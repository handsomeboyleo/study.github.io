<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ES6的语法学习</title>
    <link href="/study.github.io/2018/08/21/ES6%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/study.github.io/2018/08/21/ES6%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h1><p>ES6 = ECMAScript 6</p><h2 id="申明变量let和const"><a href="#申明变量let和const" class="headerlink" title="申明变量let和const"></a>申明变量let和const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h4 id="1、let申明变量不存在预解析；"><a href="#1、let申明变量不存在预解析；" class="headerlink" title="1、let申明变量不存在预解析；"></a>1、let申明变量不存在预解析；</h4><pre><code>console.log(flag);let flag = 123;//结果：报错</code></pre><h4 id="2、let声明的变量不允许重复"><a href="#2、let声明的变量不允许重复" class="headerlink" title="2、let声明的变量不允许重复"></a>2、let声明的变量不允许重复</h4><pre><code>let flag = 123;let flag = 456;console.log(flag);</code></pre><h4 id="3、ES6引入了块级作用域"><a href="#3、ES6引入了块级作用域" class="headerlink" title="3、ES6引入了块级作用域"></a>3、ES6引入了块级作用域</h4><p>块内部定义的变量，在外部无法访问(PS: 只要被 { } 包裹起来，就形成块级作用域)</p><pre><code>if (true){    let flag = 123;}console.log(flag);</code></pre><h4 id="4、let必须先声明在使用"><a href="#4、let必须先声明在使用" class="headerlink" title="4、let必须先声明在使用"></a>4、let必须先声明在使用</h4><p>因为用let申明的变量没有预解析</p><pre><code>tem = 123;let tem;  //报错</code></pre><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const声明的常量不能被重新赋值，且在申明的同时就要被初始化</p><pre><code>const n = 1;//申明的同时就要初始化n = 2;//此处报错</code></pre><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><pre><code>// var a =1,b=2,c=3;//js中的写法let [a,b,c] = [1,2,3];//node中 数组的解构赋值console.log(a,b,c);// 1 2 3//声明时赋初值let [a=123,b,c] = [,456,];console.log(a,b,c);// 123 456 undefined</code></pre><p>利用解构赋值交换两个变量的值</p><pre><code>let a = 1;let b = 2;[a, b] = [b, a];console.log(a,b);// 2 1</code></pre><p>对象的解构赋值</p><pre><code>let {foo,bar} = {foo : &#39;hello&#39;,bar : &#39;hi&#39;};console.log(foo,bar);</code></pre><p>字符串的解构赋值</p><pre><code>let [a,b,c,d,e] = &quot;hello&quot;;console.log(a,b,c,d,e);//h e l l o</code></pre><h2 id="字符串相关扩展"><a href="#字符串相关扩展" class="headerlink" title="字符串相关扩展"></a>字符串相关扩展</h2><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>include(str [,index]) str 所要匹配的字符串 ； index 从什么位置开始匹配</p><pre><code>console.log(&#39;hello world&#39;.includes(&#39;world&#39;);//trueconsole.log(&#39;hello world&#39;.includes(&#39;world&#39;,7);//false</code></pre><h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h3><p>判断字符串是否特定字符串开始</p><pre><code>console.log(&#39;admin/index.php&#39;.startsWith(&#39;admin&#39;));// true</code></pre><h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h3><p>判断字符串是否特定字符串结束</p><pre><code>console.log(&#39;admin/index.php&#39;.startsWith(&#39;php&#39;));// true</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>在js中若要拼接字符串</p><pre><code>var obj = {    name:&#39;张三&#39;,    age:13,    gender:&#39;男&#39;}var str = &#39;&lt;div&gt;&lt;span&gt;&#39;+obj.name+&#39;&lt;/span&gt;&lt;span&gt;&#39;+obj.age+&#39;&lt;/span&gt;&lt;span&gt;&#39;+obj.gender+&#39;&lt;/span&gt;&lt;/div&gt;&#39;;console.log(str);//&lt;div&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;/div&gt;</code></pre><p>利用模板字符串进行拼接</p><pre><code>let obj = {    name:&#39;张三&#39;,    age:13,    gender:&#39;男&#39;}let str = &#39;&lt;div&gt;                &lt;span&gt;${obj.name}&lt;/span&gt;                &lt;span&gt;${obj.age}&lt;/span&gt;                &lt;span&gt;${obj.gender}&lt;/span&gt;               &lt;span&gt;${1+1}&lt;/span&gt;               &lt;span&gt;${fn(&#39;你好&#39;)}&lt;/span&gt;          &lt;/div&gt;&#39;;console.log(str);//&lt;div&gt;//    &lt;span&gt;张三&lt;/span&gt;//    &lt;span&gt;13&lt;/span&gt;//    &lt;span&gt;男&lt;/span&gt;//      &lt;span&gt;2&lt;/span&gt;//      &lt;span&gt;你好&lt;/span&gt;//&lt;/div&gt;</code></pre><h2 id="函数的相关扩展"><a href="#函数的相关扩展" class="headerlink" title="函数的相关扩展"></a>函数的相关扩展</h2><p>1、参数的默认值</p><p>2、参数的解构赋值</p><p>3、rest参数</p><p>4、…扩展运算符</p><p>5、箭头函数</p><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>在js中的若要给函数参数指定默认值</p><pre><code>function foo(param){    let p = param || &#39;hello&#39;;    console.log(p);}//foo();//foo(&#39;nihao&#39;);</code></pre><p>在ES6中给函数参数指定默认值</p><pre><code>function foo(param = &#39;hello&#39;){    console.log(p);}//foo();//foo(&#39;nihao&#39;);</code></pre><h3 id="参数的解构赋值"><a href="#参数的解构赋值" class="headerlink" title="参数的解构赋值"></a>参数的解构赋值</h3><p>默认参数的做法</p><pre><code>function foo(param = &#39;hello&#39; , age = 12){    console.log(param,age);}//foo();//foo(&#39;nihao&#39;,18);</code></pre><p>参数的解构赋值的做法</p><pre><code>function foo({param,age}}){    console.log(param,age);}//foo({});  //注意 此时一定要传入一个对象//添加默认参数function foo({param = &#39;hello&#39;,age = 12}}){    console.log(param,age);}//foo({});  //注意 此时一定要传入一个对象//foo({param = &#39;nihao&#39;,age = 18})</code></pre><h3 id="rest参数（剩余参数）"><a href="#rest参数（剩余参数）" class="headerlink" title="rest参数（剩余参数）"></a>rest参数（剩余参数）</h3><pre><code>function foo(a,b,...param){ //...param会以数组的形式存储剩余的参数    console.log(param);}foo(1,2,3,4,5,6,7);//[3,4,5,6,7]</code></pre><h3 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h3><p>使用 … 将数组拆撒后入参</p><pre><code>function foo(a,b,c,d){    console.log(a + b + c + d);}//foo(1,2,3,4);//传统调用方式//当要传入一个数组时 arr = [1,2,3,4]//方法一 使用foo.apply(null,arr);//方法二 使用 ...   将数组拆散foo(...arr); //10</code></pre><p>使用 … 合并数组</p><pre><code>let arr1 = [1,2,3];let arr2 = [4,5,6];let arr3 = [...arr1,...arr2];console.log(arr3);//[1,2,3,4,5,6]</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code>//传统函数声明以及调用function foo(参数列表){    函数体}foo();//ES6 中新增的函数申明以及调用  =&gt;let foo = (形参参数列表) =&gt; {函数体};foo(实参列表);//用处 例子var arr = [1,2,3,4];//arr.forEach(function(e,index){//    console.log(e);//      console.log(index);//});arr.forEach((e,index) =&gt; {console.log(e);console.log(index)});</code></pre><p>箭头函数的注意事项</p><p>1、箭头函数中this取决于函数的定义，而不是函数的调用</p><pre><code>//不使用箭头函数时 this取决于调用者  此时是windowvar obj = {    name:&quot;张三&quot;,    doSomething: function(){        setTimeout(function(){            console.log(this);        },1000);    }}obj.doSomething();//window//使用箭头函数中的this 取决函数声明的环境 此时是在obj中声明的  则this指向objvar obj = {    name:&quot;张三&quot;,    doSomething: function(){        setTimeout(()=&gt;{            console.log(this);        },1000);    }}obj.doSomething();//obj{name:&quot;张三&quot;}</code></pre><p>2、箭头参数不可以new</p><p>3、箭头函数不可以使用arguments获取参数列表，可以使用rest代替</p><pre><code>let foo = (...param) =&gt; console.log(param);foo(1,2,3,4);</code></pre><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><pre><code>let a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].keys(); //Array.keys()  返回数组的所有下标[0,1,2]console.log(a.next());  //迭代返回当前位置的下标 0console.log(a.next());  //1console.log(a.next());  //2let b = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].values(); //Array.values()  返回数组的所有值console.log(b.next());  //迭代返回当前位置的值  aconsole.log(b.next());  //bconsole.log(b.next());  //c//数组查找{    console.log([1,2,3,4,5,6].find((item)=&gt;{  //find 返回满足条件的第一个元素值        return item&gt;3;    }));    console.log([1,2,3,4,5,6].filter((item)=&gt;{  //filter 返回满足条件的所有元素值        return item&gt;3;    }));    console.log([1,2,3,4,5,6].findIndex((item)=&gt;{ //findIndex 返回满条件的第一个元素下标        return item&gt;3;    }));}//数组包含{    let arr = [123,456,7,8,9,NaN];    console.log(arr.includes(456));//Array.includes(item);在数组中查询有无item元素 返回boolean    //也可以查询有无非数字    console.log([1,2,NaN].includes(1));    console.log([1,2,NaN].includes(NaN));}</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6新增数据类型 属于基本数据类型，Symbol不可以new</p><p>Symbol声明的变量是唯一的，意义在于减少命名冲突；</p><pre><code>{    //Symbol的变量是唯一的，所以a1和a2永远不相等    let a1 = Symbol();    let a2 = Symbol();    console.log(a1 === a2);   //Symbol.for(key)   //在使用Symbol时  会生成一个全局注册表，其中的数据以键值对的形式存在；能根据key来拿到对应的value   //若  a3  a4的key是相同的  那么a3 a4是相同的    let a3 = Symbol.for(&quot;a3&quot;);    let a4 = Symbol.for(&quot;a3&quot;);    console.log(a3 === a4);  //true    //问题  若改变a3的值  a4的值会改变吗？    //是值复制   还是指针}</code></pre><h2 id="ES6中涉及到的数据结构"><a href="#ES6中涉及到的数据结构" class="headerlink" title="ES6中涉及到的数据结构"></a>ES6中涉及到的数据结构</h2><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><p>数组中的元素可以重复，且数组中元素的排列是有序的（因此可以通过下标访问）</p><h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><p>集合的元素是唯一的，不可以重复出现，且集合中的元素是无序的（因此无法通过下标访问集合中的元素）</p><h4 id="Set中的方法"><a href="#Set中的方法" class="headerlink" title="Set中的方法"></a>Set中的方法</h4><table><thead><tr><th align="center"><strong>set.add(ele)</strong></th><th align="center"><strong>向set集合中追加ele元素</strong></th></tr></thead><tbody><tr><td align="center"><strong>set.has(ele)</strong></td><td align="center"><strong>判断set集合中是否存在ele元素</strong></td></tr><tr><td align="center"><strong>set.delete(ele)</strong></td><td align="center"><strong>从集合中删除ele元素</strong></td></tr><tr><td align="center"><strong>set.clear()</strong></td><td align="center"><strong>清空set集合</strong></td></tr><tr><td align="center"><strong>set.forEach( (ele) =&gt;{} )</strong></td><td align="center"><strong>遍历集和</strong></td></tr></tbody></table><p>set对象的创建：</p><pre><code>let set = new set();</code></pre><h3 id="数组与集合的互相转换"><a href="#数组与集合的互相转换" class="headerlink" title="数组与集合的互相转换"></a>数组与集合的互相转换</h3><h4 id="数组-gt-集合"><a href="#数组-gt-集合" class="headerlink" title="数组==&gt;集合"></a>数组==&gt;集合</h4><pre><code>let arr = [1,2,3];let set = new set(arr);</code></pre><h4 id="集合-gt-数组"><a href="#集合-gt-数组" class="headerlink" title="集合==&gt;数组"></a>集合==&gt;数组</h4><pre><code>let set = new set();let arr = [...set];</code></pre><h3 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h3><p><strong>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有下面区别。</strong></p><p> 1.WeakSet 的成员只能是对象，而不能是其他类型的值。</p><p> 2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不 再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p> 3.WeakSet 只有add/delete/clear/has三个方法，不能遍历，没有size属性等</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map也是由键值对构成的，和对象的区别在于Map的key也可以是一个对象，Object只可以是字符串</p><h2 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h2><h3 id="代理Proxy"><a href="#代理Proxy" class="headerlink" title="代理Proxy"></a>代理Proxy</h3><p>代理：通过代理对象访问目标对象</p><p>作用：</p><p> 1、控制目标对象的访问权限</p><p> 2、扩展目标对象方法</p><p>创建目标对象</p><pre><code>let targetObject = {    name:&quot;target&quot;,    type:&quot;object&quot;,    fun:function(){        console.log(&#39;目标对象的fun&#39;);    }}</code></pre><p>创建代理对象</p><pre><code>var p = new Proxy(targetObject,{    //target 就是目标的对象    //key 就是目标对象中的每一个属性和方法    //当代理对象直接获取属性和方法的等信息的时候都会来调用get方法    get(target,key){        if(key === &#39;fun&#39;){            console.log(&quot;代理对象调用目标对象的fun&quot;);        }        return target[key];    },    //当给对象的属性和方法赋值的时候调用set方法    //target 就是目标的对象    //key 就是目标对象中的每一个属性和方法    //value 属性值    set(target,key,value){    //如果key为type的时候就不给目标对象赋值        if(key === &#39;type&#39;){            return target[type];        }        else{            target[key] = value;        }    },    //当通过 xx in obj 的时候调用has方法    has(target,key){        if(key === &#39;type&#39;){            return false;        }        else{            return true;        }    },    //当删除对象的属性时 调用此方法    deleteProperty(target,key){        if(key === &#39;age&#39;){            delete target[key];            return true;        }        else{            return false;        }    }});p.fun(); //代理对象调用目标对象的fun     目标对象的funp.name = &#39;temp&#39;; //修改无效  当使用点的方式来访问属性时 会调用set函数  而set函数中设置了对name的修改权限console.log(p);  //{ name: &#39;target&#39;, type: &#39;object&#39;, fun: [Function: fun] }p.type = &#39;temp&#39;; //修改成功  set中没有对type的权限要求console.log(p); //{ name: &#39;target&#39;, type: &#39;temp&#39;, fun: [Function: fun] }console.log(&#39;type&#39; in p); //true  当使用in判断对象中是否有某属性时 会调用has函数 而我们在has中对type设置了权限 则无法访问console.log(&#39;name&#39; in p); //true  未对name设置  则访问成功delete p.name;  //删除失败   当使用点的方式来删除某属性时会默认调用deleteProperty方法 而我们在deleteProperty中限制了对name的删除权限 则删除失败delete p.type;  //删除成功   console.log(p); //{ name: &#39;target&#39;, fun: [Function: fun] }</code></pre><h3 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h3><p> 反射机制是指程序在运行的时候访问、检测和修改它本身状态或行为的一种能力，例如一个对象能够在运行时知道自己有哪些方法和属性。</p><p> 反射的概念在编译型的编程语言中比较明显，比如java、C#、Object-c等。对于 <code>JavaScript</code>来说，反射就是获取对象的内部结构的信息，所以JS中的反射随处可见，比如for…in方式遍历对象。</p><p> 从ECMAScript6开始，JS引入Reflect这个API专门用于操作反射。</p><p> ES6中的反射，将抛出异常，异常捕获简化为返回一个boolean值来表示其是否正常运行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cookie session</title>
    <link href="/study.github.io/2018/08/20/cookie-session/"/>
    <url>/study.github.io/2018/08/20/cookie-session/</url>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>npm init -y</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install express-cookie --save</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="引入与配置"><a href="#引入与配置" class="headerlink" title="引入与配置"></a>引入与配置</h4><pre><code>const cookieParser = require(&#39;cookie-parser&#39;);//中间件 签名app.use(cookieParser(&#39;howlcn&#39;));</code></pre><h4 id="用cookie储存信息"><a href="#用cookie储存信息" class="headerlink" title="用cookie储存信息"></a>用cookie储存信息</h4><pre><code>res.cookie(&#39;username&#39;,req.body.username,{    maxAge:1000*60, //cookie失效的时长（单位毫秒）    signed:true//开启签名 方式用户篡改cookie});</code></pre><h4 id="清空cookie"><a href="#清空cookie" class="headerlink" title="清空cookie"></a>清空cookie</h4><pre><code>res.cookie();</code></pre><h4 id="获取cookie中的数据"><a href="#获取cookie中的数据" class="headerlink" title="获取cookie中的数据"></a>获取cookie中的数据</h4><pre><code>let username = req.signedCookies.username;//获取cookie中的username</code></pre><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session底层还是调用了cookie</p><p><img src="https://i.loli.net/2019/05/30/5cef97889476388883.png" srcset="/study.github.io/img/loading.gif" alt="session"></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre><code>npm init -y</code></pre><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install express-session --save</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="引入与配置-1"><a href="#引入与配置-1" class="headerlink" title="引入与配置"></a>引入与配置</h4><pre><code>const express = require(&#39;express&#39;);const app = express();const expressSession = require(&#39;express-session&#39;);//配置expressSession中间件app.use(expressSession({    //cookie的名字    name:&#39;howlcn&#39;,    //cookie签名的信息    secret:&#39;howlcn&#39;,    cookie:{        maxAge:100000    },    resave:false,    //saveUninitialized为true时会将没有初始化的session的数据保存到storage中    //一般没有初始化的session是没有数据的  不必保存  则设置为false    saveUninitialized: false,    //为true时，某客户端每一次访问都会重置cookie的重置时间(maxAge)    rolling:true,    //指定session数据存放的地方(数据库),默认保存在服务器内存中（null也是）    store:null}));</code></pre><h4 id="用session存储数据"><a href="#用session存储数据" class="headerlink" title="用session存储数据"></a>用session存储数据</h4><pre><code>req.session.username = username;</code></pre><h4 id="清空session"><a href="#清空session" class="headerlink" title="清空session"></a>清空session</h4><pre><code>req.session.destroy()</code></pre><h4 id="获取session中的信息"><a href="#获取session中的信息" class="headerlink" title="获取session中的信息"></a>获取session中的信息</h4><pre><code>let username = req.session.username;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nuxt基本使用心得</title>
    <link href="/study.github.io/2018/08/19/Nuxt%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/study.github.io/2018/08/19/Nuxt%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p> Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染(SSR)的 Vue 应用提供了极其便利的开发体验。</p><p> Vue.js是开发SPA单页面应用的，传统的SPA应用是将bundle.js从服务端获取，然后在客户端解析并挂载到dom。</p><p> Nuxt这个框架是用Vue开发多页应用，并在服务端渲染。我们可以将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p> Nuxt适合做新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要做到是移动端项目，就没有必要用nuxt这个框架了。</p><p>Nuxt是基于Vue.js的服务端渲染框架，可以很好的解决SPA应用程序的首次加载问题。</p><pre><code>Nuxt.js有如下特点：Vue 2 ： nuxt是基于Vue2开发的Vue Router  ： nuxt整合了路由功能，配置非常简单VueX  ： 支持vuexVue Server Renderer  ： 支持服务端渲染Vue-meta  ： 支持meta标签配置</code></pre><p>Nuxt机制图示</p><p>未使用Nuxt：</p><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/noNuxt.png" srcset="/study.github.io/img/loading.gif" alt="noNuxt"></p><p>使用Nuxt：</p><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/nuxt.png" srcset="/study.github.io/img/loading.gif" alt="nuxt"></p><h2 id="二、创建Nuxt项目"><a href="#二、创建Nuxt项目" class="headerlink" title="二、创建Nuxt项目"></a>二、创建Nuxt项目</h2><p><a href="https://zh.nuxtjs.org/guide/installation/#新手模板" target="_blank" rel="noopener">新手模板</a></p><p>确保安装了npx（npx在NPM版本5.2.0默认安装了）</p><pre><code>$ npx create-nuxt-app &lt;项目名&gt;</code></pre><p>或者使用yarn:</p><pre><code>$ yarn create nuxt-app &lt;项目名&gt;</code></pre><p>配置：</p><p>启动</p><pre><code>npm run dev</code></pre><p>访问</p><pre><code>http://localhost:3000</code></pre><h2 id="三、Nuxt基本使用"><a href="#三、Nuxt基本使用" class="headerlink" title="三、Nuxt基本使用"></a>三、Nuxt基本使用</h2><h3 id="3-1-路由"><a href="#3-1-路由" class="headerlink" title="3.1 路由"></a>3.1 路由</h3><pre><code>//pages文件夹下面，文件名即路由#1.pages下新建search.vue&lt;template&gt;  &lt;div&gt;    这是search页面  &lt;/div&gt;&lt;/template&gt;//2.index.vue使用路由 此处的search就是所创建的search.vue的文件名&lt;nuxt-link to=&quot;/search&quot;&gt;到search页面&lt;/nuxt-link&gt;</code></pre><h3 id="3-2-嵌套子模版"><a href="#3-2-嵌套子模版" class="headerlink" title="3.2 嵌套子模版"></a>3.2 嵌套子模版</h3><pre><code>#index.vue&lt;template&gt;      &lt;section class=&quot;container&quot;&gt;            &lt;div&gt;              &lt;logo/&gt;             &lt;/div&gt;      &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import Logo from &#39;~/components/Logo.vue&#39;export default {  components: {    Logo  }}&lt;/script&gt;</code></pre><h3 id="3-3-layouts布局文件"><a href="#3-3-layouts布局文件" class="headerlink" title="3.3 layouts布局文件"></a>3.3 layouts布局文件</h3><p> 默认情况下所有的页面都会默认使用layouts下面default.vue这个布局文件</p><pre><code>#default.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;头部&lt;/h1&gt;    &lt;!--nuxt就相当于 router-view--&gt;    &lt;nuxt/&gt;                         &lt;h1&gt;尾巴&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>当然也可以创建自定义的布局文件</p><pre><code>//自定义布局文件//1.layouts下新建一个user.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;用户页面头部&lt;/h1&gt;    &lt;nuxt/&gt;    &lt;h1&gt;用户页面底部&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{  }&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;  h1{    color:green  }&lt;/style&gt;//2.pages下的search.vue指定使用哪个布局文件&lt;script&gt;  export default{    layout:&quot;user&quot;  }&lt;/script&gt;</code></pre><h3 id="3-4-全局CSS文件"><a href="#3-4-全局CSS文件" class="headerlink" title="3.4 全局CSS文件"></a>3.4 全局CSS文件</h3><p> 此css 文件将在所有组件中自动生效</p><pre><code>#1.在assets下新建css/main.css#2.修改nuxt.config.css配置文件后/*** global css*/css: [    &#39;element-ui/lib/theme-chalk/index.css&#39;,    &#39;~assets/css/main.css&#39;],#3.重启服务(配置文件的修改，重启后才能生效)</code></pre><h3 id="3-5-Vuex的使用"><a href="#3-5-Vuex的使用" class="headerlink" title="3.5 Vuex的使用"></a>3.5 Vuex的使用</h3><p> 在nuxt中使用vuex的时候无需new Vue.Store实例，nuxt会帮我们自动创建。默认情况下，会使用index.js这个store。</p><p> 每次修改增加Vuex时要重启服务</p><pre><code>#1.store/index.js//state存放数据export const state = () =&gt; ({  list: [&#39;a&#39;,&#39;b&#39;],  user:{}})//修改stateexport const mutations = {  increment (state,text) {    state.list.push(text);  },}//异步提交mutationsexport const actions = {}#2.store/city.jsexport const state = () =&gt; ({  list: [&#39;c&#39;,&#39;d&#39;]})export const mutations = {  increment (state,text) {    state.list.push(text);  }}</code></pre><p>在vue文件中使用vuex</p><ol><li>使用store/index.js中的state时 <code>$store.state.list</code></li><li>使用store/city.js中的state时 <code>$store.state.city.list</code></li></ol><pre><code>#3.pages/city.vue&lt;template&gt;  &lt;div&gt;    Page is city    &lt;ul&gt;      &lt;li        v-for=&quot;(item,idx) in $store.state.list&quot;        :key=&quot;idx&quot;&gt; {{ item }}        &lt;/li&gt;      &lt;input        type=&quot;button&quot;        value=&quot;增加信息index&quot;        @click=&quot;addIndex&quot;&gt;      &lt;li        v-for=&quot;(item,idx) in $store.state.city.list&quot;        :key=&quot;idx&quot;&gt; {{ item }}       &lt;/li&gt;    &lt;/ul&gt;    &lt;input      type=&quot;button&quot;      value=&quot;增加信息city&quot;      @click=&quot;addCity&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import axios from &quot;axios&quot;  export default{    data(){      return {        list:[]      }    },    methods: {      addIndex(){        this.$store.commit(&#39;increment&#39;, &quot;kk&quot;)      },      addCity(){        this.$store.commit(&#39;city/increment&#39;, &quot;jj&quot;)      }    }  }&lt;/script&gt;</code></pre><h2 id="四、SPA-SEO-SSR"><a href="#四、SPA-SEO-SSR" class="headerlink" title="四、SPA\SEO\SSR"></a>四、SPA\SEO\SSR</h2><h3 id="4-1-SPA-单页面应用"><a href="#4-1-SPA-单页面应用" class="headerlink" title="4.1 SPA:单页面应用"></a>4.1 SPA:单页面应用</h3><blockquote><p>SPA 时代，主要是在客户端端使用了<code>history</code>或<code>hash</code>（主要是为了低版本浏览器的兼容）API，在首次请求经服务端路由输出整个应用程序后，接下来的路由都由前端掌控了，前端通过路由作为中心枢纽控制一系列页面（组件）的渲染(DOM的生成)加载和数据交互。</p></blockquote><p>优点：</p><ol><li>页面之间的切换非常快</li><li>一定程度减少了后端服务器的压力</li><li>实现前后端分离，后端程序只需要提供api，不需要客户端到底是web端还是手机等</li></ol><p>缺点：</p><ol><li>首屏打开速度很慢</li><li>不利于SEO搜索引擎优化</li></ol><h3 id="4-2-SEO-搜索引擎优化"><a href="#4-2-SEO-搜索引擎优化" class="headerlink" title="4.2 SEO:搜索引擎优化"></a>4.2 SEO:搜索引擎优化</h3><blockquote><p>SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</p><p>由于SPA使用Ajax动态获取数据，很难保证搜索引擎的正常爬取，并且有些搜索引擎不支持js和Ajax获取的数据，因此SSR诞生</p></blockquote><h3 id="4-3-SSR-服务器端渲染"><a href="#4-3-SSR-服务器端渲染" class="headerlink" title="4.3 SSR:服务器端渲染"></a>4.3 SSR:服务器端渲染</h3><blockquote><p>为了解决SPA不支持SEO的问题，我们也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，但是这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。</p></blockquote><p>基本流程：当客户端向服务器发送请求后，web服务器根据路由拿到对应数据渲染并输出，且输出部分中包含两部分：</p><ol><li>路由页对应的页面及已渲染好的数据（解决首屏加载）</li><li>完整的SPA程序代码 （本地路由跳转，而不请求服务器）</li></ol><p>优点：</p><ol><li>更好的 SEO（搜索引擎爬虫抓取工具可以直接查看完全渲染的页面）</li><li>更快的内容到达时间 （不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了）</li></ol><p>缺点：</p><ol><li>占用更多的cpu和内存资源</li><li>一些常用的浏览器的api可能无法正常使用 （如：window，document，alert）</li><li>开发调试会有一些麻烦 （因为涉及到了浏览器及服务器，对于SPA的一些组件的声明周期的管理会变得复杂）</li></ol><h3 id="4-4-Nuxt对SSR支持"><a href="#4-4-Nuxt对SSR支持" class="headerlink" title="4.4 Nuxt对SSR支持"></a>4.4 Nuxt对SSR支持</h3><blockquote><p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 <a href="https://nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a> 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。</p><p>Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于Vue的SSR框架，预设了利用Vue.js开发<strong>服务端渲染</strong>的应用所需要的各种配置，使用它你可以不需要自己搭建一套 SSR 程序，而是通过其约定好的文件结构和API就可以实现一个首屏渲染的 Web 应用。</p><p>Nuxt.js 主要关注的是应用的 UI渲染。</p></blockquote><p><a href="https://juejin.im/post/58ff960ba22b9d0065b722cd" target="_blank" rel="noopener">实现基于 Nuxt.js 的 SSR 应用</a></p><h2 id="五、数据预取"><a href="#五、数据预取" class="headerlink" title="五、数据预取"></a>五、数据预取</h2><h3 id="5-1-准备服务器接口"><a href="#5-1-准备服务器接口" class="headerlink" title="5.1 准备服务器接口"></a>5.1 准备服务器接口</h3><pre><code>#1.server/interface/city.jsvar express = require(&#39;express&#39;)var router = express.Router()router.get(&#39;/info&#39;, function (req, res) {    return res.status(200).json([&#39;北京&#39;,&#39;天津&#39;])})module.exports = router#2.server/index.jsconst cityInterface = require(&quot;./interface/city&quot;)//在app.use(nuxt.render)上面添加app.use(&quot;/city&quot;,cityInterface)app.use(&quot;/city&quot;,cityInterface);app.use(nuxt.render)#.重启服务localhost:3000/city/info  测试接口</code></pre><h3 id="5-2-不适用数据预取"><a href="#5-2-不适用数据预取" class="headerlink" title="5.2 不适用数据预取"></a>5.2 不适用数据预取</h3><pre><code>#1.客户端pages下新建city.vue&lt;template&gt;  &lt;div&gt;    Page is city    &lt;ul&gt;      &lt;li        v-for=&quot;(item,idx) in list&quot;        :key=&quot;idx&quot;&gt; {{ item }} &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import axios from &quot;axios&quot;  export default{    data(){      return {        list:[]      }    },    //async表示方法返回一个Promise    //await 同步等待    async mounted(){      let {status,data} = await axios.get(&quot;/city/info&quot;);      this.list = data;      console.log(this.list);    }  }&lt;/script&gt;</code></pre><h3 id="5-3-Nuxt-js的工作流"><a href="#5-3-Nuxt-js的工作流" class="headerlink" title="5.3 Nuxt.js的工作流"></a>5.3 Nuxt.js的工作流</h3><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/1546049173524.png" srcset="/study.github.io/img/loading.gif" alt="1546049173524"></p><ul><li>nuxtServerInit：如果在状态树(store)中指定了 <code>nuxtServerInit</code> 方法，Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（仅在服务端调用）。当我们想将服务端的一些数据传到客户端时，这个方法是非常好用的</li><li>middleware：中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前，服务端首屏渲染和路由跳转前均执行对应中间件。可以用作页面跳转时验证用户信息操作(登陆拦截)。</li><li>asyncData会在组件加载前（限于页面组件）调用，可以在<strong>服务端首屏渲染或者在路由跳转时执行</strong>，专门用来请求数据，Nuxt.js 会将 <code>asyncData</code> 返回的数据融合组件 <code>data</code> 方法返回的数据一并返回给当前组件。asyncData应该是用于影响SEO的内容，也就是需要让爬虫读取的内容。</li></ul><h3 id="5-4-服务端数据预取"><a href="#5-4-服务端数据预取" class="headerlink" title="5.4 服务端数据预取"></a>5.4 服务端数据预取</h3><h4 id="nuxtServerInit"><a href="#nuxtServerInit" class="headerlink" title="nuxtServerInit"></a>nuxtServerInit</h4><blockquote><p>nuxtServerInit可以将服务端的数据通过vuex同步到客户端，该方法仅会在服务端首屏渲染时执行</p></blockquote><pre><code>#store/index.jsexport const state = () =&gt; ({  list: [],})export const mutations = {  setlist (state,text) {    text.forEach(item=&gt;{      state.list.push(item)    })  },}export const actions = {  //将菜单信息写入到vuex实例中  async nuxtServerInit ({ commit }, { req ,app }) {    {      let {status, data} = await app.$axios.get(&quot;/city/info&quot;);      commit(&#39;setlist&#39;, data)    }  }}#2.pages/city.vue&lt;template&gt;  &lt;div&gt;    Page is city    &lt;ul&gt;      &lt;li        v-for=&quot;(item,idx) in $store.state.list&quot;        :key=&quot;idx&quot;&gt; {{ item }} &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="asyncData和fetch方法"><a href="#asyncData和fetch方法" class="headerlink" title="asyncData和fetch方法"></a>asyncData和fetch方法</h4><pre><code>//使用asyncData进行ssr渲染async asyncData(){    //给data取别名，请求网址写全，因为在刷新浏览器的时候需要全路径请求服务器    let {status,data:list} = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;);    if(status == 200) {        //这边不能使用this.list = list,因为获取不到this        //通过return给页面返回数据        return {            list        }    }}async fetch ({ store, params }){      //当页面加载时触发可以执行请求来触发action来修改state      //不可以return数据给页面      //页面可以从this.$store中获取action修改的state      let {status,data:list} = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;);      store.commit(&#39;setlist&#39;, list)}</code></pre><p>注意点：asyncData 和 fetch都只能够在页面组件中使用，如果想要在页面组件的子组件中使用ssr，可以使用nuxtServerInit<br>#注意点：由于 asyncData方法是在组件初始化前被调用的，所以在方法内是没有办法通过this来引用组件的实例。<br>#注意点：当用户请求页面时候服务端会先使用SSR来生成对应的页面文档结构，而在用户切换路由则是使用了SPA的模式。这意味着如果用户刷新页面，asyncData方法会在服务端执行；如果用户通过nuxt-link路由导航到当前页面，asyncData会在客户端执行</p><h3 id="5-5客户端数据预取"><a href="#5-5客户端数据预取" class="headerlink" title="5.5客户端数据预取"></a>5.5客户端数据预取</h3><blockquote><p>当asyncData方法是由路由跳转触发的时候，则使用客户端数据预取，asyncData方法会在客户端执行。可以通过控制台打印来查看是在浏览器执行还是在node执行就可以验证了。</p></blockquote><pre><code>async asyncData(context){    //给data取别名，请求网址写全    let {status,data:list} = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;);    //如果是客户端执行，则可以使用window对象    //如果是服务端执行，则没有window对象    if(process.client){        console.log(window)    }    if(status == 200) {        //这边不能使用this.list = list,因为获取不到this        //通过return给页面返回数据        return {            list        }    }}</code></pre><h2 id="六、SSR原理"><a href="#六、SSR原理" class="headerlink" title="六、SSR原理"></a>六、SSR原理</h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180524/92672015b4914784ae5a800c4a655e25.jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a></p><p>如上图所示：webpack将 Source 打包出两个bundle文件。</p><ul><li><p>服务端渲染：Server Bundle用于服务端渲染，主要是获取异步数据，同步到组件中，并将组件渲染成HTML返回到前端，但是<strong>vue-ssr不能绑定javascript事件</strong>，也就是说服务器端使用vue-ssr渲染出来的返回到浏览器的也只能是HTML+CSS。</p></li><li><p>客户端渲染：Client Bundle 用于客户端渲染，之前说过服务器不能增加事件，那只能前端增加。所以我们看到SSR渲染的网页源码中有</p><pre><code>window.__NUXT__=...</code></pre><p>代码，这是后端和前端在使用vuex共享数据。后端从vuex里面取到数据之后渲染成真正的HTML和css返回。客户端也是从vuex里面取到数据，客户端的渲染主要做2件事：</p><ul><li>拿到数据，使用 virtual-dom进行预渲染，然后和服务端渲染出来的进行比对，比对两边渲染的内容是不是一致的</li><li>对DOM元素的事件进行绑定，也就是回答的问题，事件在这块进行的处理</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Get与Post的区别及联系</title>
    <link href="/study.github.io/2018/08/12/Get%E4%B8%8EPost%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E8%81%94%E7%B3%BB/"/>
    <url>/study.github.io/2018/08/12/Get%E4%B8%8EPost%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E8%81%94%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="GET与POST的区别与联系"><a href="#GET与POST的区别与联系" class="headerlink" title="GET与POST的区别与联系"></a>GET与POST的区别与联系</h2><p>GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。</p><p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p><p>你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。</p><p>当你在面试中被问到这个问题，你的内心充满了自信和喜悦。</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLcm8TfMjvKvXwbzXTbpUaahYNVFpXh8fIMgqcmbIeEBqFTt7ibiaewMicg/640?wx_fmt=png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>你轻轻松松的给出了一个“标准答案”：</p><ul><li><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p></li><li><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p></li><li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p></li><li><p>GET请求只能进行url编码，而POST支持多种编码方式。</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p></li><li><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p></li><li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p></li><li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p></li><li><p>GET参数通过URL传递，POST放在Request body中。</p></li></ul><p>（本标准答案参考自w3schools）</p><p>“很遗憾，这不是我们要的回答！”</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLkCV5yUI4QFlaibOg9aFp2ZjPlaeAgaibbYyzOYsmcDfPlzFPAdcy21dQ/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>请告诉我真相。。。</p><p>如果我告诉你GET和POST本质上没有区别你信吗？</p><p>让我们扒下GET和POST的外衣，坦诚相见吧！</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLVXZkPZibSibtVZoIkDcBTQJ3mFibpNtqOSNTLDs01s2rmB6PyCoibjczxQ/640?wx_fmt=png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>那么，“标准答案”里的那些区别是怎么回事？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLdhmQxXtz2Kwn3yzT8Jzic1joUsjXxeaU8JwerDiabz9N9sYmBpIgWic2A/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p><p>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLSDX3EiadGp0gDsHwgvGictCwWSEaAQ4jVib1sLaqnBGpFAUhHhjv8xGKQ/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p><p>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>你以为本文就这么结束了？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLNqLBKzbCAfuLHkM355iaBC9FuOlWrtiaIUmD95T8ReVJ9FInZIZWV0YA/0?" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>我们的大BOSS还等着出场呢。。。</p><p>这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。</p><p>GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><p>\1. GET与POST都有自己的语义，不能随便混用。</p><p>\2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p><p>\3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p><p>现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLyfrfWEnMQlicIoNbaQJCicpKjOVQp8tNjU9Zp8Eia40om3vTah9aZEF7w/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>转自<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">在途中#</a>文章写的太生动了，忍不住copy一份，哈哈哈…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云服务器的搭建</title>
    <link href="/study.github.io/2018/07/28/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/07/28/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="云服务器的搭建"><a href="#云服务器的搭建" class="headerlink" title="云服务器的搭建"></a>云服务器的搭建</h1><h2 id="一、搭建Https本地服务器"><a href="#一、搭建Https本地服务器" class="headerlink" title="一、搭建Https本地服务器"></a>一、搭建Https本地服务器</h2><h3 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h3><p>在本地磁盘上新建一个HttpsTest文件夹,用来存放测试文件</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/24.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="2-初始化以及express安装"><a href="#2-初始化以及express安装" class="headerlink" title="2.初始化以及express安装"></a>2.初始化以及express安装</h3><p>接下来用以下命令初始化文件夹以及安装express矿建</p><pre><code>npm init -ynpm install express --save</code></pre><p>之后会生成以下三个文件</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/25.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="3-建立https-js文件"><a href="#3-建立https-js文件" class="headerlink" title="3.建立https.js文件"></a>3.建立https.js文件</h3><p>新建一个https.js文件,该文件后续会写入服务器测试代码</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/26.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="4-安装openssl"><a href="#4-安装openssl" class="headerlink" title="4.安装openssl"></a>4.安装openssl</h3><p>openssl 用于生成自签名证书(免费，本地测试使用)</p><h4 id="4-1安装"><a href="#4-1安装" class="headerlink" title="4.1安装"></a>4.1安装</h4><p>如果电脑中已有git,直接右键<code>git bush here</code>即可,忽略以下安装步骤</p><p>若没有,可以安装openssl安装包,下载地址<a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p><p>找到对应的exe文件下载安装即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/27.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>安装完成后配置环境变量,把openssl安装路径bin的路径（例如 C:\OpenSSL-Win64\bin）加入到操作系统的系统环境变量Path中</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/28.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><blockquote><p>重启电脑!!!切记,是个好习惯</p></blockquote><h4 id="4-2验证"><a href="#4-2验证" class="headerlink" title="4.2验证"></a>4.2验证</h4><p>验证openssl是否生效,打开cmd,输入<code>openssl</code>若能跳转,则安装完成</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/29.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="5-生成证书"><a href="#5-生成证书" class="headerlink" title="5.生成证书"></a>5.生成证书</h3><p>cmd进入openssl后,输入命令生成Private Key 和 CSR</p><pre><code>req -new -newkey rsa:2048 -nodes -out mydomain.csr -keyout private.key</code></pre><p>ps:若用git则需要加openssl,下同</p><pre><code>openssl req -new -newkey rsa:2048 -nodes -out mydomain.csr -keyout private.key</code></pre><p>生成自签名证书</p><p>使用上一步的private.key和mydomain.csr生成自签名证书,输入以下命令</p><pre><code>x509 -req -days 365 -in mydomain.csr -signkey private.key -out mydomain.crt</code></pre><p>完成后会得到以下几个文件</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/30.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="6-完善https-js以及测试"><a href="#6-完善https-js以及测试" class="headerlink" title="6.完善https.js以及测试"></a>6.完善https.js以及测试</h3><p>在http.js中输入以下代码搭建服务器</p><pre><code>var express = require(&quot;express&quot;);var app = express();var fs = require(&#39;fs&#39;);var key = fs.readFileSync(&#39;./private.key&#39;);var cert = fs.readFileSync(&#39;./mydomain.crt&#39;);var options = {    key: key,    cert: cert};// Run static servervar https = require(&#39;https&#39;);https.createServer(options, app.get(&#39;/&#39;, function (req, reb) {    reb.send(&#39;Success!&#39;)})).listen(3000, function () {    console.log(&#39;Running...&#39;)});</code></pre><p>到此基本处理完成,下面开始测试</p><p>运行https.js</p><p>在浏览器中输入<a href="https://www.javascriptcn.com/go/?target=https%3A%2F%2Flocalhost">https://localhost</a>:3000</p><p>浏览器会显示<code>您的连接是不是私密连接</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/31.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击<code>高级</code>选项,再点击<code>继续前往</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/32.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>当看到页面返回<code>Success!</code>时,即表示https服务搭建成功</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/33.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>可以通过点击网站信息,点击证书查看证书信息</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/34.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/35.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><blockquote><p>由于我们证书是自己创建的，没有经过第三方机构的验证，因此会出现警告的提示。大家可以去有资质的网络运营商，去申请自己的证书。比如：<a href="http://www.godaddy.com/ssl/ssl-certificates.aspx" target="_blank" rel="noopener">godaddy SSL Certificates</a>，优惠码：<strong>WOWfensme</strong></p></blockquote><h2 id="二、搭建腾讯云Https网络服务器"><a href="#二、搭建腾讯云Https网络服务器" class="headerlink" title="二、搭建腾讯云Https网络服务器"></a>二、搭建腾讯云Https网络服务器</h2><h3 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h3><p>进入腾讯云官网,用微信登录账号(若提示是否创建新账号,点击创建新账号)往下翻,找到<code>域名与网站</code>功能菜单,点击</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/1.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击域名注册</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/2.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击<code>域名1元抢</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/3.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>进入页面后<code>.club</code>和<code>.xyz</code>域名都是一年一元,按喜好任选即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/4.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击之后,再输入框中输入自己的想要创建的域名,点击查询,如果不可以购买,说明已被抢注,需要换其他名称</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/5.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>购买完成之后,点击页面右上角控制台,即可进入管理中心,看到自己购买的域名</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/6.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/7.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/8.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>之后,在该页面点击实名认证,域名都要通过实名认证才可以使用,填写相关信息即可</p><h3 id="2-购买服务器"><a href="#2-购买服务器" class="headerlink" title="2.购买服务器"></a>2.购买服务器</h3><p>接下来准备购买服务器,在腾讯云官网有15天免费体验,可以先进行试用</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/9.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>这一部分都可以免费试用,我们主要需要<code>云服务器</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/10.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击领取之后会有默认配置可以选择,操作系统的话,如果熟悉Linux可以使用Cent OS,否则选择windows server即可</p><p>接下来免费付款即可</p><p>完成之后,右上角会有消息提示,点击查看消息,即可看到购买的服务器的登录密码和相关信息</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/11.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="3-服务器配置"><a href="#3-服务器配置" class="headerlink" title="3.服务器配置"></a>3.服务器配置</h3><p>接下来需要配置服务器</p><p>1.首先登录云服务器控制台</p><p>2.在实例列表中可以看到自己的服务器,点击登录</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/12.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>3.在弹出的【登录Windows实例】窗口中，选择【使用 RDP 文件登录】，单击【下载 RDP 文件】到本地。</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/13.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>4.双击下载到本地的 RDP 文件，远程连接到 Windows 云服务器。</p><p>到此服务器基本设置完成,接下来需要在服务器中安装node,sublime等等(强烈推荐vscode)</p><h3 id="4-域名配置"><a href="#4-域名配置" class="headerlink" title="4.域名配置"></a>4.域名配置</h3><p>在完成实名认证后,点击控制台,进入域名管理,点击解析</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/14.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击添加记录,基本格式按以下图片内容写</p><p><strong>注意:其中记录值换成你自己购买的服务器的公网ip</strong></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/15.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>这样域名已经与服务器进行绑定</p><h3 id="5-https连接测试"><a href="#5-https连接测试" class="headerlink" title="5.https连接测试"></a>5.https连接测试</h3><p>以下都是在云服务器中操作</p><p>1.要搭建https的连接,先要下载ssl证书管理,在腾讯云官网中,点击控制台,云产品,ssl证书</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/16.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>2.点开之后会看到如下</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/17.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>3、点击申请证书，默认选择即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/18.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>4、填写信息完毕后，选择“自动DNS验证”，将自动为域名添加DNS记录，如下图：</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/19.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>5、等候证书通过，通过后点击下载</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/20.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>6、然后把这两个文件放到服务器磁盘中(新建一个usr文件夹,放入其中,记住他的绝对路径)</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/21.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>7.在服务器中安装Nginx,进行反向代理,这是Nginx的官网</p><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p><p>下载解压即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/22.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>7、修改Nginx下面的conf文件夹下nginx.conf文件添加如下代码,删去中文</p><pre><code>server {    listen              443 ssl;    server_name         gw2.vsgames.cn;    ssl_certificate     /Users/wucao/Desktop/gw2.vsgames.cn/Nginx/1_gw2.vsgames.cn_bundle.crt;  # 证书文件地址    ssl_certificate_key /Users/wucao/Desktop/gw2.vsgames.cn/Nginx/2_gw2.vsgames.cn.key; # 私钥文件地址    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers         HIGH:!aNULL:!MD5;    location / {        root /usr/share/nginx/html;    }}</code></pre><p>配置好点击nginx.exe重启Nginx</p><p>8.接下来在node中编写代码,将秘钥和证书地址改为自己的</p><pre><code>const https = require(&#39;https&#39;);const fs = require(&#39;fs&#39;);const options = {  key: fs.readFileSync(&#39;/Users/wucao/Desktop/gw2.vsgames.cn/Nginx/2_gw2.vsgames.cn.key&#39;),//秘钥地址  cert: fs.readFileSync(&#39;/Users/wucao/Desktop/gw2.vsgames.cn/Nginx/1_gw2.vsgames.cn_bundle.crt&#39;)//证书地址};https.createServer(options, function(req, res) {  res.statusCode = 200;  res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);  res.end(&#39;Hello World\n&#39;);}).listen(8000);</code></pre><p>开启服务器</p><p>输入你的域名地址加端口号,例如<code>https://howlcn.cn:8000</code></p><p>出现<code>hello world</code>说明搭建成功</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/23.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>若直接域名访问,则将监听端口设为80即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack的基本使用心得</title>
    <link href="/study.github.io/2018/07/20/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/study.github.io/2018/07/20/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack的基本使用"><a href="#webpack的基本使用" class="headerlink" title="webpack的基本使用"></a>webpack的基本使用</h1><p>1、webpack能够处理JS文件之间相互依赖的关系</p><p>2、webpack能够处理JS的兼容性问题，将高级的、浏览器无法识别的语法转为低级的浏览器能识别的语法</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装webpack</p><pre><code>npm install -g webpacknpm install webpack@3.0.0 -g  //安装指定版本</code></pre><p>全局安装脚手架()</p><pre><code>npm i webpack-cli -g</code></pre><h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>这里以隔行换色为例：</p><p>先构建文件目录如下：</p><p><img src="https://howlcn1997.github.io/2018/04/02/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E7%9B%AE%E5%BD%95.png" srcset="/study.github.io/img/loading.gif" alt="目录"></p><p>其中node_modules文件夹是安装其他包自动构建的</p><p>安装我们要用到的包，这里使用了jquery</p><pre><code>npm i jquery</code></pre><p>index.html中写入代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!-- 不推荐在这里直接引用任何css script --&gt;    &lt;!-- 所有的引用都在main.js中写 --&gt;    &lt;!-- 因为main.js中用了ES6的语法，浏览器不兼容，此时就需要webpack来预处理 --&gt;    &lt;!-- &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;这是第1个li&lt;/li&gt;        &lt;li&gt;这是第2个li&lt;/li&gt;        &lt;li&gt;这是第3个li&lt;/li&gt;        &lt;li&gt;这是第4个li&lt;/li&gt;        &lt;li&gt;这是第5个li&lt;/li&gt;        &lt;li&gt;这是第6个li&lt;/li&gt;        &lt;li&gt;这是第7个li&lt;/li&gt;        &lt;li&gt;这是第8个li&lt;/li&gt;        &lt;li&gt;这是第9个li&lt;/li&gt;        &lt;li&gt;这是第10个li&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在main中写入代码</p><pre><code>//这是入口js文件//导入jqueryimport $ from &#39;jquery&#39;$(function(){    $(&#39;li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;skyblue&#39;);    $(&#39;li:even&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;)})</code></pre><p>用webpack处理mian.js</p><p>命令行中键入</p><pre><code>webpack ./src/main.js ./dist/bundle.js</code></pre><p><code>./src/main.js</code>是要处理的文件路径</p><p><code>./dist/bundle.js</code>是处理之后需要保存到的路径</p><p>此时将<code>main.js</code>处理成<code>bundle.js</code>,此时我们就可以在html页面中直接引入<code>bundle.js</code>了</p><pre><code>&lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt;</code></pre><p>完成效果</p><p><img src="https://howlcn1997.github.io/2018/04/02/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E6%95%88%E6%9E%9C.png" srcset="/study.github.io/img/loading.gif" alt="1561981889615"></p><h2 id="基本配置文件的使用"><a href="#基本配置文件的使用" class="headerlink" title="基本配置文件的使用"></a>基本配置文件的使用</h2><p>每当我们将<code>mian.js</code>中的内容做出变化时，都要手动输入 <code>webpack ./src/main.js ./dist/bundle.js</code>命令来重新生成<code>bundle.js</code>,过于麻烦，这里可以设置配置文件以达到，只需要输入<code>webpack</code>就可以达到重新生成bundle.js的目的</p><p>在项目根目录下创建<code>webpack.config.js</code>文件，进行配置</p><pre><code>const path = require(&#39;path&#39;);//这个配置文件，其实就是一个js文件，通过Node中的模块操作，向外暴露了一个对象module.exports = {    //手动指定入口 和 出口    //入口，表示要使用webpack打包哪个文件    entry: path.join(__dirname,&#39;./src/main.js&#39;),    //输入文件相关属性    output: {        path: path.join(__dirname,&#39;./dist&#39;),//指定打包好的文件，输出到哪个目录中去        filename: &#39;bundle.js&#39; //指定 输出文件名称    }}</code></pre><h2 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server</h2><p>之前代码每做一次改变都要在命令行键入<code>webpack</code>，过于麻烦，为了进一步偷懒，我们可以利用<code>webpack-dev-server</code>工具来实现。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>命令行键入</p><pre><code>npm i webpack-dev-server -D  //将此工具安装到项目的本地开发依赖npm i webpack -D   //项目中安装webpacknpm i webpack-cli -D   //项目中安装webpack-cli</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>webpack-dev-server</code>的使用方式同<code>webpack</code>一样，（这让我想到了<code>node</code> 与 nodemon`的关系）</p><pre><code>webpack-dev-server   //暂不可用</code></pre><p>注意：1、由于我们是在项目本地中安装的，无法在powershell中直接使用，我们可以在package.json中，在scripts中添加<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>，配置如下</p><pre><code>{    &quot;name&quot;: &quot;01-webpack&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;&quot;,    &quot;main&quot;: &quot;index.js&quot;,    &quot;scripts&quot;: {        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,        &quot;dev&quot;: &quot;webpack-dev-server&quot;    },    &quot;keywords&quot;: [],    &quot;author&quot;: &quot;&quot;,    &quot;license&quot;: &quot;ISC&quot;,    &quot;dependencies&quot;: {        &quot;jquery&quot;: &quot;^3.4.1&quot;    },    &quot;devDependencies&quot;: {        &quot;webpack-dev-server&quot;: &quot;^3.7.2&quot;    }}</code></pre><p>2、由于webpack-dev-server是依赖于webpack的，所以我们呢必须要在项目中本地安装webpack和脚手架</p><p>3、由于webpack-dev-server打包的文件并没有存放在磁盘上，而是暂存在内存中，导致我们的改变<code>main.js</code>时没有效果，它相当于在项目根目录生成了一个看不见的文件，</p><p>所以我们在script引入时，应直接应用根目录下</p><pre><code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>npm run dev</code></pre><h2 id="使用html-webpack-plugin"><a href="#使用html-webpack-plugin" class="headerlink" title="使用html-webpack-plugin"></a>使用html-webpack-plugin</h2><p>使得html页面也可以被加载到内存中，提高代码开发效率</p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><pre><code>npm i html-webpack-plugin -D</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>在main.js中引入</p><pre><code>const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);</code></pre><p>在plugins中配置</p><pre><code>plugins: [    //配置插件的节点    new webpack.HashedModuleIdsPlugin(), //new 一个热更新的 模块对象     new htmlWebpackPlugin({  //创建一个 在内存中生成HTML 页面的插件        //指定 模板页面，将来会根据指定的页面的路径，去生成内存中的 页面        template: path.join(__dirname,&#39;./src/index.html&#39;),        // 指定 生成的页面的名称        filename: &#39;index.html&#39;    })]</code></pre><h2 id="webpack-处理第三方不是文件类型的过程"><a href="#webpack-处理第三方不是文件类型的过程" class="headerlink" title="webpack 处理第三方不是文件类型的过程"></a>webpack 处理第三方不是文件类型的过程</h2><ol><li>当发现要处理的文件不是js文件时，回去配置文件中查找有无对应的第三方loader规则；</li><li>如查找到对应规则，会调用对应的一系列loader处理此文件类型；</li><li>调用use中一系列的loader时，会从后向前调用，第一个loader的处理结果会返回给下一个；loader，直到当前loader为最后一个loader；</li><li>当最后一个loader处理完毕时，会将执行结构返回给webpack进行打包合并处理，并输出到bundle.js中去。</li></ol><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><strong>由于webpack默认只能处理js文件，非js文件要使用loader加载器</strong></p><h3 id="loader处理css"><a href="#loader处理css" class="headerlink" title="loader处理css"></a>loader处理css</h3><p>在index.html中不推荐直接引入css，这样可能会导致客户端项服务器发送第二次请求，这里使用第三方loader，利用webpack将css打包到bundle.js中去。</p><p>处理css需要两个loader加载器</p><ul><li>style-loader</li><li>css-loader</li></ul><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install style-loader css-loader -D</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在webpack.config.js中新增一个配置节点module，他是一个对象；在这个module对象上有一个rules属性，这个属性是一个数组，存放了所有第三方的 匹配 和 处理规则。</p><pre><code>module: {    rules: [        {test: /\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;]}    ]}</code></pre><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>在main.js中引入css</p><pre><code>import &#39;./css/index.css&#39;</code></pre><h3 id="loader处理less"><a href="#loader处理less" class="headerlink" title="loader处理less"></a>loader处理less</h3><p>处理less需要三个个loader加载器</p><ul><li>style-loader</li><li>css-loader</li><li>less-loader</li></ul><h4 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install style-loader css-loader less-loader -D</code></pre><p>注意：若之前已经安装了<code>style-loader</code> <code>css-loader</code>，仅需要安装<code>less-loader</code> 即可</p><pre><code>npm install less-loader -D</code></pre><p>若要正常使用less-loader，还需要一个less依赖项，安装less</p><pre><code>npm install less -D</code></pre><p>注意：此处的less是内部依赖于less-loader的，则无需再main.js中引入</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在module中的rules中添加配置</p><pre><code>{test: /\.less$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]}</code></pre><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><pre><code>main.js`中引入`index.lessimport &#39;./css/index.less&#39;</code></pre><h3 id="loader处理scss"><a href="#loader处理scss" class="headerlink" title="loader处理scss"></a>loader处理scss</h3><p>处理less需要三个个loader加载器</p><ul><li>style-loader</li><li>css-loader</li><li>sass-loader (坑：这里是sass 而文件名是.scss)</li></ul><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install sass-loader -D</code></pre><p>安装内部依赖项</p><pre><code>npm install node-sass -D</code></pre><p>注意此处安装node-sass若失败，请切换cnpm进行安装</p><pre><code>npm install cnpm -gcnpm install node-sass -D</code></pre><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><pre><code>{test: /\.scss$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]}</code></pre><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><pre><code>main.js`中引入`index.scssimport &#39;./css/index.scss&#39;</code></pre><h3 id="loader处理css中的图片"><a href="#loader处理css中的图片" class="headerlink" title="loader处理css中的图片"></a>loader处理css中的图片</h3><p>当css中出现引用图片时，webpack会解码出错，如</p><pre><code>body {    background: url(./images/temp.jpg);}</code></pre><p>之所以出错，是由于对url的解析出错，这里需要用到url-loader；</p><p>处理图片需要两个loader加载器</p><ul><li>url-loader</li><li>file-loader</li></ul><h4 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install url-loader file-loader -D</code></pre><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><pre><code>{test: /\.(png|jpg|gif|bmp|jpeg)$/, use: &#39;url-loader?limit=1024$name=[hash:8]-[name].[ext]&#39;}</code></pre><p>该loader会默认将要加载的图片转码为base64的字符串替换url原本的位置，使其可以直接加载在页面上；</p><p>其中：</p><ul><li>limit 当图片大小超过此属性对应的值时，不将其转码为base64，否则转为base64</li><li>name 设置由url-loader处理之后的文件名<ul><li>[hash: 8] 设置文件名开头为随机的8位哈希值</li><li>[name] 设置文件名结束为文件的原本名字</li><li>[ext] 设置后缀名为文件原本的后缀名</li></ul></li></ul><p>示例：当文件<code>test.png</code>大小大于limit时，文件被处理为<code>3hu4ye89-test.png</code></p><h4 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h4><p>在css中使用</p><pre><code>body {  background: url(../images/test.png);}</code></pre><p>并将此css文件引入main.js中</p><h3 id="loader处理字体图标的问题"><a href="#loader处理字体图标的问题" class="headerlink" title="loader处理字体图标的问题"></a>loader处理字体图标的问题</h3><p>当我们使用第三方字体图标时（如bootstrap.css）时，若文件声明某种字体时而利用url去引用其他文件时，在webpack打包时便会报错。</p><p>处理图片需要一个loader加载器</p><ul><li>url-loader</li></ul><h4 id="安装-7"><a href="#安装-7" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install url-loader -D</code></pre><p>其实上一步已经安装，无需再次安装。</p><h4 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h4><pre><code>{test: /\.(ttf|eot|svg|woff|woff2)$/, use: &#39;url-loader&#39;}</code></pre><h4 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h4><p>这里以<code>bootstrap</code>为例：</p><p>安装<code>bootstrap</code></p><pre><code>npm install bootstrap@3.3.5 --save</code></pre><p><code>index.html</code>中输入</p><pre><code>&lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;</code></pre><p><code>main.js</code>中引入</p><pre><code>import &#39;bootstrap/dist/css/bootstrap.css&#39;</code></pre><p>注意：这里不能直接引入<code>import &#39;bootstrap&#39;</code></p><h2 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h2><p>由于webpack只能处理部分ES6的代码，所以为了更好的兼容ES6我们需要引入babel来达到目的。将ES6以上的语法自动转换成当前浏览器可以识别的ES最高版本的语法。</p><h3 id="安装-8"><a href="#安装-8" class="headerlink" title="安装"></a>安装</h3><h4 id="安装babel的转码工具"><a href="#安装babel的转码工具" class="headerlink" title="安装babel的转码工具"></a>安装babel的转码工具</h4><pre><code>npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev</code></pre><h4 id="安装babel转换的语法"><a href="#安装babel转换的语法" class="headerlink" title="安装babel转换的语法"></a>安装babel转换的语法</h4><pre><code>npm i babel-preset-env babel-preset-stage-0 --save-dev</code></pre><h3 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h3><p> 1、在webpack.config.js中配置</p><pre><code>{test: /\.js$/, use: &#39;babel-loader&#39;, exclude: /node_modules/}</code></pre><p> 2、在项目根目录下新建一个名为 <code>.babelrc</code>的babel配置文件,文件中键入内容</p><pre><code>{    &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;],    &quot;plugins&quot;: [&quot;transform-runtime&quot;]}</code></pre><p>注意：该文件是严格遵从<code>json</code>格式的。</p><p>其中:</p><ul><li>presets 中配置语法插件 (相当于高级语法翻译成低级语法的字典)</li><li>plugins中配置属于babel的插件（相当于翻译器）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Express服务器的搭建</title>
    <link href="/study.github.io/2018/07/14/Express%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/07/14/Express%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>是基于Node.js平台，快速、开放极简的web开发框架</p><p>初始化</p><pre><code>npm init -y  //加-y时 会以默认参数创建package.json文件   若不加 可以自定义package.json参数信息</code></pre><p>安装</p><pre><code>npm install express -save</code></pre><p>自动重启服务器工具</p><pre><code>npm install nodemon  //若要使用该工具  在启动服务器时要使用nodemon命令 如 nodemon ./server.js</code></pre><p>路径的匹配</p><pre><code>//匹配student开头，而且后面跟了学号   http://localhost:8000/student/1234app.get(&quot;/student/:id/:name&quot;,function(req,res){    var id = req.params[&quot;id&quot;];    var name = req.params[&quot;name&quot;];    res.send(id+name);});</code></pre><h2 id="中间件的另一种使用方式"><a href="#中间件的另一种使用方式" class="headerlink" title="中间件的另一种使用方式"></a>中间件的另一种使用方式</h2><pre><code>const express = require(&#39;express&#39;);const app = express();var f1 = (req,res,next)=&gt;{    console.log(1);    next();}var f2 = (req,res,next)=&gt;{    console.log(2);    next();}var f3 = (req,res,next)=&gt;{    console.log(3);    res.send();}app.use(&#39;/user&#39;,[f1,f2,f3]);app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);})</code></pre><h2 id="next注意点"><a href="#next注意点" class="headerlink" title="next注意点"></a>next注意点</h2><p>有如下代码：</p><pre><code>const express = require(&#39;express&#39;);const app = express();//无门槛进入  只要是localhost:3000就会响应app.use((req,res,next)=&gt;{    console.log(&#39;有用户进入...函数一&#39;);    next(); //通关文牒},(req,res,next)=&gt;{         console.log(&#39;有用户进入...函数二&#39;);    next();});app.use(&#39;/user&#39;,(req,res,next)=&gt;{    console.log(&#39;访问结束&#39;);    res.send(&#39;用户页面&#39;+total);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);})</code></pre><p><strong>next() 不加参数时会指向下一个执行函数，即函数一中的next()会指向函数二</strong></p><pre><code>const express = require(&#39;express&#39;);const app = express();//无门槛进入  只要是localhost:3000就会响应app.use((req,res,next)=&gt;{    console.log(&#39;有用户进入...函数一&#39;);    next(&#39;/user&#39;); //通关文牒},(req,res,next)=&gt;{         console.log(&#39;有用户进入...函数二&#39;);    next();});app.use(&#39;/user&#39;,(req,res,next)=&gt;{    console.log(&#39;访问结束&#39;);    res.send(&#39;用户页面&#39;+total);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);})</code></pre><p><strong>next(‘/user’) 加参数时，会跳转至下一个路径为/user的use函数，即跳过函数二直接来到下一个use函数</strong></p><h2 id="body-parser的使用"><a href="#body-parser的使用" class="headerlink" title="body-parser的使用"></a>body-parser的使用</h2><p><strong>作用：可以获取post请求中信息</strong></p><p>安装</p><pre><code>npm install body-parser --save</code></pre><p>使用</p><pre><code>const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);//若要获取post中的参数 则必须以此挂载bodyparser中间件app.use(bodyParser.urlencoded({extended: false}));app.use(express.static(&#39;views&#39;));app.post(&#39;/login&#39;,(req,res)=&gt;{    res.send(&#39;name:&#39;+req.body.username);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h2><pre><code>const express = require(&#39;express&#39;);const app = express();app.get(&#39;/index&#39;,(req,res,next)=&gt;{    try{        let a = null;        console.log(a.toString()); //null不能调用toString()  此处故意制造错误        next();    }catch(e){        next(e); //转至错误处理中间件    }});//错误处理中间件（注意。错误处理中间件 要用use）app.use((err,req,res,next)=&gt;{    // res.send(err); 无法打印    res.send(err.toString());});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="指定静态资源"><a href="#指定静态资源" class="headerlink" title="指定静态资源"></a>指定静态资源</h2><pre><code>const express = require(&#39;express&#39;);const app = express();app.use(express.static(&#39;views&#39;));//指定views文件夹为静态资源文件夹  若该文件夹中存在login.html 则可以通过http:localhost:3000/login.html来直接访问该页面</code></pre><h2 id="Router类的使用"><a href="#Router类的使用" class="headerlink" title="Router类的使用"></a>Router类的使用</h2><p>1、先创建一个需要js文件，每一个js文件就是一个类</p><p>每一个js文件中的写法</p><pre><code>const express = require(&#39;express&#39;);const router = express.Router(); //创建router类router.get(&#39;/c1&#39;,(req,res)=&gt;{  //设置请求响应函数  /c1为访问路径    res.send(&#39;/c1&#39;);});router.post(&#39;/c2&#39;,(req,res)=&gt;{//设置请求响应函数    res.send(&#39;/c2&#39;);});module.exports = router;  //将router暴露出去</code></pre><p>2、当创建若干js文件（类）之后，用一个js文件进行汇总使用，相当于入口文件 此处创建server.js</p><p>写法</p><pre><code>const express = require(&#39;express&#39;);const app = express();const chang = require(&#39;./chang&#39;); //引入自定义的类//...app.use(&#39;/chang&#39;,chang);  //访问方式 localhost:3000/chang/c1     //此处用use指定的/chang只是虚拟路径 并不存在真实的物理路径//app.use(chang);   //访问方式 localhost:3000/c1 //...//app.use(.....)app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><p>这种使用方式相当于自定义了中间件后，再在server中使用。</p><h2 id="art-template的使用"><a href="#art-template的使用" class="headerlink" title="art-template的使用"></a>art-template的使用</h2><h3 id="art-template在前台的使用"><a href="#art-template在前台的使用" class="headerlink" title="art-template在前台的使用"></a>art-template在前台的使用</h3><p><strong>下载</strong><a href="http://aui.github.io/art-template/docs/installation.html" target="_blank" rel="noopener">art-template-web</a></p><p>1、将art-template-web.js引入到页面</p><pre><code>&lt;script src=&quot;./template-web.js&quot;&gt;&lt;/script&gt;</code></pre><p>2、在页面中定义一个模板</p><pre><code>&lt;/body&gt;//此script标签相当于一个容器&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; //注意 此处一定要加上  type=&quot;text/html&quot;    {{each users}}        &lt;h1&gt;{{$value.name}}&lt;/h1&gt;        &lt;li&gt;{{$value.age}}&lt;/li&gt;        &lt;li&gt;{{$value.gender}}&lt;/li&gt;        &lt;li&gt;{{$value.love}}&lt;/li&gt;    {{/each}}&lt;/script&gt;&lt;script&gt;    var data = {        users:[{name: &#39;张三&#39;, age: 12, gender: &#39;女&#39;, love: &#39;唱&#39;},               {name: &#39;李四&#39;, age: 13, gender: &#39;男&#39;, love: &#39;跳&#39;},               {name: &#39;王五&#39;, age: 14, gender: &#39;女&#39;, love: &#39;rap&#39;},               {name: &#39;蔡徐坤&#39;, age: 15, gender: &#39;女&#39;, love: &#39;篮球&#39;}]    }    //如果数组中都是对象，且要访问对象内的值时要使用$value.xxx  value代表当前遍历到的数组元素    var html = template(&#39;test&#39;,data);    var box = document.getElementById(&#39;box&#39;);    box.innerHTML = html;&lt;/script&gt;&lt;/html&gt;</code></pre><p>另一种实现方式</p><pre><code>&lt;script&gt;    //当使用此法时 模板字符串拼接时  每一个标签要单独用 &quot;&quot; 括起来    var artt = &quot;{{each users}}&quot;+        &quot;&lt;h1&gt;{{$value.name}}&lt;/h1&gt;&quot;+        &quot;&lt;li&gt;{{$value.age}}&lt;/li&gt;&quot;+        &quot;&lt;li&gt;{{$value.gender}}&lt;/li&gt;&quot;+        &quot;&lt;li&gt;{{$value.love}}&lt;/li&gt;&quot;+    &quot;{{/each}}&quot;;    var render = template.compile(artt);    var data = {        users:[{name: &#39;张三&#39;, age: 12, gender: &#39;女&#39;, love: &#39;唱&#39;},                {name: &#39;李四&#39;, age: 13, gender: &#39;男&#39;, love: &#39;跳&#39;},                {name: &#39;王五&#39;, age: 14, gender: &#39;女&#39;, love: &#39;rap&#39;},                {name: &#39;蔡徐坤&#39;, age: 15, gender: &#39;女&#39;, love: &#39;篮球&#39;}]    }    //如果数组中都是对象，且要访问对象内的值时要使用$value.xxx  value代表当前遍历到的数组元素    var html = render(data);    var box = document.getElementById(&#39;box&#39;);    box.innerHTML = html;&lt;/script&gt;</code></pre><h3 id="art-template在后台中的使用"><a href="#art-template在后台中的使用" class="headerlink" title="art-template在后台中的使用"></a>art-template在后台中的使用</h3><p>初始化</p><pre><code>npm init -y</code></pre><p>安装</p><pre><code>npm install art-template --savenpm install express-art-template --save</code></pre><p>使用</p><pre><code>const express = require(&#39;express&#39;);const app = express();//指定art-template渲染的文件后缀是htmlapp.engine(&#39;html&#39;,require(&#39;express-art-template&#39;));//指定静态资源目录app.use(express.static(&#39;views&#39;));</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>wamp环境的搭建</title>
    <link href="/study.github.io/2018/07/10/wamp%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/07/10/wamp%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="wamp环境搭建"><a href="#wamp环境搭建" class="headerlink" title="wamp环境搭建"></a>wamp环境搭建</h1><h2 id="一、wamp简介"><a href="#一、wamp简介" class="headerlink" title="一、wamp简介"></a>一、wamp简介</h2><p>wamp是Windows Apache MySQL PHP的简称</p><p>Windows 操作系统</p><p>Apache 提供网页服务(html js css img)</p><p>MySQL 数据库</p><p>PHP 编程语言，可以用来开发动态网站</p><h2 id="二、下载与安装"><a href="#二、下载与安装" class="headerlink" title="二、下载与安装"></a>二、下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>根据电脑系统下载 <a href="https://pan.baidu.com/s/1b_8fp8Qsj9laXzxIeO5XCQ" target="_blank" rel="noopener">wampServer2.4 x86 x64</a> 提取码:i3ti.</p><p>（推荐安装32位）</p><h3 id="安装前须知"><a href="#安装前须知" class="headerlink" title="安装前须知"></a>安装前须知</h3><p>1 确保电脑安装了<a href="https://pan.baidu.com/s/1OfOwL8Qd6MCV8kSppBn6yA" target="_blank" rel="noopener">Microsoft Visual C++ 2012 Redistributable</a>提取码:0u1t;</p><p>2 更新了<a href="https://pan.baidu.com/s/1_COl7-dFJZI-sjH3NzQ5Vg" target="_blank" rel="noopener">KB2999226</a> 提取码:s6w7;</p><p>3 已卸载原有的数据库和Apache.</p><p>安装wamp，傻瓜式安装即可.</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>打开wamp 当任务栏中的W变为绿色，且再浏览器中输入localhost回车后出现wamp界面则本地服务器运行成功</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%AE%89%E8%A3%85%E6%A3%80%E6%B5%8B.png" srcset="/study.github.io/img/loading.gif" alt="安装检测"></p><h2 id="三、配置访问权限"><a href="#三、配置访问权限" class="headerlink" title="三、配置访问权限"></a>三、配置访问权限</h2><h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><p>想要其他设备访问到你的本地服务器需要进行如下操作</p><p>打开 wamp –&gt; bin –&gt; apache –&gt; Apache2.4.4 –&gt; conf –&gt; httpd.conf文件，搜索关键词 Order</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png" srcset="/study.github.io/img/loading.gif" alt="配置访问权限"></p><p>将此行修改为</p><pre><code>Allow from all      //允许所有ip访问</code></pre><p>右击wamp任务栏图片重启服务器（刷新失效时，请重启wamp）</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1%E5%99%A8.png" srcset="/study.github.io/img/loading.gif" alt="重启服务器"></p><p>PS：你当然也可以不将Deny from all 改为Allow from all，你可以在下方指定只有那些ip可以访问，如只允许192.168.32.222访问</p><p>在下方添加</p><pre><code>Allow from 192.168.32.222</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>查询本机ip地址，cmd中键入</p><pre><code>ipconfig</code></pre><p>其中IPV4 后便是本机ip地址，如（192.168.32.2）</p><p>在另一台设备中输入192.168.32.2，回车后访问成功（若显示访问被拒绝请确认配置正确，重启wamp，关闭防火墙后重试）</p><h2 id="四、更改wamp默认服务器根目录"><a href="#四、更改wamp默认服务器根目录" class="headerlink" title="四、更改wamp默认服务器根目录"></a>四、更改wamp默认服务器根目录</h2><p>本地服务器的默认根目录是安装根目录下的www文件夹。</p><p>可在该文件夹中新建一个index.html文件，再在浏览器中输入localhost/index.html访问该页面。</p><p>更改默认目录</p><p>打开 wamp –&gt; bin –&gt; apache –&gt; Apache2.4.4 –&gt; conf –&gt; httpd.conf文件，搜索关键词 DocumentRoot</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B9%E7%9B%AE%E5%BD%95.png" srcset="/study.github.io/img/loading.gif" alt="修改默认根目录"></p><p>将此两行的路径同时修改为你所创建的文件夹所在路径：</p><p>我在桌面的ClassPC文件夹下创建了www文件夹，以此作为根目录，则DocumentRoot改为C:/Users/student/Desktop/ClassPC/www</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B9%E7%9B%AE%E5%BD%952.png" srcset="/study.github.io/img/loading.gif" alt="更改默认根目录2"></p><p>重启wamp</p><h2 id="五、虚拟主机配置"><a href="#五、虚拟主机配置" class="headerlink" title="五、虚拟主机配置"></a>五、虚拟主机配置</h2><p>配置虚拟主机，以支持多站点</p><p>我们先在之前所设置好的服务器根目录(C:/Users/student/Desktop/ClassPC/www)下，新建三个文件夹 server1 server2 server3 (一个文件夹代表一个站点)</p><h3 id="配置httpd-vhosts-conf"><a href="#配置httpd-vhosts-conf" class="headerlink" title="配置httpd-vhosts.conf"></a>配置httpd-vhosts.conf</h3><p>打开 wamp –&gt; bin –&gt; apache –&gt; Apache2.4.4 –&gt; conf –&gt; extra –&gt; httpd-vhosts.conf</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE1.png" srcset="/study.github.io/img/loading.gif" alt="虚拟主机配置1"></p><p>一个表示一个站点</p><p>将已有标签复制三份，并分别设置其DocumentRoot ServerName ServerAlias，如下图所示</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE2.png" srcset="/study.github.io/img/loading.gif" alt="虚拟主机配置2"></p><h3 id="配置计算机映射关系"><a href="#配置计算机映射关系" class="headerlink" title="配置计算机映射关系"></a>配置计算机映射关系</h3><p>打开 计算机 –&gt; C: –&gt;windows –&gt; System32 –&gt; drivers –&gt; etc –&gt; host</p><p>在最下方添加映射关系，如图</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" srcset="/study.github.io/img/loading.gif" alt="配置映射关系"></p><p>重启wamp</p><p>浏览器输入localhost/server1,显示index of/server1,访问成功！</p><p>其他机器浏览器输入192.168.32.2/server1,显示index of/server1,访问成功！</p><hr><p>更新：若有购买腾讯云等云端服务器，在将Wamp部署到服务器时，请手动关闭Wamp自带的MySQL，MySQL的运行出错可能导致Apache的假死现象。</p><p>更新：关于Apache服务器<code>(OS 64)指定的网络名不再可用。 : AH00341: winnt_accept: Asynchronous AcceptEx failed.</code>错误而导致的Apache假死现象的解决：</p><ol><li>apache版本为APAche2.0.49及以上版本，增加<code>Win32DisableAcceptEx</code>配置项</li><li>apache版本为APAche2.4及以上版本，在<code>wamp\bin\apache\Apache2.4.4\conf\httpd.conf</code>增加<code>AcceptFilter http None AcceptFilter https None</code>配置项替代<code>Win32DisableAcceptEx</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Less的使用</title>
    <link href="/study.github.io/2018/07/06/Less%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/07/06/Less%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><p>less是动态的样式表<strong>语言</strong>，通过简明的语法定义，使编写cs’s的工作变得非常简单，本质上，less包含一套自定义的语法以及i一个解析器。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、安装Nodejs环境</p><p>2、cmd中执行</p><pre><code>npm install -g less</code></pre><p>3、验证</p><pre><code>lessc -v    //若正确出现less版本号则安装成功</code></pre><h2 id="使用less编译"><a href="#使用less编译" class="headerlink" title="使用less编译"></a>使用less编译</h2><p> 先创建一个less文件 demo.less</p><pre><code>@color: #ccc;div {    color: @color;}</code></pre><p> 在当前目录下运行cmd，输入</p><pre><code>lessc demo.less demo.css</code></pre><p>运行之后会在当前目录下生成一个demo.css文件，内容为</p><pre><code>div {  color: #ccc;}</code></pre><h2 id="VsCode中使用less"><a href="#VsCode中使用less" class="headerlink" title="VsCode中使用less"></a>VsCode中使用less</h2><p> 1、添加 Easy Less 扩展插件，安装，安装完后最好重启一次VSCode；</p><p> 2、在需要生成css文件的地方，新建一个<code>.less</code>文件；</p><p> 3、保存后，会在同级目录下自动生成一个同名css文件</p><h2 id="less的基本语法"><a href="#less的基本语法" class="headerlink" title="less的基本语法"></a>less的基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>/*注释*/        这种注释方式会也会编译到css中//              这种注释方式在编译时会被去除</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p> @变量名: 值</p><pre><code>@baseColor: #eee;     //申明一个变量并赋值a {    color: @@baseColor;   //使用变量}</code></pre><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><p> 可以将一个定义好的变量引入到另一个样式中 类似于函数的调用</p><pre><code>//先写好一个样式  @r 类似于函数的形参.addRadius(@r:10px){  //也可以设置默认值    border-radius: @r;    -wekit-border-radius: @r;    -moz-border-radius: @r;}//使用样式div {    width: 200px;    height: 200px;    .addRadius(5px);}</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p> 可以实现选择器的继承，可以减少代码量，同时使代码结构更加清晰</p><pre><code>.jd_hearder {}.jd_hearder &gt; div {}.jd_hearder &gt; div &gt; h3 {}.jd_hearder &gt; div &gt; h3::before {}.jd_hearder    &gt; div &gt; a:hover {}</code></pre><p>上面是我们之前常用的写样式的方式，代码是非常冗余的，并且结构不清晰；</p><p>可以用less来解决这类问题，并且编译后的css文件，与上面的代码的效果是一样的</p><pre><code>.jd_header {    width: 100%；        height: 200px;    .addRadius();    //嵌套一个元素    div {        width: 100%;        h3 {            height: 200px;            ::before    //相当于 h3 ::before            $::before {}//相当于 h3::before     注意区别        }        a {            color: @baseColor;            $:hover {   //相当于 a:hover                text-decoration: none;            }        }    }    }</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于JavaScript中作用域/作用域链和预解析</title>
    <link href="/study.github.io/2018/07/02/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/study.github.io/2018/07/02/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析Javascript中作用域、作用域链和预解析"><a href="#浅析Javascript中作用域、作用域链和预解析" class="headerlink" title="浅析Javascript中作用域、作用域链和预解析"></a>浅析Javascript中作用域、作用域链和预解析</h1><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><pre><code>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</code></pre><p>作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p><h3 id="1-全局作用域（全局变量）"><a href="#1-全局作用域（全局变量）" class="headerlink" title="1.全局作用域（全局变量）"></a>1.全局作用域（全局变量）</h3><p><strong>全局变量，原理就是将变量挂载到window对象中.</strong></p><p><strong>全局变量拥有全局的作用域，可在任意地方被调用</strong></p><p>全局变量有两种声明方式</p><h3 id="（1）函数外部"><a href="#（1）函数外部" class="headerlink" title="（1）函数外部"></a>（1）函数外部</h3><p>(写在函数外面的都是全局变量)</p><pre><code>&lt;script&gt;    var num = 15; //全局变量        function f() {        var num = 10; //不是全局变量            function f2(){               /*----*/             }            f2();        }    f();    console.log(num); //  15&lt;/script&gt;</code></pre><h3 id="（2）函数内部"><a href="#（2）函数内部" class="headerlink" title="（2）函数内部"></a>（2）函数内部</h3><p>(不加var的变量声明，隐式全局变量)</p><pre><code>&lt;script&gt;    function f() {        num = 10; //隐式全局变量    }    f();    console.log(num); // 10&lt;/script&gt;</code></pre><h4 id="全局变量与隐式全局变量的区别"><a href="#全局变量与隐式全局变量的区别" class="headerlink" title="全局变量与隐式全局变量的区别"></a>全局变量与隐式全局变量的区别</h4><pre><code>隐式全局变量可以通过delete关键字来删除，全局变量不可以//全局变量不可被delete&lt;script&gt;    var a = 2; //全局变量    function f(){        //****    }    console.log(a); //  2    delete a;    console.log(a); //  2&lt;/script&gt;//隐式全局变量被delete&lt;script&gt;    function f(){        a = 2; //隐式全局变量    }    console.log(a); //  2    delete a;    console.log(a); //  not defined (已被删除)&lt;/script&gt;</code></pre><h3 id="2-局部作用域-局部变量"><a href="#2-局部作用域-局部变量" class="headerlink" title="2.局部作用域(局部变量)"></a>2.局部作用域(局部变量)</h3><pre><code>局部变量：写在函数体里面的变量局部变量只可以在当前函数内部使用&lt;script&gt;    function f() {        var num = 10; //局部变量        function f2(){            console.log(num); // 10        }        f2();    }    f();    console.log(num); //  not defined&lt;/script&gt;</code></pre><h2 id="二、作用域链"><a href="#二、作用域链" class="headerlink" title="二、作用域链"></a>二、作用域链</h2><p>作用域链简而言之就是，调用变量时，若当前作用域内没有该变量时就向它的上一级作用域去寻找。</p><p>Javascript用的是词法作用域（静态作用域）</p><p>实例：</p><pre><code>&lt;script&gt;    /* 0级作用域 */var a = 1;function aa(){    /* 1级作用域 */    //var a = 2;    function bb(){  /* 2级作用域 */        //var a = 3;        console.log(a);  // 1    }    bb();}aa();&lt;/script&gt;</code></pre><p>作用过程：</p><ol><li>当运行到console.log(a)时，会在当前作用域（2级作用域）内寻找是否有a可用；</li><li>若有直接使用，否则向上一级作用域（1级作用域）去寻找；</li><li>此时来到1级作用域，若此时有a可用则用，否则继续向上一级寻找，直到到达0级作用域；</li><li>此时来到0级作用域，若此时有a可用则用，否则报错；</li></ol><p><img src="https://howlcn1997.github.io/2018/02/26/%E6%B5%85%E6%9E%90Javascript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg" srcset="/study.github.io/img/loading.gif" alt="作用域链"></p><p><strong>值得注意的是：作用域链的始发点与函数的调用位置无关，而与函数的声明位置有关</strong> 例子如下：</p><pre><code>&lt;script&gt;    var value = 1;    function foo() {        console.log(value);    }    function bar() {        var value = 2;        foo();    }    bar();&lt;/script&gt;</code></pre><p>此时的打印结果为1，而不是foo函数调用所在作用域的value = 2；</p><p>这里的1是foo函数声明所在的作用域中的value = 1；</p><p>## 三、预解析</p><p>当浏览器执行Javascript代码时，为了提高执行效率会在代码解释执行前进行预解析处理。</p><p>预解析处理规则：</p><p>\1. 变量提升 仅仅将变量声明提升到当前作用域的最上面，不包括变量的赋值<br>\2. 函数提升 将函数的声明提升到当前作用域的最上面，不包括函数的调用 <strong>函数的声明会提前到变量声明之前</strong></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>实例：</p><pre><code>&lt;script&gt;    console.log(a); //undefined    var a = 10;&lt;/script&gt;</code></pre><p>上述代码结果打印为undefined,而不是10，这是为什么呢？</p><p>我们来看看与解析之后的结果，</p><p>预解析为：</p><pre><code>&lt;script&gt;    var a    console.log(a);    a = 10;&lt;/script&gt;</code></pre><p>由于变量声明被提升到作用域最前端，而赋值没有被提升，导致执行console.log(a);时 a还未被赋值。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>实例：</p><pre><code>&lt;script&gt;    f1();    function f1() {        /*-----*/    }&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function f1() {        /*-----*/    }    f1();&lt;/script&gt;</code></pre><h3 id="函数的声明会提前到变量声明之前"><a href="#函数的声明会提前到变量声明之前" class="headerlink" title="函数的声明会提前到变量声明之前"></a>函数的声明会提前到变量声明之前</h3><pre><code>函数提升和变量提升同时发生时，函数的声明会提前到变量声明之前。&lt;script&gt;    var a = 3;    function a(){        console.log(10);    }       console.log(a);    a();&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function a(){        console.log(10);    }    var a;    a = 3    console.log(a);    a(); //not function  因为此时a为变量而不是函数&lt;/script&gt;</code></pre><p><strong>值得注意的是：</strong></p><p>1.函数是可以被打印的</p><pre><code>&lt;script&gt;    function a(){    /*----*/    }console.log(a); //打印函数a&lt;/script&gt;</code></pre><p>2.变量a的赋值可以被普通类型和函数互相取代</p><pre><code>&lt;script&gt;    var a；    a = function(){        /*----*/        }    console.log(a); //打印函数a    a = 1;    console.log(a); // 1；&lt;/script&gt;</code></pre><h3 id="匿名函数的申明不遵循预解析规则"><a href="#匿名函数的申明不遵循预解析规则" class="headerlink" title="匿名函数的申明不遵循预解析规则"></a>匿名函数的申明不遵循预解析规则</h3><pre><code>&lt;script&gt;    f();  //报错    var f = function(){        /*----*/    }&lt;/script&gt;</code></pre><p>因为解析前后代码相同 执行 <strong>f()</strong> 时，f未被声明为函数类型。</p><h3 id="隐式全局变量的注意点"><a href="#隐式全局变量的注意点" class="headerlink" title="隐式全局变量的注意点"></a>隐式全局变量的注意点</h3><pre><code>&lt;script&gt;    f();    console.log(a);  //undefined    console.log(b);  //9    function f() {      var a = b = c = 9;      console.log(a); //9      console.log(b); //9    }&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function f() {      var a;  //局部变量      a = 9;        b = 9;  //隐式全局变量      console.log(a);  //9      console.log(b);  //9    }    f();    console.log(b);  //9    console.log(a);  //undefined   因为a是局部变量&lt;/script&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于JS函数的重载问题</title>
    <link href="/study.github.io/2018/06/29/JS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2018/06/29/JS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="关于Javascript的函数重载问题"><a href="#关于Javascript的函数重载问题" class="headerlink" title="关于Javascript的函数重载问题"></a>关于Javascript的函数重载问题</h1><p><strong>在Javascript与Java等语言不同，它自身没有重载的具体方法，但我们可以利用Javascript的特性来完成重载的效果</strong></p><h2 id="1-什么是重载"><a href="#1-什么是重载" class="headerlink" title="1.什么是重载"></a>1.什么是重载</h2><pre><code>重载，简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</code></pre><h2 id="2-Javascript如何实现重载"><a href="#2-Javascript如何实现重载" class="headerlink" title="2.Javascript如何实现重载"></a>2.Javascript如何实现重载</h2><h3 id="方法一：利用函数的arguments来完成函数的重载"><a href="#方法一：利用函数的arguments来完成函数的重载" class="headerlink" title="方法一：利用函数的arguments来完成函数的重载"></a>方法一：利用函数的arguments来完成函数的重载</h3><pre><code>//函数的声明function overLoading() {　　// 根据arguments.length，对不同的值进行不同的操作　　switch(arguments.length) {　　　　case 0: console.log(&#39;无参&#39;);　　　　　    break;　　　　case 1: console.log(&#39;一个参数&#39;);　　　　　    break;　　　　case 2: console.log(&#39;两个参数&#39;);              break;    } }//函数的调用overLoading();  //结果：无参overLoading(1);  //结果：一个参数overLoading(1,2);  //结果：两个参数</code></pre><h3 id="方法二：《Secrets-of-the-JavaScript-Ninja》中的方法"><a href="#方法二：《Secrets-of-the-JavaScript-Ninja》中的方法" class="headerlink" title="方法二：《Secrets of the JavaScript Ninja》中的方法"></a>方法二：《Secrets of the JavaScript Ninja》中的方法</h3><p>重载方法实例：</p><pre><code>function addMethod(object, name, fn) {　　var old = object[name];   //把前一次添加的方法存在一个临时变量old里面　　object[name] = function() {   // 重写了object[name]的方法　　　　// 如果调用object[name]方法时，传入的参数个数跟预期的一致，则直接调用　　　　if(fn.length === arguments.length) {　　　　　　return fn.apply(this, arguments);　　　　// 否则，判断old是否是函数，如果是，就调用old　　　　} else if(typeof old === &quot;function&quot;) {　　　　　　return old.apply(this, arguments);　　　　}　　}}</code></pre><p>所谓<strong>addMethod</strong>函数，简单的理解，就是给某个<strong>object</strong>，添加一个指定<strong>name</strong>的函数<strong>fn</strong>。它利用了<strong>闭包</strong>，可以通过<strong>old</strong>变量将先后绑定的函数链接起来。</p><p>你可以这样使用<strong>addMethod</strong>函数，将<strong>find</strong>函数直接添加到每个对象实例：</p><pre><code>function Users(){  addMethod(this, &quot;find&quot;, function(){      // Find All  });  addMethod(this, &quot;find&quot;, function(name){    // Find a user by name  });  addMethod(this, &quot;find&quot;, function(first, last){    // Find a user by first and last name  });}</code></pre><p>你也可以将<strong>find</strong>函数添加到对象的<strong>prototype</strong>，这样所有对象实例将共享<strong>find</strong>函数:</p><pre><code>function Users(){    addMethod(Users.prototype, &quot;find&quot;, function(){      // Find all users...    });    addMethod(Users.prototype, &quot;find&quot;, function(name){      // Find a user by name    });    addMethod(Users.prototype, &quot;find&quot;, function(first, last){      // Find a user by first and last name    });}</code></pre><p><strong>users</strong>对象的<strong>find</strong>方法成功实现了重载，可以根据不同的输入调用不同的函数：</p><pre><code>var users = new Users();users.find(); // Finds allusers.find(&quot;John&quot;); //  Finds users by nameusers.find(&quot;John&quot;, &quot;Resig&quot;); // Finds users by first and last nameusers.find(&quot;John&quot;, &quot;E&quot;, &quot;Resig&quot;); // Does nothing</code></pre><p>这种方法有一些明显的缺陷:</p><ul><li>重载只能处理输入参数个数不同的情况，它不能区分参数的类型、名称等其他要素。(ECMAScript 4计划支持这一特性，称作Multimethods，然而该版本已被放弃)。</li><li>重载过的函数将会有一些额外的负载，对于性能要求比较高的应用，使用这个方法要慎重考虑。</li></ul><p><strong>addMethod</strong>函数的秘诀之一在于<strong>fn.length</strong>。或许很多人并不清楚，所有函数都有一个<strong>length</strong>属性，它的值等于定义函数时的参数个数。比如，当你定义的函数只有1个参数时，其<strong>length</strong>属性为1：</p><pre><code>(function(foo){}).length == 1</code></pre><p>如果你担心只绑定单个函数时的性能问题，你可以使用如下<strong>addMethod</strong>函数：</p><pre><code>function addMethod(object, name, fn){    var old = object[ name ];    if ( old )        object[ name ] = function(){            if ( fn.length == arguments.length )                return fn.apply( this, arguments );            else if ( typeof old == &#39;function&#39; )                return old.apply( this, arguments );        };    else        object[ name ] = fn;}</code></pre><p>这样绑定第一个函数时，将不会有额外的操作，既简单又快速。当绑定更多函数时，则与原<strong>addMethod</strong>函数一样，会有额外的性能损失。</p><p>这样做还有一个额外的好处：对于那些参数个数不符合要求的函数调用，将统一又第一个绑定的函数处理。这时调用<strong>find</strong>方法的输出如下：</p><pre><code>var users = new Users();users.find(); // Finds allusers.find(&quot;John&quot;); // Finds users by nameusers.find(&quot;John&quot;, &quot;Resig&quot;); // Finds users by first and last nameusers.find(&quot;John&quot;, &quot;E&quot;, &quot;Resig&quot;); // Finds all</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Css3学习</title>
    <link href="/study.github.io/2018/06/26/Css3%E5%AD%A6%E4%B9%A0/"/>
    <url>/study.github.io/2018/06/26/Css3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h2><pre><code>width: 200px;height: 200px;border: 30px solid pink;box-sizing: border-box;border-image: url(./img/border1.png);/* 切割 */border-image-slice: 30 fill;/* 背景图会被拉升 */border-image-repeat: stretch;/* 将内容缩放进行完整的重复平铺 使得能够正好放下若干元素 */border-image-repeat: round;/* 背景会被直接平铺 */border-image-repeat: repeat;/* 设置边框图片的宽度 */border-image-width: 30px;/* 将背景图延伸到盒子外 不会放大 只会延伸 *//*放大中间部分*/border-image-outset: 100px;</code></pre><h2 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h2><h3 id="简单渐变"><a href="#简单渐变" class="headerlink" title="简单渐变"></a>简单渐变</h3><h4 id="简单线性渐变-linear-gradient"><a href="#简单线性渐变-linear-gradient" class="headerlink" title="简单线性渐变 linear-gradient"></a>简单线性渐变 linear-gradient</h4><pre><code>.box1{    width: 400px;    height: 800px;    margin: 10px auto;    /*linear-gradient(方向，开始颜色位置，颜色2位置，颜色3位置...)    1. to left：设置渐变为从右到左。相当于: 270deg;    2. to right：设置渐变从左到右。相当于: 90deg;       3. to top：设置渐变从下到上。相当于: 0deg;    4. to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。也可以直接指定度数，如45deg    */    background: linear-gradient(to right,pink,skyblue,yellowgreen,orange);    background: linear-gradient(20deg,pink,skyblue,yellowgreen,orange);    background: linear-gradient(-20deg,pink,skyblue,yellowgreen,orange);}</code></pre><h4 id="简单径向渐变radial-gradient"><a href="#简单径向渐变radial-gradient" class="headerlink" title="简单径向渐变radial-gradient"></a>简单径向渐变radial-gradient</h4><pre><code>.box2{    width: 400px;    height: 800px;    margin: 10px auto;    /* radial-gradient(·形状 大小 坐标·,颜色1，颜色2...) */    /* 圆形 */    background: radial-gradient(circle at center,pink,skyblue,yellowgreen,orange);    /* background: radial-gradient(circle at 200px 100px,pink,skyblue,yellowgreen,orange); */    /* 0%至10%是red渐变至green  10%至100%是green渐变至yellow */    background: radial-gradient(circle at 100px 100px,red 0%,green 10%,yellow 100%);    /* 椭圆 */    background: radial-gradient(ellipse at center,pink,skyblue,yellowgreen,orange);    /* 0%至20%是pink渐变至skyblue  20%至40%是skyblue渐变至yellowgreen  40%之后是纯yellowgreen */    background: radial-gradient(ellipse at 10px 100px,pink 0%,skyblue 20%,yellowgreen 40%);    /* 参数加入大小 */    /*    closest-side：最近边；      farthest-side：最远边；     closest-corner：最近角；      farthest-corner：最远角。默认是最远的角farthest-corner      */    /* 渐变的范围边缘触及最近的border结束 */    background: radial-gradient(circle closest-side at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最远的border结束 */    background: radial-gradient(circle farthest-side at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最近的角结束 */    background: radial-gradient(circle closest-corner at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最圆的角结束 */    background: radial-gradient(circle farthest-corner at 10px 500px,pink,skyblue,yellowgreen,orange);}</code></pre><h3 id="重复渐变"><a href="#重复渐变" class="headerlink" title="重复渐变"></a>重复渐变</h3><h4 id="重复线性渐变repeating-linear-gradient"><a href="#重复线性渐变repeating-linear-gradient" class="headerlink" title="重复线性渐变repeating-linear-gradient"></a>重复线性渐变repeating-linear-gradient</h4><pre><code>/* 重复渐变 */.box3 {    width: 400px;    height: 800px;    margin: 10px auto;    /*线性重复性渐变    repeating-linear-gradient(角度,颜色1 %0,颜色2 %10)    */    background: repeating-linear-gradient(45deg,red 0%,red 3%,orange 3%,orange 6%,yellow 6%,yellow 9%,green 9%,green 12%,blue 12%,blue 15%,indigo 15%,indigo 18%,purple 18%,purple 21%); */    /* background: repeating-linear-gradient(45deg,#fff 0px,#fff 2px,#000 2px,#000 4px); */}</code></pre><h4 id="重复径向渐变repeating-radial-gradient"><a href="#重复径向渐变repeating-radial-gradient" class="headerlink" title="重复径向渐变repeating-radial-gradient"></a>重复径向渐变repeating-radial-gradient</h4><pre><code>.box4{    width: 400px;    height: 800px;    margin: 10px auto;    /*径向的重复性渐变    repeating-radial-gradient(形状 终点位置 at 起点位置,颜色1 0%,颜色2 5%,颜色3 10%)    */    background: repeating-radial-gradient(circle farthest-corner at 10px 20px,red 0%,red 3%,orange 3%,orange 6%,yellow 6%,yellow 9%,green 9%,green 12%,blue 12%,blue 15%,indigo 15%,indigo 18%,purple 18%,purple 21%);</code></pre><h3 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h3><p>多次使用渐变，利用透明度，达到交叉效果</p><pre><code>background: repeating-linear-gradient(45deg,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%),repeating-linear-gradient(-45deg,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%);    background: repeating-radial-gradient(circle farthest-corner at left top,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%),repeating-radial-gradient(circle farthest-corner at right top,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%);}</code></pre><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E6%B8%90%E5%8F%98%E8%89%B2.png" srcset="/study.github.io/img/loading.gif" alt="渐变色"></p><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><pre><code>transition: 要过渡的属性  花费时间  运动曲线  何时开始;/*可以一次性设置，也可以分开设置*/    transition-property : 设置哪个属性要进行动画    transition-duration: 设置动画的时间    transition-timing-function : 设置动画运动的曲线(linear  ease  ease-in  ease-out  ease-in-out)    transition-delay : 设置动画延迟的时间</code></pre><h2 id="CSS-2D变形"><a href="#CSS-2D变形" class="headerlink" title="CSS 2D变形"></a>CSS 2D变形</h2><h3 id="translate-x-y"><a href="#translate-x-y" class="headerlink" title="translate(x, y)"></a>translate(x, y)</h3><pre><code>transform: translate(100px,100px);transform: translateX(100px);</code></pre><h3 id="缩放-scale-x-y"><a href="#缩放-scale-x-y" class="headerlink" title="缩放 scale(x, y)"></a>缩放 scale(x, y)</h3><pre><code>transform:scale(0.8,2.0);  //宽  高</code></pre><h3 id="旋转-rotate-deg"><a href="#旋转-rotate-deg" class="headerlink" title="旋转 rotate(deg)"></a>旋转 rotate(deg)</h3><p> 注意设置旋转中心点的时候不要设置在hover上</p><pre><code>transform:rotate(45deg);   //如果是正数，则顺时针，否则为逆时针transform-origin: left top; //默认为centertransform-origin: 10px 100px;</code></pre><h3 id="倾斜-skew-deg-deg"><a href="#倾斜-skew-deg-deg" class="headerlink" title="倾斜 skew(deg, deg)"></a>倾斜 skew(deg, deg)</h3><pre><code>transform:skew(45deg);</code></pre><p> 注意点角度不要是90的奇数整倍数，因为skew时，元素的高度是不发生变化的，当倾斜90度时元素的斜边要水平（上下边要与左右边重合）与高度不为零冲突，元素动画会 <strong>鬼畜</strong></p><p><strong>添加多个变形动画时用空格隔开，如</strong></p><pre><code>transform: rotate(45deg) translateX(100px);</code></pre><h3 id="坐标系问题"><a href="#坐标系问题" class="headerlink" title="坐标系问题"></a>坐标系问题</h3><p>下面两种的效果是不同的</p><pre><code>（1）transform: rotate(45deg) translateX(100px); （2）transform: translateX(100px) rotate(45deg);</code></pre><p>这是因为元素在进行2D变化时是根据坐标轴的，而旋转和缩放会改变坐标轴，发生意想不到的结果。但好好利用可以做出好的动画效果。</p><pre><code>transform: rotate(700deg) translateX(100px); /*达到蜗牛旋转效果*/</code></pre><h2 id="盒子居中的方法"><a href="#盒子居中的方法" class="headerlink" title="盒子居中的方法"></a>盒子居中的方法</h2><h3 id="盒子水平居中的办法"><a href="#盒子水平居中的办法" class="headerlink" title="盒子水平居中的办法"></a>盒子水平居中的办法</h3><p> 1、text-align: center</p><p> 2、margin: auto; 元素需要时block</p><h3 id="盒子垂直居中的办法"><a href="#盒子垂直居中的办法" class="headerlink" title="盒子垂直居中的办法"></a>盒子垂直居中的办法</h3><p> 1、line-height</p><p> 2、padding</p><h3 id="盒子垂直水平居中的方法"><a href="#盒子垂直水平居中的方法" class="headerlink" title="盒子垂直水平居中的方法"></a>盒子垂直水平居中的方法</h3><h4 id="利用transform让盒子垂直水平居中"><a href="#利用transform让盒子垂直水平居中" class="headerlink" title="利用transform让盒子垂直水平居中"></a>利用transform让盒子垂直水平居中</h4><pre><code>width: 200px;height: 200px;background-color: red;position: absolute;/*transform 百分比参照的是元素本身的宽高*/transform: translate(-50%,-50%); /*left和top参照的是父容器宽高的50%*/left: 50%;top:50%;</code></pre><h4 id="利用margin"><a href="#利用margin" class="headerlink" title="利用margin"></a>利用margin</h4><pre><code>position:fixed;width:200px;height:200px;left:50%;top:50%;margin-left:-100px;margin-top:-100px;</code></pre><h4 id="calc和定位的组合使用"><a href="#calc和定位的组合使用" class="headerlink" title="calc和定位的组合使用"></a>calc和定位的组合使用</h4><pre><code>top: calc(50% - 元素高度/2);left: calc(50% - 元素宽度/2);</code></pre><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><pre><code>/*    有：    background-color        背景颜色        background-image        背景图片地址        background-repeat        是否平铺  查手册了解其取值        background-position        背景位置       查手册了解其取值 left right center top bottom  两两搭配                                            使用方位名词时，前后无顺序要求；但是使用数字10px 10px时注意前后顺序        background-attachment    背景固定还是滚动*/div{    width: 400px;    height: 400px;    background-color: skyblue;    background-repeat: no-repeat;/*大小自适应充满*/    background-image: url(../img/girl.jpg);    background-size: 200px;    background-position: center;    /*background-position: 30px 10px;第一个值为X轴 第二个值为Y轴    其中网页顶端为X轴  右为正方向   左边为Y轴  下为正方向*/    /*background-position: 10px center;*/}</code></pre><h2 id="背景缩放"><a href="#背景缩放" class="headerlink" title="背景缩放"></a>背景缩放</h2><pre><code>div{    width: 800px;    height: 500px;    background: #000 url(../img/王者荣耀背景图.jpg) no-repeat top center;    /*background-size: 100px 100px;     设置两个属性值可能导致图片失真扭曲    background-size: 100px;   尽量使用一个属性值 另一个属性值会等比例缩放*/    /*background-size: 50%;     使用一个值 另一个值等比例缩放*/    background-size:cover;     /*会自动  |等比例缩放|  保证图片充满容器 但有可能图片溢出导致部分图片无法显示  【最常用】*/    /*background-size:contain;    等比例缩放，过程中图片的高度或者宽度任意一个属性值满足容器高宽时就停止缩放，保证图片完整性，但可能无法充满容器*/}</code></pre><h2 id="多背景"><a href="#多背景" class="headerlink" title="多背景"></a>多背景</h2><pre><code>/*一个元素可以设置多重背景图像；    每组属性之间使用逗号分隔    如果设置的多重背景图之间存在交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上    为了避免背景色将图像盖住，背景色通常都定义在最后一组上。*/div{    width: 500px;    height: 500px;    /*background: pink url(../img/水浒传.jpg) no-repeat fixed center center;  此处添加fixed后 该图片便以body为容器*/    background: url(../第1阶段HTML/img/水浒传.jpg) no-repeat left top,        url(../第1阶段HTML/img/三国演义.jpg) no-repeat right bottom pink;/*当一个div中需要出现多个背景图片时 中间用逗号隔开。值得注意的是：背景色的设置要放在最后一个设置中，不然会覆盖之前的图片效果*/}</code></pre><h2 id="凹凸文字"><a href="#凹凸文字" class="headerlink" title="凹凸文字"></a>凹凸文字</h2><pre><code>/*凸起*//*text-shadow:水平位置 垂直位置 模糊位置 阴影颜色  右和下为正方向*/text-shadow: 1px 1px 1px #000,-1px -1px 1px #fff;/*凹下*//*text-shadow:水平位置 垂直位置 模糊位置 阴影颜色  右和下为正方向*/text-shadow: 1px 1px 1px #fff,-1px -1px 1px #000;</code></pre><h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2><h3 id="观察距离"><a href="#观察距离" class="headerlink" title="观察距离"></a>观察距离</h3><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E6%99%AF%E6%B7%B1.png" srcset="/study.github.io/img/loading.gif" alt="景深"></p><pre><code>perspective:1000px; /*设置视角与投射面的距离*/</code></pre><p>注意的是：若要给某元素设置景深效果，那么perspective要设置在他的父元素上</p><p>分别设置 transform: translateZ()后的效果</p><pre><code>transform: translateZ(0px);transform: translateZ(500px);transform: translateZ(999px);transform: translateZ(1001px);</code></pre><h3 id="视角观察点"><a href="#视角观察点" class="headerlink" title="视角观察点"></a>视角观察点</h3><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E8%A7%82%E5%AF%9F%E7%82%B9.png" srcset="/study.github.io/img/loading.gif" alt="观察点"></p><p>默认为中心（center center）</p><pre><code>perspective-origin: left top;/*是body的左上角*/perspective-origin: 0px 0px; /*也可以精确化垂点*/</code></pre><h3 id="利用景深达到伪3d效果"><a href="#利用景深达到伪3d效果" class="headerlink" title="利用景深达到伪3d效果"></a>利用景深达到伪3d效果</h3><pre><code>body {    perspective: 1000px;    /*设置视角观察方向 且是相对于body的，且视角是一直垂直与body的*/    perspective-origin: left top;/*是body的左上角*/}.box {    width: 200px;    height: 200px;    border: 2px solid black;    /*transition 设置过渡动画*/    transition: all  1s;}.box1:hover {    transform: translateZ(500px);}&lt;div class=&quot;box box1&quot;&gt;&lt;/div&gt;</code></pre><p>当鼠标移动到box上时触发 transform: translateZ(500px); 致使box在他的Z轴上正方向移动500px;而他的父元素body设置了观察点为body的左上角，则box的移动轨迹是向右下角的。</p><h2 id="3d变形"><a href="#3d变形" class="headerlink" title="3d变形"></a>3d变形</h2><p>(注：3d变形结合景深后可以呈现空间立体效果。)</p><p>每个元素都有自己的坐标系</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/3d%E5%9D%90%E6%A0%87%E7%B3%BB.png" srcset="/study.github.io/img/loading.gif" alt="3d坐标系"></p><h3 id="translate3d-x-y-z"><a href="#translate3d-x-y-z" class="headerlink" title="translate3d(x,y,z)"></a>translate3d(x,y,z)</h3><p>例：</p><pre><code>.box1 {    transform: translate3d(100px,-50px,500px);}/*向x轴正方向移动100px 向y轴负方向移动50px  向z轴正方向移动500px*/</code></pre><h3 id="rotate3d-x-y-z-angle"><a href="#rotate3d-x-y-z-angle" class="headerlink" title="rotate3d(x,y,z,angle)"></a>rotate3d(x,y,z,angle)</h3><p>[x,y,z]向量，定义旋转轴；</p><p>angle定义旋转角度，正值为顺时针，负值为逆时针；</p><p> <strong>关于向量的运作原理</strong></p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F1.png" srcset="/study.github.io/img/loading.gif" alt="1560564644997"></p><p>[x,y,z]向量为[0,0,1]时代表z轴，旋转绕z轴旋转</p><p>[x,y,z]向量为[0,1,0]时代表y轴，旋转绕y轴旋转</p><p>[x,y,z]向量为[1,0,0]时代表x轴，旋转绕x轴旋转</p><p>[x,y,z]向量为[1,1,1]时，旋转轴如图绿色线所示</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F2.png" srcset="/study.github.io/img/loading.gif" alt="1560564933962"></p><p>再加上旋转角度后：</p><pre><code>.box2 {    transform: rotate3d(1,1,1,45deg);}</code></pre><p>效果</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F3.png" srcset="/study.github.io/img/loading.gif" alt="1560565807459"></p><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p> transform-origin: x-axis y-axis z-axis;</p><h3 id="scale3d-x-y-z"><a href="#scale3d-x-y-z" class="headerlink" title="scale3d(x,y,z)"></a>scale3d(x,y,z)</h3><pre><code>/* transform: scaleX(0.5); *//* transform: scaleY(0.5); *//*元素没有厚度 Z轴上的缩放暂时是没有意义的*/scale3d(2,2,0.5);</code></pre><h3 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h3><pre><code>/*当图片不是正面对象用户的时候就隐藏*/backface-visibility: hidden;</code></pre><h3 id="preserve-3d"><a href="#preserve-3d" class="headerlink" title="preserve-3d"></a>preserve-3d</h3><p> 让元素以3d效果去呈现 他是添加在父元素上的一个属性</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p> 关键帧动画(animation)：允许我们在多个状态之间进行动画</p><p> 过渡动画(transition )：允许我们在两个状态之间进行动画</p><p>1、先申明动画函数</p><pre><code>@keyframes Animate{    0%{        /* 可以同时对多个属性添加动画效果 */        transform: scale3d(1,1,1);    }    50%{        transform: scale3d(2,2,2);    }    100%{        transform: scale3d(1,1,1);    }}</code></pre><p>2、使用 并配置</p><pre><code>.box:hover{    /*动画的名字 调用动画函数*/    animation-name: Animate;    /*动画持续的时间*/    animation-duration: 2s;    /*动画延迟多长时间执行*/    animation-delay: 1s;    /*动画运动的曲线  linear匀速动画*/    animation-timing-function: linear;    /*指定动画执行的次数*/    animation-iteration-count: infinite;    /*让动画结束之后保留在动画结束的状态*/    animation-fill-mode: forwards;     /*让动画结束之后保留在动画初始的状态*/    /* animation-fill-mode: backwards;  */}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Photoshop的简单使用</title>
    <link href="/study.github.io/2018/06/24/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/06/24/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Photoshop图像处理专家"><a href="#Photoshop图像处理专家" class="headerlink" title="Photoshop图像处理专家"></a>Photoshop图像处理专家</h1><h2 id="1-学习Ps的目的"><a href="#1-学习Ps的目的" class="headerlink" title="1. 学习Ps的目的"></a>1. 学习Ps的目的</h2><p>虽然ps应该是UI的拿手好戏，但作为前端开发人员，在日常写程序的过程中不免会有用到Ps的时候，会使用Ps可以使得与前端的交接工作变得顺利。</p><p>前端人员的Ps学习目的：</p><p><strong>1) 会简单的抠图</strong></p><p><strong>2) 会简单的修改PSD效果图</strong></p><p><strong>3) 熟练的切图</strong></p><h2 id="2-Photoshop的安装"><a href="#2-Photoshop的安装" class="headerlink" title="2.Photoshop的安装"></a>2.Photoshop的安装</h2><p>现阶段我门使用的是Photoshop-CC（阉割版）</p><p>(64bit) <a href="https://pan.baidu.com/s/1W9b0F-CdHrzIirJpd50Ang" target="_blank" rel="noopener">百度云下载地址</a> 提取码：2rhu</p><p>(32bit) <a href="https://pan.baidu.com/s/1MU-KOriQ8fenWZgxJAX-Vw" target="_blank" rel="noopener">百度云下载地址</a> 提取码： vjmr</p><h2 id="3-Photoshop的界面认识"><a href="#3-Photoshop的界面认识" class="headerlink" title="3.Photoshop的界面认识"></a>3.Photoshop的界面认识</h2><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img1.png" srcset="/study.github.io/img/loading.gif" alt="img1"></p><h2 id="4-Photoshop的基本操作"><a href="#4-Photoshop的基本操作" class="headerlink" title="4.Photoshop的基本操作"></a>4.Photoshop的基本操作</h2><p>基本设置</p><p><strong>视图 –&gt; 标尺</strong></p><p><strong>窗口 –&gt; 信息</strong></p><p><strong>右击标尺可选择标尺单位</strong></p><h3 id="1-新建文件"><a href="#1-新建文件" class="headerlink" title="1) 新建文件"></a>1) 新建文件</h3><pre><code>文件 --&gt; 新建         //Ctrl+n</code></pre><ol><li>在新建对话框中如果宽度和高度的单位不是像素，要改成以像素为单位。平日的开发都是以像素为单位的。</li><li>分辨率固定72，为了避免出现预期之外错误，此值固定不变。</li></ol><h3 id="2-关闭文件"><a href="#2-关闭文件" class="headerlink" title="2) 关闭文件"></a>2) 关闭文件</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img2.png" srcset="/study.github.io/img/loading.gif" alt="img2"></p><p>或者</p><pre><code>Ctrl+W</code></pre><h3 id="3-保存文件"><a href="#3-保存文件" class="headerlink" title="3) 保存文件"></a>3) 保存文件</h3><pre><code>文件 --&gt; 保存        //Ctrl+s</code></pre><h3 id="4-移动工具与缩放变形"><a href="#4-移动工具与缩放变形" class="headerlink" title="4) 移动工具与缩放变形"></a>4) 移动工具与缩放变形</h3><h4 id="移动工具"><a href="#移动工具" class="headerlink" title="移动工具"></a>移动工具</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img3.png" srcset="/study.github.io/img/loading.gif" alt="img3"></p><p>使用案例：将一张图添加到另一张图中。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img4.png" srcset="/study.github.io/img/loading.gif" alt="img4"></p><p>打开一文件后，鼠标左击图片标题不动，向下拖拽成</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img5.png" srcset="/study.github.io/img/loading.gif" alt="img5"></p><p>这时再利用移动工具，将图片移动到目标图片上</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img6.png" srcset="/study.github.io/img/loading.gif" alt="img6"></p><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><pre><code>按住ctrl，鼠标即可对当前图层拖拽，要移动哪个图形，就在在图层面板中选中该图形所在的图层。按方向键可以微调。</code></pre><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><pre><code>Ctrl+t   //当前图层显示变换控件，也可以直接点击工具属性栏中的按钮按住shift可以等比例缩放</code></pre><p>操作完成后，ENTER回车，确认操作。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img7.png" srcset="/study.github.io/img/loading.gif" alt="img7"></p><h3 id="5-图层操作"><a href="#5-图层操作" class="headerlink" title="5) 图层操作"></a>5) 图层操作</h3><pre><code>F7   //图层面板显示/消失按钮</code></pre><h4 id="新建图层与删除"><a href="#新建图层与删除" class="headerlink" title="新建图层与删除"></a>新建图层与删除</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img8.png" srcset="/study.github.io/img/loading.gif" alt="img8"></p><h4 id="图层层叠"><a href="#图层层叠" class="headerlink" title="图层层叠"></a>图层层叠</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img9.png" srcset="/study.github.io/img/loading.gif" alt="img9"></p><p>此时鸣人是压着佐助的，这时因为佐助所在的图层在鸣人所在图层的下面。</p><p>我们将图层2 拖住至图层1上方，此时佐助就跑到鸣人上面了。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img10.png" srcset="/study.github.io/img/loading.gif" alt="img10"></p><h4 id="图层复制"><a href="#图层复制" class="headerlink" title="图层复制"></a>图层复制</h4><p>选择移动工具后</p><pre><code>1.按住Alt 拖拽图像2.Ctrl+j (重合复制)</code></pre><h4 id="图层编组"><a href="#图层编组" class="headerlink" title="图层编组"></a>图层编组</h4><p>选定所有待分组图层后</p><pre><code>ctrl+g  //创建分组ctrl+shift+g //取消分组</code></pre><p>图层或编组重命名</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img11.png" srcset="/study.github.io/img/loading.gif" alt="img11"></p><p>组操作或图层操作切换</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img12.png" srcset="/study.github.io/img/loading.gif" alt="img12"></p><h4 id="图层合并"><a href="#图层合并" class="headerlink" title="图层合并"></a>图层合并</h4><p>选中待合并图层后</p><pre><code>ctrl+e</code></pre><h4 id="图层的不透明度"><a href="#图层的不透明度" class="headerlink" title="图层的不透明度"></a>图层的不透明度</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img13.png" srcset="/study.github.io/img/loading.gif" alt="img13"></p><h3 id="6-选区工具"><a href="#6-选区工具" class="headerlink" title="6) 选区工具"></a>6) 选区工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img14.png" srcset="/study.github.io/img/loading.gif" alt="img14"></p><pre><code>Ctrl+D  //取消分区</code></pre><h3 id="7-磁性套索工具"><a href="#7-磁性套索工具" class="headerlink" title="7) 磁性套索工具"></a>7) 磁性套索工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img15.png" srcset="/study.github.io/img/loading.gif" alt="磁性套索工具"></p><h3 id="8-魔棒工具"><a href="#8-魔棒工具" class="headerlink" title="8) 魔棒工具"></a>8) 魔棒工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img16.png" srcset="/study.github.io/img/loading.gif" alt="魔棒工具"></p><p><strong>容差的概念：简单来说，容差越大选区范围越广，容差越小选区范围越宅</strong></p><h3 id="9-选区的布尔运算"><a href="#9-选区的布尔运算" class="headerlink" title="9) 选区的布尔运算"></a>9) 选区的布尔运算</h3><p>就是在原有选区的基础上，加上新的选区或减去分区。</p><pre><code>按住shift 再继续选区   //加选区按住Alt  再选区    //减选区Ctrl+shift+i   //反选</code></pre><h3 id="10-钢笔工具"><a href="#10-钢笔工具" class="headerlink" title="10) 钢笔工具"></a>10) 钢笔工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img17.png" srcset="/study.github.io/img/loading.gif" alt="钢笔工具"></p><ol><li>点击第一个点</li><li>再点击第二点时按住鼠标不动进行拖拽，会形成一个可控的弧线</li><li>上一条线为弧线后，与下一个点之间会默认为弧（取消办法：按住Alt，点击上一个点，即可取消）</li><li>完成一个闭合曲线</li><li>Ctrl+ENTER 形成选区</li></ol><h3 id="11-文字工具"><a href="#11-文字工具" class="headerlink" title="11) 文字工具"></a>11) 文字工具</h3><p>略</p><h3 id="12-吸管工具"><a href="#12-吸管工具" class="headerlink" title="12) 吸管工具"></a>12) 吸管工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img18.png" srcset="/study.github.io/img/loading.gif" alt="吸管工具1"></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img19.png" srcset="/study.github.io/img/loading.gif" alt="吸管工具2"></p><h3 id="13）切片工具"><a href="#13）切片工具" class="headerlink" title="13）切片工具"></a>13）切片工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img20.png" srcset="/study.github.io/img/loading.gif" alt="切片工具"></p><h4 id="手动切片"><a href="#手动切片" class="headerlink" title="手动切片"></a>手动切片</h4><p>1.用切片工具选取目标区域</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img21.png" srcset="/study.github.io/img/loading.gif" alt="切片选区"></p><p>2.<strong>文件 –&gt;储存为web所用格式</strong></p><pre><code>Alt+Ctrl+shift+S  //存储为web所用格式快捷键</code></pre><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img22.png" srcset="/study.github.io/img/loading.gif" alt="选定格式"></p><p><strong>存储时，要记得选中“选中的切片”</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img23.png" srcset="/study.github.io/img/loading.gif" alt="储存"></p><h4 id="图层切片"><a href="#图层切片" class="headerlink" title="图层切片"></a>图层切片</h4><p>1.选中目标图层</p><p>2.<strong>图层 –&gt; 新建基于图层的切片</strong></p><p>3.存储</p><h3 id="辅助线切图"><a href="#辅助线切图" class="headerlink" title="辅助线切图"></a>辅助线切图</h3><p>1.标尺部分拖拽出辅助线，将图片进行分割。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img25.png" srcset="/study.github.io/img/loading.gif" alt="辅助线切图"></p><p>2.点击属性栏中的基于参考线的切片</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img26.png" srcset="/study.github.io/img/loading.gif" alt="基于参考线的切片"></p><p>3.存储</p><h3 id="等份数切片"><a href="#等份数切片" class="headerlink" title="等份数切片"></a>等份数切片</h3><p>1.<strong>切片选择工具 –&gt;划分</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img27.png" srcset="/study.github.io/img/loading.gif" alt="等分数切片"></p><p>2.选择等份切片方式</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img28.png" srcset="/study.github.io/img/loading.gif" alt="划分"></p><p>3.存储</p><h4 id="清除全部切片和辅助线"><a href="#清除全部切片和辅助线" class="headerlink" title="清除全部切片和辅助线"></a>清除全部切片和辅助线</h4><p>1.视图 –&gt; 清除切片</p><p>2.视图 –&gt; 清除参考线</p><h4 id="切片注意"><a href="#切片注意" class="headerlink" title="切片注意"></a>切片注意</h4><p><strong>1.当切片时发现有其他图层盖住了目标图层，用利用“小眼睛”将其他图层隐藏</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img24.png" srcset="/study.github.io/img/loading.gif" alt="切片注意"></p><p><strong>2.切片存储时，若要一次存储多个切片，可按住shift再点击目标切片</strong></p><h2 id="5-Photoshop的快捷键"><a href="#5-Photoshop的快捷键" class="headerlink" title="5.Photoshop的快捷键"></a>5.Photoshop的快捷键</h2><ol><li>Ctrl+Z //撤销上一步</li><li>Alt+Ctrl+Z //撤销多步</li><li>Alt+滚轮 //放大、缩小</li><li>Ctrl+滚轮 //左右移动</li><li>Ctrl+D //取消选择</li><li>Ctrl+shift+D //重新选择</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Npm与Yarn的使用</title>
    <link href="/study.github.io/2018/06/21/Npm%E4%B8%8EYarn%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/06/21/Npm%E4%B8%8EYarn%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-amp-YARN"><a href="#NPM-amp-YARN" class="headerlink" title="NPM&amp;YARN"></a>NPM&amp;YARN</h1><h2 id="npm常用的命令"><a href="#npm常用的命令" class="headerlink" title="npm常用的命令"></a>npm常用的命令</h2><p>全局安装：默认安装在Node.js环境的node_modules目录下，全局安装的包一般用于命令行工具</p><p>本地安装：一般用于开发某种具体的功能</p><p> 1、安装包（若不指定版本号 默认安装最新版本）</p><pre><code>npm install -g 安装包名称     （全局安装）npm install 安装包名称      （本地安装）</code></pre><pre><code>例： npm install es-checker     //安装es6例： npm install</code></pre><p>2、卸载包</p><pre><code>npm uninstall -g 安装包名称     （全局卸载）npm uninstall 安装包名称      （本地卸载）例： npm uninstall es-checker     //卸载es6</code></pre><p>3、更新包 （更新到最新版本号）</p><pre><code>npm updata -g 安装包名称</code></pre><p>4、添加依赖</p><pre><code>--save   （向生产环境添加依赖） 生产环境是项目部署上线之后的服务器环境--save-dev   （向开发环境添加依赖） 开发环境是平时开发使用的环境//例子：npm install es-checker --save//例子：npm install es-checker --save-dev</code></pre><p>安装服务器自动重启</p><pre><code>npm install -g nodemon</code></pre><h2 id="npm安装包的步骤"><a href="#npm安装包的步骤" class="headerlink" title="npm安装包的步骤"></a>npm安装包的步骤</h2><p>1、初始化</p><pre><code>npm init //初始化 生成package.json文件</code></pre><p>2、安装包</p><pre><code>npm install 安装包名称      （本地安装）</code></pre><p>3、若存在package.json文件 和 package-lock.json文件，恢复安装</p><pre><code>npm install</code></pre><h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p>安装yarn工具</p><pre><code>npm install -g yarn</code></pre><h2 id="yarn中的命令"><a href="#yarn中的命令" class="headerlink" title="yarn中的命令"></a>yarn中的命令</h2><p>1、初始化包</p><pre><code>npm init  //npm中的初始化方式yarn init  //yarn中初始化方式</code></pre><p>2、安装包</p><pre><code>npm install xxx --save //npm中的安装方式yarn add xxx  //yarn中的安装方式</code></pre><p>3、移除包</p><pre><code>npm uninstall xxx  //npm中的移除方式yarn remove xxx  //yarn中的移除方式</code></pre><p>4、更新包</p><pre><code>npm update xxxyarn upgrade xxx</code></pre><p>5、安装开发依赖的包</p><pre><code>npm install xxx --save-devyarn  add xxx --dev</code></pre><p>6、全局安装</p><pre><code>npm install -g xxxyarn globar add xxx</code></pre><p>7、设置下载镜像的地址</p><pre><code>npm config set registry urlyarn config set registry url</code></pre><p>8、安装所有依赖</p><pre><code>npm installyarn install</code></pre><p>9、执行包</p><pre><code>npm runyarn run</code></pre><h1 id="切换源"><a href="#切换源" class="headerlink" title="切换源"></a>切换源</h1><p>安装nrm</p><pre><code>npm install nrm</code></pre><p>查看源</p><pre><code>nrm ls</code></pre><p>切换</p><pre><code>nrm xxx</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于浮动的若干问题</title>
    <link href="/study.github.io/2018/06/20/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2018/06/20/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标准文档流"><a href="#1-标准文档流" class="headerlink" title="1.标准文档流"></a>1.标准文档流</h1><p>标准流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做标准流布局。</p><h1 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2.浮动"></a>2.浮动</h1><h2 id="2-1-浮动的机制"><a href="#2-1-浮动的机制" class="headerlink" title="2.1 浮动的机制"></a>2.1 浮动的机制</h2><p>当有两个div同时在标准刘文档中的时候，两个div会隔行显示：</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img1.png" srcset="/study.github.io/img/loading.gif" alt="img1"></p><pre><code>(2D图)</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img4.png" srcset="/study.github.io/img/loading.gif" alt="img4"></p><pre><code>**（3D图）**</code></pre><p>当将蓝色div对应的CSS添加浮动属性后，蓝色div会脱离标准流，而浮在标准流之上</p><pre><code>float: left;</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img2.png" srcset="/study.github.io/img/loading.gif" alt="img2"></p><pre><code>**（2D图）**</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img5.png" srcset="/study.github.io/img/loading.gif" alt="img5"></p><pre><code>**（3D图）**</code></pre><p>将蓝色div和红色div同时设置浮动属性后，两者都处于浮动的层次，显示方式默认为贴边水平并排显示</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img3.png" srcset="/study.github.io/img/loading.gif" alt="img3"></p><pre><code>**（2D图）**</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img6.png" srcset="/study.github.io/img/loading.gif" alt="img6"></p><pre><code>**（3D图）**</code></pre><h2 id="2-2-浮动的使用"><a href="#2-2-浮动的使用" class="headerlink" title="2.2 浮动的使用"></a>2.2 浮动的使用</h2><pre><code>选择器{float:属性值;}</code></pre><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">元素向左浮动</td></tr><tr><td align="center">right</td><td align="center">元素向右浮动</td></tr><tr><td align="center">none</td><td align="center">元素不浮动（默认值）</td></tr></tbody></table><h2 id="2-3-清除浮动"><a href="#2-3-清除浮动" class="headerlink" title="2.3 清除浮动"></a>2.3 清除浮动</h2><h3 id="2-3-1-为什么要清除浮动"><a href="#2-3-1-为什么要清除浮动" class="headerlink" title="2.3.1 为什么要清除浮动"></a>2.3.1 为什么要清除浮动</h3><p>浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。</p><p>由于<strong>浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</strong>，为了解决这些问题，此时就需要在该元素中清除浮动。</p><p>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p><h3 id="2-3-2-清除浮动的本质"><a href="#2-3-2-清除浮动的本质" class="headerlink" title="2.3.2 清除浮动的本质"></a>2.3.2 清除浮动的本质</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img7.jpg" srcset="/study.github.io/img/loading.gif" alt="img7"></p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img8.jpg" srcset="/study.github.io/img/loading.gif" alt="img8"></p><h3 id="2-3-3-清除浮动的方法"><a href="#2-3-3-清除浮动的方法" class="headerlink" title="2.3.3 清除浮动的方法"></a>2.3.3 清除浮动的方法</h3><h4 id="1-用clear属性清除浮动"><a href="#1-用clear属性清除浮动" class="headerlink" title="1)用clear属性清除浮动"></a>1)用clear属性清除浮动</h4><pre><code>选择器{clear:属性值;}</code></pre><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td align="center">right</td><td align="center">不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td align="center">both</td><td align="center">同时清除左右两侧浮动的影响</td></tr></tbody></table><h4 id="2-额外标签法"><a href="#2-额外标签法" class="headerlink" title="2)额外标签法"></a>2)额外标签法</h4><p>在浮动元素末尾添加一个大小为0，内容为空的标签，如：</p><pre><code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></pre><p><strong>（不推荐）</strong></p><h4 id="3-父级添加overflow属性方法"><a href="#3-父级添加overflow属性方法" class="headerlink" title="3)父级添加overflow属性方法"></a>3)父级添加overflow属性方法</h4><p>给父级元素添加</p><pre><code>overflow： hidden；  /*auto、scroll都可以*/</code></pre><h4 id="4-使用after伪元素清除浮动"><a href="#4-使用after伪元素清除浮动" class="headerlink" title="4) 使用after伪元素清除浮动"></a>4) 使用after伪元素清除浮动</h4><p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong> 。</p><pre><code>.clearfix::after {  content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden;  }   .clearfix {*zoom: 1;}   /*IE6、7 专有 ，星号表示IE7之下浏览器识别，其他浏览器不识别*/                                    /*然后给父元素加上clearfix类就可以了*/</code></pre><h4 id="5-使用before和after双伪元素清除浮动"><a href="#5-使用before和after双伪元素清除浮动" class="headerlink" title="5)使用before和after双伪元素清除浮动"></a>5)使用before和after双伪元素清除浮动</h4><pre><code>.clearfix::before,.clearfix::after {   content:&quot;&quot;;  display:table;  }.clearfix:after {  clear:both;}.clearfix {  *zoom:1;} /*然后给父元素加上clearfix类就可以了*/</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/study.github.io/2018/06/19/Ajax/"/>
    <url>/study.github.io/2018/06/19/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="什么是AJAX？"><a href="#什么是AJAX？" class="headerlink" title="什么是AJAX？"></a>什么是AJAX？</h2><p> Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p><p><strong>AJAX的好处</strong>：可以通过<code>js</code>代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能</p><h2 id="创建AJAX对象"><a href="#创建AJAX对象" class="headerlink" title="创建AJAX对象"></a>创建AJAX对象</h2><pre><code>//兼容性写法  ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);是为了兼容IE5 IE6var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);</code></pre><h2 id="AJAX的方法"><a href="#AJAX的方法" class="headerlink" title="AJAX的方法"></a>AJAX的方法</h2><pre><code>//设置请求方式ajax.open(&quot;post&quot;,&quot;url&quot;,true);  //第三个参数如果为true，则是异步，反之同步//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);//发送请求:get请求参数放在url后面，post请求参数send()方法里面ajax.send(&quot;数据&quot;); //监听ajax状态，当ajax的状态发生改变的时候执行ajax.onreadystatechange = function(){    //响应完成，浏览器已经可以获取到服务器响应结果了    if(this.readyState == 4){  //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性        //http响应的状态码        if(this.state == 200){  //还有302  301  404...            //获取响应内容            console.log(this.responseText); //用ajax.responseText获取服务器返回的数据                //responseText 获得字符串形式的响应数据。               //responseXML 获得XML 形式的响应数据        }    }}</code></pre><h2 id="数据渲染的两种方式"><a href="#数据渲染的两种方式" class="headerlink" title="数据渲染的两种方式"></a>数据渲染的两种方式</h2><h3 id="数据在服务器中渲染完毕，返回给客户端一个完整页面"><a href="#数据在服务器中渲染完毕，返回给客户端一个完整页面" class="headerlink" title="数据在服务器中渲染完毕，返回给客户端一个完整页面"></a>数据在服务器中渲染完毕，返回给客户端一个完整页面</h3><ol><li>浏览器发送请求至服务器</li><li>服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端</li><li>客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板）</li></ol><h3 id="服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"><a href="#服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示" class="headerlink" title="服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"></a>服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示</h3><ol><li>客户端发送数据请求给服务器</li><li>服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端</li><li>客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js）</li></ol><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML extensible Markup Language 扩展的标记语言，XML的标签可以自定义<br>HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个</p><p><strong>XML用途：</strong><br>1、 定义数据结构<br>2、 作为配置文件出现</p><p><strong>XML组成：</strong><br>1、 XML文档声明<br>2、 XML标签<br>3、 XML属性<br>4、 XML注释</p><p><strong>XML文档注意点：</strong><br>1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如<br>2）xml标签名称区分大小写。<br>3）xml标签一定要正确配对。<br>4）xml标签名中间不能使用空格<br>5）xml标签名不能以数字开头<br>6）注意： 在一个xml文档中，有且仅有一个根标签</p><pre><code>//使用xml设计一个通讯录&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;contact&gt;    &lt;person id=&quot;100&quot;&gt;         &lt;name&gt;张三&lt;/name&gt;         &lt;age&gt;18&lt;/age&gt;         &lt;phone&gt;12345678&lt;/phone&gt;         &lt;email&gt;12453@qq.com&lt;/email&gt;    &lt;/person&gt;    &lt;person id=&quot;101&quot;&gt;         &lt;name&gt;李四&lt;/name&gt;         &lt;age&gt;20&lt;/age&gt;         &lt;phone&gt;22345678&lt;/phone&gt;         &lt;email&gt;34453@qq.com&lt;/email&gt;    &lt;/person&gt;&lt;/contact&gt;</code></pre><p><strong>xml的使用</strong></p><pre><code>//服务器代码//返回XML格式的数据app.get(&quot;/getXML&quot;,(req,res)=&gt;{    //设置响应头，指定返回的数据是XML    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);    var xml =  &#39;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&#39;;//XML文档声明    xml += &#39;&lt;person&gt;&#39;;    xml += &#39;&lt;name&gt;羊杨&lt;/name&gt;&#39;;    xml += &#39;&lt;age&gt;16&lt;/age&gt;&#39;;    xml += &#39;&lt;gender&gt;男&lt;/gender&gt;&#39;;    xml += &#39;&lt;/person&gt;&#39;;    res.send(xml);})//客户端代码ajax.onreadystatechange = function(){    if(this.readyState == 4){        //获取响应的XML数据        var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据        var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据  但此时age是&lt;age&gt;16&lt;/age&gt;        console.log(age.innerHTML);//此处用innerText拿不到数据        console.log(xml.children);//xml的语法几乎与html语法类似    }}</code></pre><p>JSON</p><p>json数据的使用</p><pre><code>//服务器代码//返回JSON格式的数据app.get(&quot;/getJSON&quot;,(req,res)=&gt;{    //数组    let arr = [        {            name:&quot;zhangsan&quot;,            age:&quot;18&quot;,            gender:&quot;男&quot;,            id:001        },        {            name:&quot;lisi&quot;,            age:&quot;28&quot;,            gender:&quot;男&quot;,            id:002        }    ]    //将数组转换为JSON数据    res.status(200).send(JSON.stringify(arr));})//客户端代码ajax.onreadystatechange = function(){    if(this.readyState == 4){        console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象        var students = JSON.parse(this.responseText);        var html = template(&quot;generatorTable&quot;,{students:students});        container.innerHTML = html;    }}</code></pre><h2 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h2><p>推荐使用 方便的一批</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>客户端代码</p><pre><code>$.ajax({    //请求方式    type:&quot;get&quot;, //post    //请求路径    url:&quot;&quot;, //如http://localhost:3000/index    //请求参数，无论是get还是post请求，请求参数都可以写在这里    //注意：请求为get时  在服务器得到请求参数时 仍然使用res.query    //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify({[{},{}]})    data:{name:&quot;zhangsan&quot;},    //规定所要请求的数据的类型    dataType: &#39;&#39;,    //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写    //contentType: &quot;application/x-www-form-urlencoded&quot;,    //请求成功的回调    success:function(res){        console.log(res);//res是请求的到的数据    }    //请求出错的回调 推荐写    error:function(err){        console.log(err);    }    //无论请求的成功与否，只要请求结束都会执行此函数    complete:function(xhr){    }})</code></pre><p>服务器代码</p><pre><code>let express = require(&quot;express&quot;);let app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));//注意 当客户端中的data:JSON.stringify([{name:&#39;zhangsan&#39;},{name:&#39;lisi&#39;}])时，服务器需要此配置//以解析body中的json数据app.use(bodyParser.json({extended:false}));app.use(express.static(&quot;./views&quot;));//当ajax的url为&#39;/getJSON&#39;时 此接口响应 返回JSON格式的数据//此时ajax的dataType要设置为&#39;json&#39;app.get(&quot;/getJSON&quot;,(req,res)=&gt;{    //数组    let arr = [        {            name:&quot;zhangsan&quot;,            age:&quot;18&quot;,            gender:&quot;男&quot;,            id:001        },        {            name:&quot;lisi&quot;,            age:&quot;28&quot;,            gender:&quot;男&quot;,            id:002        }    ]    arr.forEach((user,idx)={        if(user.name == req.body.name){            res.status(200).send(JSON.stringify(user));        }    })})//当ajax的url为&#39;/getXML&#39;时 此接口响应 返回XML格式的数据//此时ajax的dataType要设置为&#39;xml&#39;app.get(&quot;/getXML&quot;,(req,res)=&gt;{    //设置响应头，指定返回的数据是XML    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);    var xml =  &#39;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&#39;;    xml += &#39;&lt;person&gt;&#39;;    xml += &#39;&lt;name&gt;zhangsan&lt;/name&gt;&#39;;    xml += &#39;&lt;age&gt;16&lt;/age&gt;&#39;;    xml += &#39;&lt;gender&gt;男&lt;/gender&gt;&#39;;    xml += &#39;&lt;/person&gt;&#39;;    res.send(xml);})</code></pre><p>发送也接受html或script数据</p><p>服务器代码</p><pre><code>const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.use(express.static(&#39;views&#39;));app.get(&#39;/getScript&#39;,(req,res)=&gt;{    res.header(&#39;content-type&#39;,&#39;application/javascript;charset=utf-8&#39;);    res.send(&#39;alert(123);&#39;);});app.get(&#39;/getHtml&#39;,(req,res)=&gt;{    res.header(&#39;content-type&#39;,&#39;text/html;charset=utf-8&#39;)    res.send(&#39;&lt;h1&gt;HTML&lt;/h1&gt;&#39;);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><p>客户端代码</p><pre><code>$(&#39;#btn1&#39;).click(function(){    $.ajax({        type: &#39;get&#39;,        url: &#39;/getHtml&#39;,        data: &#39;&#39;,        dataType: &#39;html&#39;,        success:function(res){            //因为dataType为html  jQuery。AJAX会自动设置响应头为text/html  则 可以直接追加res到页面中            $(&#39;#info&#39;).append(res);        },        error:function(err){            console.log(err);        }    });});$(&#39;#btn2&#39;).click(function(){    $.ajax({        type: &#39;get&#39;,        url: &#39;/getScript&#39;,        data: &#39;&#39;,        dataType: &#39;script&#39;,        success:function(res){            //之所以alert()能执行  是因为将script代码打印到控制台  控制台会执行script代码            //也可以用script标签的对res进行封装 追加到页面中 也可以执行            console.log(res);        },        error:function(err){            console.log(err);        }    });});</code></pre><h3 id="dataType"><a href="#dataType" class="headerlink" title="dataType"></a>dataType</h3><p><strong>dataType取值有xml、html、json、jsonp、script或者text</strong></p><p>当dataType取值为<strong>json</strong>，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。<br>服务器应该设置这个响应头：<strong>res.header(“content-type”, “application/json;charset=utf-8”);</strong></p><p>当dataType为<strong>xml或者text</strong>的时候，返回的数据不会另做处理<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/xml”);</strong><br><strong>res.header(“content-type”,”text/plain;charset=utf-8”);</strong></p><p>当dataType为<strong>html</strong>的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”text/html;charset=utf-8”);</strong></p><p>当dataType为<strong>script</strong>的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><p>当dataType为<strong>jsonp</strong>的时候，会向服务器发送一个jsonp请求<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><h2 id="nprogress的使用（全局事件处理）"><a href="#nprogress的使用（全局事件处理）" class="headerlink" title="nprogress的使用（全局事件处理）"></a>nprogress的使用（全局事件处理）</h2><p>1、在html文件中引入nprogress.js 和 nprogress.css</p><p>2</p><pre><code>$(document).ajaxStart(function(){//请求数据开始    NProgress.start();//数据加载动画}).ajaxStop(function(){//请求数据结束    NProgress.done();//数据加载完毕动画});</code></pre><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p><strong>同源策略</strong>是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口完全相同</strong> ，只有同源的地址才可以相互通过AJAX的方式请求。</p><p>同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为<strong>跨域请求</strong></p><p>例如</p><pre><code>http://localhost:8000  是不可以通过ajax访问  http://locally.uieee.com/categories的因为两者不满足同源的条件</code></pre><h3 id="如何进行跨域请求"><a href="#如何进行跨域请求" class="headerlink" title="如何进行跨域请求"></a>如何进行跨域请求</h3><ol><li>CORS</li><li>JSONP</li><li>代理服务器</li><li>修改document.domain</li><li>Iframe</li><li>Location.hash</li><li>Window.postMessage()</li><li>Websocket</li></ol><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax()</p><p>Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。</p><pre><code>//直接在服务器配置如下,客户端代码和以前一样写app.all(&#39;*&#39;, function(req, res, next) {    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-type&#39;);    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;);    res.header(&#39;Access-Control-Max-Age&#39;,6000);//预请求缓存10分钟    next();  });</code></pre><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求</p><p>需要服务器和客户端配合</p><pre><code>//此时客户端的地址为http://localhost:3000实现要点//客户端代码var script = document.createElement(&#39;script&#39;);script.src = &#39;http://localhost:9999/testJSONP&#39;;//向http://localhost:9999发送跨域请求document.body.appendChild(script)//服务器代码app.get(&quot;/testJSONP&quot;,(req,res)=&gt;{    //设置响应头 服务器给客户端发送了一个js代码块    res.header(&quot;content-type&quot;,&quot;application/javascript&quot;);    let data = JSON.stringify({&quot;name&quot;:&quot;zhangsan&quot;}) ;    //服务器发送 `foo(&#39;{&quot;name&quot;:&quot;zhangsan&quot;}&#39;)` 这个字符串给客户端    res.send(`foo(${data})`);})//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数function foo(data){    console.log(data);}</code></pre><p><strong>jQuery代码</strong></p><pre><code>//客户端代码$.ajax({    type:&quot;get&quot;,    url:&quot;http://localhost:9999/testJSONP&quot;,    data:&#39;&#39;,    dataType: &#39;jsonp&#39;,    success:function(res){        $(&#39;body&#39;).append(res);    }    error:function(err){        console.log(err);    }    complete:function(xhr){    }});function foo(data){    console.log(data);}//服务器http://localhost:3000代码const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.use(express.static(&#39;views&#39;));app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});//服务器http://localhost:8888代码const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.get(&#39;/getJsonp&#39;,(req,res)=&gt;{    res.send(&#39;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&#39;);});app.listen(8888,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>AJAX是通过<code>XMLHttpRequest</code>或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
