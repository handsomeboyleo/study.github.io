<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack的基本使用心得</title>
    <link href="/study.github.io/2020/02/19/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/study.github.io/2020/02/19/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Express服务器的搭建</title>
    <link href="/study.github.io/2020/02/19/Express%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2020/02/19/Express%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>wamp环境的搭建</title>
    <link href="/study.github.io/2020/02/19/wamp%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2020/02/19/wamp%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Less的使用</title>
    <link href="/study.github.io/2020/02/19/Less%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2020/02/19/Less%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于JavaScript中作用域/作用域链和预解析</title>
    <link href="/study.github.io/2018/07/02/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/study.github.io/2018/07/02/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析Javascript中作用域、作用域链和预解析"><a href="#浅析Javascript中作用域、作用域链和预解析" class="headerlink" title="浅析Javascript中作用域、作用域链和预解析"></a>浅析Javascript中作用域、作用域链和预解析</h1><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><pre><code>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</code></pre><p>作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p><h3 id="1-全局作用域（全局变量）"><a href="#1-全局作用域（全局变量）" class="headerlink" title="1.全局作用域（全局变量）"></a>1.全局作用域（全局变量）</h3><p><strong>全局变量，原理就是将变量挂载到window对象中.</strong></p><p><strong>全局变量拥有全局的作用域，可在任意地方被调用</strong></p><p>全局变量有两种声明方式</p><h3 id="（1）函数外部"><a href="#（1）函数外部" class="headerlink" title="（1）函数外部"></a>（1）函数外部</h3><p>(写在函数外面的都是全局变量)</p><pre><code>&lt;script&gt;    var num = 15; //全局变量        function f() {        var num = 10; //不是全局变量            function f2(){               /*----*/             }            f2();        }    f();    console.log(num); //  15&lt;/script&gt;</code></pre><h3 id="（2）函数内部"><a href="#（2）函数内部" class="headerlink" title="（2）函数内部"></a>（2）函数内部</h3><p>(不加var的变量声明，隐式全局变量)</p><pre><code>&lt;script&gt;    function f() {        num = 10; //隐式全局变量    }    f();    console.log(num); // 10&lt;/script&gt;</code></pre><h4 id="全局变量与隐式全局变量的区别"><a href="#全局变量与隐式全局变量的区别" class="headerlink" title="全局变量与隐式全局变量的区别"></a>全局变量与隐式全局变量的区别</h4><pre><code>隐式全局变量可以通过delete关键字来删除，全局变量不可以//全局变量不可被delete&lt;script&gt;    var a = 2; //全局变量    function f(){        //****    }    console.log(a); //  2    delete a;    console.log(a); //  2&lt;/script&gt;//隐式全局变量被delete&lt;script&gt;    function f(){        a = 2; //隐式全局变量    }    console.log(a); //  2    delete a;    console.log(a); //  not defined (已被删除)&lt;/script&gt;</code></pre><h3 id="2-局部作用域-局部变量"><a href="#2-局部作用域-局部变量" class="headerlink" title="2.局部作用域(局部变量)"></a>2.局部作用域(局部变量)</h3><pre><code>局部变量：写在函数体里面的变量局部变量只可以在当前函数内部使用&lt;script&gt;    function f() {        var num = 10; //局部变量        function f2(){            console.log(num); // 10        }        f2();    }    f();    console.log(num); //  not defined&lt;/script&gt;</code></pre><h2 id="二、作用域链"><a href="#二、作用域链" class="headerlink" title="二、作用域链"></a>二、作用域链</h2><p>作用域链简而言之就是，调用变量时，若当前作用域内没有该变量时就向它的上一级作用域去寻找。</p><p>Javascript用的是词法作用域（静态作用域）</p><p>实例：</p><pre><code>&lt;script&gt;    /* 0级作用域 */var a = 1;function aa(){    /* 1级作用域 */    //var a = 2;    function bb(){  /* 2级作用域 */        //var a = 3;        console.log(a);  // 1    }    bb();}aa();&lt;/script&gt;</code></pre><p>作用过程：</p><ol><li>当运行到console.log(a)时，会在当前作用域（2级作用域）内寻找是否有a可用；</li><li>若有直接使用，否则向上一级作用域（1级作用域）去寻找；</li><li>此时来到1级作用域，若此时有a可用则用，否则继续向上一级寻找，直到到达0级作用域；</li><li>此时来到0级作用域，若此时有a可用则用，否则报错；</li></ol><p><img src="https://howlcn1997.github.io/2018/02/26/%E6%B5%85%E6%9E%90Javascript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg" srcset="/study.github.io/img/loading.gif" alt="作用域链"></p><p><strong>值得注意的是：作用域链的始发点与函数的调用位置无关，而与函数的声明位置有关</strong> 例子如下：</p><pre><code>&lt;script&gt;    var value = 1;    function foo() {        console.log(value);    }    function bar() {        var value = 2;        foo();    }    bar();&lt;/script&gt;</code></pre><p>此时的打印结果为1，而不是foo函数调用所在作用域的value = 2；</p><p>这里的1是foo函数声明所在的作用域中的value = 1；</p><p>## 三、预解析</p><p>当浏览器执行Javascript代码时，为了提高执行效率会在代码解释执行前进行预解析处理。</p><p>预解析处理规则：</p><p>\1. 变量提升 仅仅将变量声明提升到当前作用域的最上面，不包括变量的赋值<br>\2. 函数提升 将函数的声明提升到当前作用域的最上面，不包括函数的调用 <strong>函数的声明会提前到变量声明之前</strong></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>实例：</p><pre><code>&lt;script&gt;    console.log(a); //undefined    var a = 10;&lt;/script&gt;</code></pre><p>上述代码结果打印为undefined,而不是10，这是为什么呢？</p><p>我们来看看与解析之后的结果，</p><p>预解析为：</p><pre><code>&lt;script&gt;    var a    console.log(a);    a = 10;&lt;/script&gt;</code></pre><p>由于变量声明被提升到作用域最前端，而赋值没有被提升，导致执行console.log(a);时 a还未被赋值。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>实例：</p><pre><code>&lt;script&gt;    f1();    function f1() {        /*-----*/    }&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function f1() {        /*-----*/    }    f1();&lt;/script&gt;</code></pre><h3 id="函数的声明会提前到变量声明之前"><a href="#函数的声明会提前到变量声明之前" class="headerlink" title="函数的声明会提前到变量声明之前"></a>函数的声明会提前到变量声明之前</h3><pre><code>函数提升和变量提升同时发生时，函数的声明会提前到变量声明之前。&lt;script&gt;    var a = 3;    function a(){        console.log(10);    }       console.log(a);    a();&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function a(){        console.log(10);    }    var a;    a = 3    console.log(a);    a(); //not function  因为此时a为变量而不是函数&lt;/script&gt;</code></pre><p><strong>值得注意的是：</strong></p><p>1.函数是可以被打印的</p><pre><code>&lt;script&gt;    function a(){    /*----*/    }console.log(a); //打印函数a&lt;/script&gt;</code></pre><p>2.变量a的赋值可以被普通类型和函数互相取代</p><pre><code>&lt;script&gt;    var a；    a = function(){        /*----*/        }    console.log(a); //打印函数a    a = 1;    console.log(a); // 1；&lt;/script&gt;</code></pre><h3 id="匿名函数的申明不遵循预解析规则"><a href="#匿名函数的申明不遵循预解析规则" class="headerlink" title="匿名函数的申明不遵循预解析规则"></a>匿名函数的申明不遵循预解析规则</h3><pre><code>&lt;script&gt;    f();  //报错    var f = function(){        /*----*/    }&lt;/script&gt;</code></pre><p>因为解析前后代码相同 执行 <strong>f()</strong> 时，f未被声明为函数类型。</p><h3 id="隐式全局变量的注意点"><a href="#隐式全局变量的注意点" class="headerlink" title="隐式全局变量的注意点"></a>隐式全局变量的注意点</h3><pre><code>&lt;script&gt;    f();    console.log(a);  //undefined    console.log(b);  //9    function f() {      var a = b = c = 9;      console.log(a); //9      console.log(b); //9    }&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function f() {      var a;  //局部变量      a = 9;        b = 9;  //隐式全局变量      console.log(a);  //9      console.log(b);  //9    }    f();    console.log(b);  //9    console.log(a);  //undefined   因为a是局部变量&lt;/script&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于JS函数的重载问题</title>
    <link href="/study.github.io/2018/06/29/JS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2018/06/29/JS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="关于Javascript的函数重载问题"><a href="#关于Javascript的函数重载问题" class="headerlink" title="关于Javascript的函数重载问题"></a>关于Javascript的函数重载问题</h1><p><strong>在Javascript与Java等语言不同，它自身没有重载的具体方法，但我们可以利用Javascript的特性来完成重载的效果</strong></p><h2 id="1-什么是重载"><a href="#1-什么是重载" class="headerlink" title="1.什么是重载"></a>1.什么是重载</h2><pre><code>重载，简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</code></pre><h2 id="2-Javascript如何实现重载"><a href="#2-Javascript如何实现重载" class="headerlink" title="2.Javascript如何实现重载"></a>2.Javascript如何实现重载</h2><h3 id="方法一：利用函数的arguments来完成函数的重载"><a href="#方法一：利用函数的arguments来完成函数的重载" class="headerlink" title="方法一：利用函数的arguments来完成函数的重载"></a>方法一：利用函数的arguments来完成函数的重载</h3><pre><code>//函数的声明function overLoading() {　　// 根据arguments.length，对不同的值进行不同的操作　　switch(arguments.length) {　　　　case 0: console.log(&#39;无参&#39;);　　　　　    break;　　　　case 1: console.log(&#39;一个参数&#39;);　　　　　    break;　　　　case 2: console.log(&#39;两个参数&#39;);              break;    } }//函数的调用overLoading();  //结果：无参overLoading(1);  //结果：一个参数overLoading(1,2);  //结果：两个参数</code></pre><h3 id="方法二：《Secrets-of-the-JavaScript-Ninja》中的方法"><a href="#方法二：《Secrets-of-the-JavaScript-Ninja》中的方法" class="headerlink" title="方法二：《Secrets of the JavaScript Ninja》中的方法"></a>方法二：《Secrets of the JavaScript Ninja》中的方法</h3><p>重载方法实例：</p><pre><code>function addMethod(object, name, fn) {　　var old = object[name];   //把前一次添加的方法存在一个临时变量old里面　　object[name] = function() {   // 重写了object[name]的方法　　　　// 如果调用object[name]方法时，传入的参数个数跟预期的一致，则直接调用　　　　if(fn.length === arguments.length) {　　　　　　return fn.apply(this, arguments);　　　　// 否则，判断old是否是函数，如果是，就调用old　　　　} else if(typeof old === &quot;function&quot;) {　　　　　　return old.apply(this, arguments);　　　　}　　}}</code></pre><p>所谓<strong>addMethod</strong>函数，简单的理解，就是给某个<strong>object</strong>，添加一个指定<strong>name</strong>的函数<strong>fn</strong>。它利用了<strong>闭包</strong>，可以通过<strong>old</strong>变量将先后绑定的函数链接起来。</p><p>你可以这样使用<strong>addMethod</strong>函数，将<strong>find</strong>函数直接添加到每个对象实例：</p><pre><code>function Users(){  addMethod(this, &quot;find&quot;, function(){      // Find All  });  addMethod(this, &quot;find&quot;, function(name){    // Find a user by name  });  addMethod(this, &quot;find&quot;, function(first, last){    // Find a user by first and last name  });}</code></pre><p>你也可以将<strong>find</strong>函数添加到对象的<strong>prototype</strong>，这样所有对象实例将共享<strong>find</strong>函数:</p><pre><code>function Users(){    addMethod(Users.prototype, &quot;find&quot;, function(){      // Find all users...    });    addMethod(Users.prototype, &quot;find&quot;, function(name){      // Find a user by name    });    addMethod(Users.prototype, &quot;find&quot;, function(first, last){      // Find a user by first and last name    });}</code></pre><p><strong>users</strong>对象的<strong>find</strong>方法成功实现了重载，可以根据不同的输入调用不同的函数：</p><pre><code>var users = new Users();users.find(); // Finds allusers.find(&quot;John&quot;); //  Finds users by nameusers.find(&quot;John&quot;, &quot;Resig&quot;); // Finds users by first and last nameusers.find(&quot;John&quot;, &quot;E&quot;, &quot;Resig&quot;); // Does nothing</code></pre><p>这种方法有一些明显的缺陷:</p><ul><li>重载只能处理输入参数个数不同的情况，它不能区分参数的类型、名称等其他要素。(ECMAScript 4计划支持这一特性，称作Multimethods，然而该版本已被放弃)。</li><li>重载过的函数将会有一些额外的负载，对于性能要求比较高的应用，使用这个方法要慎重考虑。</li></ul><p><strong>addMethod</strong>函数的秘诀之一在于<strong>fn.length</strong>。或许很多人并不清楚，所有函数都有一个<strong>length</strong>属性，它的值等于定义函数时的参数个数。比如，当你定义的函数只有1个参数时，其<strong>length</strong>属性为1：</p><pre><code>(function(foo){}).length == 1</code></pre><p>如果你担心只绑定单个函数时的性能问题，你可以使用如下<strong>addMethod</strong>函数：</p><pre><code>function addMethod(object, name, fn){    var old = object[ name ];    if ( old )        object[ name ] = function(){            if ( fn.length == arguments.length )                return fn.apply( this, arguments );            else if ( typeof old == &#39;function&#39; )                return old.apply( this, arguments );        };    else        object[ name ] = fn;}</code></pre><p>这样绑定第一个函数时，将不会有额外的操作，既简单又快速。当绑定更多函数时，则与原<strong>addMethod</strong>函数一样，会有额外的性能损失。</p><p>这样做还有一个额外的好处：对于那些参数个数不符合要求的函数调用，将统一又第一个绑定的函数处理。这时调用<strong>find</strong>方法的输出如下：</p><pre><code>var users = new Users();users.find(); // Finds allusers.find(&quot;John&quot;); // Finds users by nameusers.find(&quot;John&quot;, &quot;Resig&quot;); // Finds users by first and last nameusers.find(&quot;John&quot;, &quot;E&quot;, &quot;Resig&quot;); // Finds all</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Css3学习</title>
    <link href="/study.github.io/2018/06/26/Css3%E5%AD%A6%E4%B9%A0/"/>
    <url>/study.github.io/2018/06/26/Css3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h2><pre><code>width: 200px;height: 200px;border: 30px solid pink;box-sizing: border-box;border-image: url(./img/border1.png);/* 切割 */border-image-slice: 30 fill;/* 背景图会被拉升 */border-image-repeat: stretch;/* 将内容缩放进行完整的重复平铺 使得能够正好放下若干元素 */border-image-repeat: round;/* 背景会被直接平铺 */border-image-repeat: repeat;/* 设置边框图片的宽度 */border-image-width: 30px;/* 将背景图延伸到盒子外 不会放大 只会延伸 *//*放大中间部分*/border-image-outset: 100px;</code></pre><h2 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h2><h3 id="简单渐变"><a href="#简单渐变" class="headerlink" title="简单渐变"></a>简单渐变</h3><h4 id="简单线性渐变-linear-gradient"><a href="#简单线性渐变-linear-gradient" class="headerlink" title="简单线性渐变 linear-gradient"></a>简单线性渐变 linear-gradient</h4><pre><code>.box1{    width: 400px;    height: 800px;    margin: 10px auto;    /*linear-gradient(方向，开始颜色位置，颜色2位置，颜色3位置...)    1. to left：设置渐变为从右到左。相当于: 270deg;    2. to right：设置渐变从左到右。相当于: 90deg;       3. to top：设置渐变从下到上。相当于: 0deg;    4. to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。也可以直接指定度数，如45deg    */    background: linear-gradient(to right,pink,skyblue,yellowgreen,orange);    background: linear-gradient(20deg,pink,skyblue,yellowgreen,orange);    background: linear-gradient(-20deg,pink,skyblue,yellowgreen,orange);}</code></pre><h4 id="简单径向渐变radial-gradient"><a href="#简单径向渐变radial-gradient" class="headerlink" title="简单径向渐变radial-gradient"></a>简单径向渐变radial-gradient</h4><pre><code>.box2{    width: 400px;    height: 800px;    margin: 10px auto;    /* radial-gradient(·形状 大小 坐标·,颜色1，颜色2...) */    /* 圆形 */    background: radial-gradient(circle at center,pink,skyblue,yellowgreen,orange);    /* background: radial-gradient(circle at 200px 100px,pink,skyblue,yellowgreen,orange); */    /* 0%至10%是red渐变至green  10%至100%是green渐变至yellow */    background: radial-gradient(circle at 100px 100px,red 0%,green 10%,yellow 100%);    /* 椭圆 */    background: radial-gradient(ellipse at center,pink,skyblue,yellowgreen,orange);    /* 0%至20%是pink渐变至skyblue  20%至40%是skyblue渐变至yellowgreen  40%之后是纯yellowgreen */    background: radial-gradient(ellipse at 10px 100px,pink 0%,skyblue 20%,yellowgreen 40%);    /* 参数加入大小 */    /*    closest-side：最近边；      farthest-side：最远边；     closest-corner：最近角；      farthest-corner：最远角。默认是最远的角farthest-corner      */    /* 渐变的范围边缘触及最近的border结束 */    background: radial-gradient(circle closest-side at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最远的border结束 */    background: radial-gradient(circle farthest-side at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最近的角结束 */    background: radial-gradient(circle closest-corner at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最圆的角结束 */    background: radial-gradient(circle farthest-corner at 10px 500px,pink,skyblue,yellowgreen,orange);}</code></pre><h3 id="重复渐变"><a href="#重复渐变" class="headerlink" title="重复渐变"></a>重复渐变</h3><h4 id="重复线性渐变repeating-linear-gradient"><a href="#重复线性渐变repeating-linear-gradient" class="headerlink" title="重复线性渐变repeating-linear-gradient"></a>重复线性渐变repeating-linear-gradient</h4><pre><code>/* 重复渐变 */.box3 {    width: 400px;    height: 800px;    margin: 10px auto;    /*线性重复性渐变    repeating-linear-gradient(角度,颜色1 %0,颜色2 %10)    */    background: repeating-linear-gradient(45deg,red 0%,red 3%,orange 3%,orange 6%,yellow 6%,yellow 9%,green 9%,green 12%,blue 12%,blue 15%,indigo 15%,indigo 18%,purple 18%,purple 21%); */    /* background: repeating-linear-gradient(45deg,#fff 0px,#fff 2px,#000 2px,#000 4px); */}</code></pre><h4 id="重复径向渐变repeating-radial-gradient"><a href="#重复径向渐变repeating-radial-gradient" class="headerlink" title="重复径向渐变repeating-radial-gradient"></a>重复径向渐变repeating-radial-gradient</h4><pre><code>.box4{    width: 400px;    height: 800px;    margin: 10px auto;    /*径向的重复性渐变    repeating-radial-gradient(形状 终点位置 at 起点位置,颜色1 0%,颜色2 5%,颜色3 10%)    */    background: repeating-radial-gradient(circle farthest-corner at 10px 20px,red 0%,red 3%,orange 3%,orange 6%,yellow 6%,yellow 9%,green 9%,green 12%,blue 12%,blue 15%,indigo 15%,indigo 18%,purple 18%,purple 21%);</code></pre><h3 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h3><p>多次使用渐变，利用透明度，达到交叉效果</p><pre><code>background: repeating-linear-gradient(45deg,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%),repeating-linear-gradient(-45deg,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%);    background: repeating-radial-gradient(circle farthest-corner at left top,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%),repeating-radial-gradient(circle farthest-corner at right top,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%);}</code></pre><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E6%B8%90%E5%8F%98%E8%89%B2.png" srcset="/study.github.io/img/loading.gif" alt="渐变色"></p><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><pre><code>transition: 要过渡的属性  花费时间  运动曲线  何时开始;/*可以一次性设置，也可以分开设置*/    transition-property : 设置哪个属性要进行动画    transition-duration: 设置动画的时间    transition-timing-function : 设置动画运动的曲线(linear  ease  ease-in  ease-out  ease-in-out)    transition-delay : 设置动画延迟的时间</code></pre><h2 id="CSS-2D变形"><a href="#CSS-2D变形" class="headerlink" title="CSS 2D变形"></a>CSS 2D变形</h2><h3 id="translate-x-y"><a href="#translate-x-y" class="headerlink" title="translate(x, y)"></a>translate(x, y)</h3><pre><code>transform: translate(100px,100px);transform: translateX(100px);</code></pre><h3 id="缩放-scale-x-y"><a href="#缩放-scale-x-y" class="headerlink" title="缩放 scale(x, y)"></a>缩放 scale(x, y)</h3><pre><code>transform:scale(0.8,2.0);  //宽  高</code></pre><h3 id="旋转-rotate-deg"><a href="#旋转-rotate-deg" class="headerlink" title="旋转 rotate(deg)"></a>旋转 rotate(deg)</h3><p> 注意设置旋转中心点的时候不要设置在hover上</p><pre><code>transform:rotate(45deg);   //如果是正数，则顺时针，否则为逆时针transform-origin: left top; //默认为centertransform-origin: 10px 100px;</code></pre><h3 id="倾斜-skew-deg-deg"><a href="#倾斜-skew-deg-deg" class="headerlink" title="倾斜 skew(deg, deg)"></a>倾斜 skew(deg, deg)</h3><pre><code>transform:skew(45deg);</code></pre><p> 注意点角度不要是90的奇数整倍数，因为skew时，元素的高度是不发生变化的，当倾斜90度时元素的斜边要水平（上下边要与左右边重合）与高度不为零冲突，元素动画会 <strong>鬼畜</strong></p><p><strong>添加多个变形动画时用空格隔开，如</strong></p><pre><code>transform: rotate(45deg) translateX(100px);</code></pre><h3 id="坐标系问题"><a href="#坐标系问题" class="headerlink" title="坐标系问题"></a>坐标系问题</h3><p>下面两种的效果是不同的</p><pre><code>（1）transform: rotate(45deg) translateX(100px); （2）transform: translateX(100px) rotate(45deg);</code></pre><p>这是因为元素在进行2D变化时是根据坐标轴的，而旋转和缩放会改变坐标轴，发生意想不到的结果。但好好利用可以做出好的动画效果。</p><pre><code>transform: rotate(700deg) translateX(100px); /*达到蜗牛旋转效果*/</code></pre><h2 id="盒子居中的方法"><a href="#盒子居中的方法" class="headerlink" title="盒子居中的方法"></a>盒子居中的方法</h2><h3 id="盒子水平居中的办法"><a href="#盒子水平居中的办法" class="headerlink" title="盒子水平居中的办法"></a>盒子水平居中的办法</h3><p> 1、text-align: center</p><p> 2、margin: auto; 元素需要时block</p><h3 id="盒子垂直居中的办法"><a href="#盒子垂直居中的办法" class="headerlink" title="盒子垂直居中的办法"></a>盒子垂直居中的办法</h3><p> 1、line-height</p><p> 2、padding</p><h3 id="盒子垂直水平居中的方法"><a href="#盒子垂直水平居中的方法" class="headerlink" title="盒子垂直水平居中的方法"></a>盒子垂直水平居中的方法</h3><h4 id="利用transform让盒子垂直水平居中"><a href="#利用transform让盒子垂直水平居中" class="headerlink" title="利用transform让盒子垂直水平居中"></a>利用transform让盒子垂直水平居中</h4><pre><code>width: 200px;height: 200px;background-color: red;position: absolute;/*transform 百分比参照的是元素本身的宽高*/transform: translate(-50%,-50%); /*left和top参照的是父容器宽高的50%*/left: 50%;top:50%;</code></pre><h4 id="利用margin"><a href="#利用margin" class="headerlink" title="利用margin"></a>利用margin</h4><pre><code>position:fixed;width:200px;height:200px;left:50%;top:50%;margin-left:-100px;margin-top:-100px;</code></pre><h4 id="calc和定位的组合使用"><a href="#calc和定位的组合使用" class="headerlink" title="calc和定位的组合使用"></a>calc和定位的组合使用</h4><pre><code>top: calc(50% - 元素高度/2);left: calc(50% - 元素宽度/2);</code></pre><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><pre><code>/*    有：    background-color        背景颜色        background-image        背景图片地址        background-repeat        是否平铺  查手册了解其取值        background-position        背景位置       查手册了解其取值 left right center top bottom  两两搭配                                            使用方位名词时，前后无顺序要求；但是使用数字10px 10px时注意前后顺序        background-attachment    背景固定还是滚动*/div{    width: 400px;    height: 400px;    background-color: skyblue;    background-repeat: no-repeat;/*大小自适应充满*/    background-image: url(../img/girl.jpg);    background-size: 200px;    background-position: center;    /*background-position: 30px 10px;第一个值为X轴 第二个值为Y轴    其中网页顶端为X轴  右为正方向   左边为Y轴  下为正方向*/    /*background-position: 10px center;*/}</code></pre><h2 id="背景缩放"><a href="#背景缩放" class="headerlink" title="背景缩放"></a>背景缩放</h2><pre><code>div{    width: 800px;    height: 500px;    background: #000 url(../img/王者荣耀背景图.jpg) no-repeat top center;    /*background-size: 100px 100px;     设置两个属性值可能导致图片失真扭曲    background-size: 100px;   尽量使用一个属性值 另一个属性值会等比例缩放*/    /*background-size: 50%;     使用一个值 另一个值等比例缩放*/    background-size:cover;     /*会自动  |等比例缩放|  保证图片充满容器 但有可能图片溢出导致部分图片无法显示  【最常用】*/    /*background-size:contain;    等比例缩放，过程中图片的高度或者宽度任意一个属性值满足容器高宽时就停止缩放，保证图片完整性，但可能无法充满容器*/}</code></pre><h2 id="多背景"><a href="#多背景" class="headerlink" title="多背景"></a>多背景</h2><pre><code>/*一个元素可以设置多重背景图像；    每组属性之间使用逗号分隔    如果设置的多重背景图之间存在交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上    为了避免背景色将图像盖住，背景色通常都定义在最后一组上。*/div{    width: 500px;    height: 500px;    /*background: pink url(../img/水浒传.jpg) no-repeat fixed center center;  此处添加fixed后 该图片便以body为容器*/    background: url(../第1阶段HTML/img/水浒传.jpg) no-repeat left top,        url(../第1阶段HTML/img/三国演义.jpg) no-repeat right bottom pink;/*当一个div中需要出现多个背景图片时 中间用逗号隔开。值得注意的是：背景色的设置要放在最后一个设置中，不然会覆盖之前的图片效果*/}</code></pre><h2 id="凹凸文字"><a href="#凹凸文字" class="headerlink" title="凹凸文字"></a>凹凸文字</h2><pre><code>/*凸起*//*text-shadow:水平位置 垂直位置 模糊位置 阴影颜色  右和下为正方向*/text-shadow: 1px 1px 1px #000,-1px -1px 1px #fff;/*凹下*//*text-shadow:水平位置 垂直位置 模糊位置 阴影颜色  右和下为正方向*/text-shadow: 1px 1px 1px #fff,-1px -1px 1px #000;</code></pre><h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2><h3 id="观察距离"><a href="#观察距离" class="headerlink" title="观察距离"></a>观察距离</h3><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E6%99%AF%E6%B7%B1.png" srcset="/study.github.io/img/loading.gif" alt="景深"></p><pre><code>perspective:1000px; /*设置视角与投射面的距离*/</code></pre><p>注意的是：若要给某元素设置景深效果，那么perspective要设置在他的父元素上</p><p>分别设置 transform: translateZ()后的效果</p><pre><code>transform: translateZ(0px);transform: translateZ(500px);transform: translateZ(999px);transform: translateZ(1001px);</code></pre><h3 id="视角观察点"><a href="#视角观察点" class="headerlink" title="视角观察点"></a>视角观察点</h3><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E8%A7%82%E5%AF%9F%E7%82%B9.png" srcset="/study.github.io/img/loading.gif" alt="观察点"></p><p>默认为中心（center center）</p><pre><code>perspective-origin: left top;/*是body的左上角*/perspective-origin: 0px 0px; /*也可以精确化垂点*/</code></pre><h3 id="利用景深达到伪3d效果"><a href="#利用景深达到伪3d效果" class="headerlink" title="利用景深达到伪3d效果"></a>利用景深达到伪3d效果</h3><pre><code>body {    perspective: 1000px;    /*设置视角观察方向 且是相对于body的，且视角是一直垂直与body的*/    perspective-origin: left top;/*是body的左上角*/}.box {    width: 200px;    height: 200px;    border: 2px solid black;    /*transition 设置过渡动画*/    transition: all  1s;}.box1:hover {    transform: translateZ(500px);}&lt;div class=&quot;box box1&quot;&gt;&lt;/div&gt;</code></pre><p>当鼠标移动到box上时触发 transform: translateZ(500px); 致使box在他的Z轴上正方向移动500px;而他的父元素body设置了观察点为body的左上角，则box的移动轨迹是向右下角的。</p><h2 id="3d变形"><a href="#3d变形" class="headerlink" title="3d变形"></a>3d变形</h2><p>(注：3d变形结合景深后可以呈现空间立体效果。)</p><p>每个元素都有自己的坐标系</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/3d%E5%9D%90%E6%A0%87%E7%B3%BB.png" srcset="/study.github.io/img/loading.gif" alt="3d坐标系"></p><h3 id="translate3d-x-y-z"><a href="#translate3d-x-y-z" class="headerlink" title="translate3d(x,y,z)"></a>translate3d(x,y,z)</h3><p>例：</p><pre><code>.box1 {    transform: translate3d(100px,-50px,500px);}/*向x轴正方向移动100px 向y轴负方向移动50px  向z轴正方向移动500px*/</code></pre><h3 id="rotate3d-x-y-z-angle"><a href="#rotate3d-x-y-z-angle" class="headerlink" title="rotate3d(x,y,z,angle)"></a>rotate3d(x,y,z,angle)</h3><p>[x,y,z]向量，定义旋转轴；</p><p>angle定义旋转角度，正值为顺时针，负值为逆时针；</p><p> <strong>关于向量的运作原理</strong></p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F1.png" srcset="/study.github.io/img/loading.gif" alt="1560564644997"></p><p>[x,y,z]向量为[0,0,1]时代表z轴，旋转绕z轴旋转</p><p>[x,y,z]向量为[0,1,0]时代表y轴，旋转绕y轴旋转</p><p>[x,y,z]向量为[1,0,0]时代表x轴，旋转绕x轴旋转</p><p>[x,y,z]向量为[1,1,1]时，旋转轴如图绿色线所示</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F2.png" srcset="/study.github.io/img/loading.gif" alt="1560564933962"></p><p>再加上旋转角度后：</p><pre><code>.box2 {    transform: rotate3d(1,1,1,45deg);}</code></pre><p>效果</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F3.png" srcset="/study.github.io/img/loading.gif" alt="1560565807459"></p><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p> transform-origin: x-axis y-axis z-axis;</p><h3 id="scale3d-x-y-z"><a href="#scale3d-x-y-z" class="headerlink" title="scale3d(x,y,z)"></a>scale3d(x,y,z)</h3><pre><code>/* transform: scaleX(0.5); *//* transform: scaleY(0.5); *//*元素没有厚度 Z轴上的缩放暂时是没有意义的*/scale3d(2,2,0.5);</code></pre><h3 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h3><pre><code>/*当图片不是正面对象用户的时候就隐藏*/backface-visibility: hidden;</code></pre><h3 id="preserve-3d"><a href="#preserve-3d" class="headerlink" title="preserve-3d"></a>preserve-3d</h3><p> 让元素以3d效果去呈现 他是添加在父元素上的一个属性</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p> 关键帧动画(animation)：允许我们在多个状态之间进行动画</p><p> 过渡动画(transition )：允许我们在两个状态之间进行动画</p><p>1、先申明动画函数</p><pre><code>@keyframes Animate{    0%{        /* 可以同时对多个属性添加动画效果 */        transform: scale3d(1,1,1);    }    50%{        transform: scale3d(2,2,2);    }    100%{        transform: scale3d(1,1,1);    }}</code></pre><p>2、使用 并配置</p><pre><code>.box:hover{    /*动画的名字 调用动画函数*/    animation-name: Animate;    /*动画持续的时间*/    animation-duration: 2s;    /*动画延迟多长时间执行*/    animation-delay: 1s;    /*动画运动的曲线  linear匀速动画*/    animation-timing-function: linear;    /*指定动画执行的次数*/    animation-iteration-count: infinite;    /*让动画结束之后保留在动画结束的状态*/    animation-fill-mode: forwards;     /*让动画结束之后保留在动画初始的状态*/    /* animation-fill-mode: backwards;  */}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Photoshop的简单使用</title>
    <link href="/study.github.io/2018/06/24/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/06/24/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Photoshop图像处理专家"><a href="#Photoshop图像处理专家" class="headerlink" title="Photoshop图像处理专家"></a>Photoshop图像处理专家</h1><h2 id="1-学习Ps的目的"><a href="#1-学习Ps的目的" class="headerlink" title="1. 学习Ps的目的"></a>1. 学习Ps的目的</h2><p>虽然ps应该是UI的拿手好戏，但作为前端开发人员，在日常写程序的过程中不免会有用到Ps的时候，会使用Ps可以使得与前端的交接工作变得顺利。</p><p>前端人员的Ps学习目的：</p><p><strong>1) 会简单的抠图</strong></p><p><strong>2) 会简单的修改PSD效果图</strong></p><p><strong>3) 熟练的切图</strong></p><h2 id="2-Photoshop的安装"><a href="#2-Photoshop的安装" class="headerlink" title="2.Photoshop的安装"></a>2.Photoshop的安装</h2><p>现阶段我门使用的是Photoshop-CC（阉割版）</p><p>(64bit) <a href="https://pan.baidu.com/s/1W9b0F-CdHrzIirJpd50Ang" target="_blank" rel="noopener">百度云下载地址</a> 提取码：2rhu</p><p>(32bit) <a href="https://pan.baidu.com/s/1MU-KOriQ8fenWZgxJAX-Vw" target="_blank" rel="noopener">百度云下载地址</a> 提取码： vjmr</p><h2 id="3-Photoshop的界面认识"><a href="#3-Photoshop的界面认识" class="headerlink" title="3.Photoshop的界面认识"></a>3.Photoshop的界面认识</h2><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img1.png" srcset="/study.github.io/img/loading.gif" alt="img1"></p><h2 id="4-Photoshop的基本操作"><a href="#4-Photoshop的基本操作" class="headerlink" title="4.Photoshop的基本操作"></a>4.Photoshop的基本操作</h2><p>基本设置</p><p><strong>视图 –&gt; 标尺</strong></p><p><strong>窗口 –&gt; 信息</strong></p><p><strong>右击标尺可选择标尺单位</strong></p><h3 id="1-新建文件"><a href="#1-新建文件" class="headerlink" title="1) 新建文件"></a>1) 新建文件</h3><pre><code>文件 --&gt; 新建         //Ctrl+n</code></pre><ol><li>在新建对话框中如果宽度和高度的单位不是像素，要改成以像素为单位。平日的开发都是以像素为单位的。</li><li>分辨率固定72，为了避免出现预期之外错误，此值固定不变。</li></ol><h3 id="2-关闭文件"><a href="#2-关闭文件" class="headerlink" title="2) 关闭文件"></a>2) 关闭文件</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img2.png" srcset="/study.github.io/img/loading.gif" alt="img2"></p><p>或者</p><pre><code>Ctrl+W</code></pre><h3 id="3-保存文件"><a href="#3-保存文件" class="headerlink" title="3) 保存文件"></a>3) 保存文件</h3><pre><code>文件 --&gt; 保存        //Ctrl+s</code></pre><h3 id="4-移动工具与缩放变形"><a href="#4-移动工具与缩放变形" class="headerlink" title="4) 移动工具与缩放变形"></a>4) 移动工具与缩放变形</h3><h4 id="移动工具"><a href="#移动工具" class="headerlink" title="移动工具"></a>移动工具</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img3.png" srcset="/study.github.io/img/loading.gif" alt="img3"></p><p>使用案例：将一张图添加到另一张图中。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img4.png" srcset="/study.github.io/img/loading.gif" alt="img4"></p><p>打开一文件后，鼠标左击图片标题不动，向下拖拽成</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img5.png" srcset="/study.github.io/img/loading.gif" alt="img5"></p><p>这时再利用移动工具，将图片移动到目标图片上</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img6.png" srcset="/study.github.io/img/loading.gif" alt="img6"></p><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><pre><code>按住ctrl，鼠标即可对当前图层拖拽，要移动哪个图形，就在在图层面板中选中该图形所在的图层。按方向键可以微调。</code></pre><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><pre><code>Ctrl+t   //当前图层显示变换控件，也可以直接点击工具属性栏中的按钮按住shift可以等比例缩放</code></pre><p>操作完成后，ENTER回车，确认操作。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img7.png" srcset="/study.github.io/img/loading.gif" alt="img7"></p><h3 id="5-图层操作"><a href="#5-图层操作" class="headerlink" title="5) 图层操作"></a>5) 图层操作</h3><pre><code>F7   //图层面板显示/消失按钮</code></pre><h4 id="新建图层与删除"><a href="#新建图层与删除" class="headerlink" title="新建图层与删除"></a>新建图层与删除</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img8.png" srcset="/study.github.io/img/loading.gif" alt="img8"></p><h4 id="图层层叠"><a href="#图层层叠" class="headerlink" title="图层层叠"></a>图层层叠</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img9.png" srcset="/study.github.io/img/loading.gif" alt="img9"></p><p>此时鸣人是压着佐助的，这时因为佐助所在的图层在鸣人所在图层的下面。</p><p>我们将图层2 拖住至图层1上方，此时佐助就跑到鸣人上面了。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img10.png" srcset="/study.github.io/img/loading.gif" alt="img10"></p><h4 id="图层复制"><a href="#图层复制" class="headerlink" title="图层复制"></a>图层复制</h4><p>选择移动工具后</p><pre><code>1.按住Alt 拖拽图像2.Ctrl+j (重合复制)</code></pre><h4 id="图层编组"><a href="#图层编组" class="headerlink" title="图层编组"></a>图层编组</h4><p>选定所有待分组图层后</p><pre><code>ctrl+g  //创建分组ctrl+shift+g //取消分组</code></pre><p>图层或编组重命名</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img11.png" srcset="/study.github.io/img/loading.gif" alt="img11"></p><p>组操作或图层操作切换</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img12.png" srcset="/study.github.io/img/loading.gif" alt="img12"></p><h4 id="图层合并"><a href="#图层合并" class="headerlink" title="图层合并"></a>图层合并</h4><p>选中待合并图层后</p><pre><code>ctrl+e</code></pre><h4 id="图层的不透明度"><a href="#图层的不透明度" class="headerlink" title="图层的不透明度"></a>图层的不透明度</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img13.png" srcset="/study.github.io/img/loading.gif" alt="img13"></p><h3 id="6-选区工具"><a href="#6-选区工具" class="headerlink" title="6) 选区工具"></a>6) 选区工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img14.png" srcset="/study.github.io/img/loading.gif" alt="img14"></p><pre><code>Ctrl+D  //取消分区</code></pre><h3 id="7-磁性套索工具"><a href="#7-磁性套索工具" class="headerlink" title="7) 磁性套索工具"></a>7) 磁性套索工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img15.png" srcset="/study.github.io/img/loading.gif" alt="磁性套索工具"></p><h3 id="8-魔棒工具"><a href="#8-魔棒工具" class="headerlink" title="8) 魔棒工具"></a>8) 魔棒工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img16.png" srcset="/study.github.io/img/loading.gif" alt="魔棒工具"></p><p><strong>容差的概念：简单来说，容差越大选区范围越广，容差越小选区范围越宅</strong></p><h3 id="9-选区的布尔运算"><a href="#9-选区的布尔运算" class="headerlink" title="9) 选区的布尔运算"></a>9) 选区的布尔运算</h3><p>就是在原有选区的基础上，加上新的选区或减去分区。</p><pre><code>按住shift 再继续选区   //加选区按住Alt  再选区    //减选区Ctrl+shift+i   //反选</code></pre><h3 id="10-钢笔工具"><a href="#10-钢笔工具" class="headerlink" title="10) 钢笔工具"></a>10) 钢笔工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img17.png" srcset="/study.github.io/img/loading.gif" alt="钢笔工具"></p><ol><li>点击第一个点</li><li>再点击第二点时按住鼠标不动进行拖拽，会形成一个可控的弧线</li><li>上一条线为弧线后，与下一个点之间会默认为弧（取消办法：按住Alt，点击上一个点，即可取消）</li><li>完成一个闭合曲线</li><li>Ctrl+ENTER 形成选区</li></ol><h3 id="11-文字工具"><a href="#11-文字工具" class="headerlink" title="11) 文字工具"></a>11) 文字工具</h3><p>略</p><h3 id="12-吸管工具"><a href="#12-吸管工具" class="headerlink" title="12) 吸管工具"></a>12) 吸管工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img18.png" srcset="/study.github.io/img/loading.gif" alt="吸管工具1"></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img19.png" srcset="/study.github.io/img/loading.gif" alt="吸管工具2"></p><h3 id="13）切片工具"><a href="#13）切片工具" class="headerlink" title="13）切片工具"></a>13）切片工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img20.png" srcset="/study.github.io/img/loading.gif" alt="切片工具"></p><h4 id="手动切片"><a href="#手动切片" class="headerlink" title="手动切片"></a>手动切片</h4><p>1.用切片工具选取目标区域</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img21.png" srcset="/study.github.io/img/loading.gif" alt="切片选区"></p><p>2.<strong>文件 –&gt;储存为web所用格式</strong></p><pre><code>Alt+Ctrl+shift+S  //存储为web所用格式快捷键</code></pre><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img22.png" srcset="/study.github.io/img/loading.gif" alt="选定格式"></p><p><strong>存储时，要记得选中“选中的切片”</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img23.png" srcset="/study.github.io/img/loading.gif" alt="储存"></p><h4 id="图层切片"><a href="#图层切片" class="headerlink" title="图层切片"></a>图层切片</h4><p>1.选中目标图层</p><p>2.<strong>图层 –&gt; 新建基于图层的切片</strong></p><p>3.存储</p><h3 id="辅助线切图"><a href="#辅助线切图" class="headerlink" title="辅助线切图"></a>辅助线切图</h3><p>1.标尺部分拖拽出辅助线，将图片进行分割。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img25.png" srcset="/study.github.io/img/loading.gif" alt="辅助线切图"></p><p>2.点击属性栏中的基于参考线的切片</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img26.png" srcset="/study.github.io/img/loading.gif" alt="基于参考线的切片"></p><p>3.存储</p><h3 id="等份数切片"><a href="#等份数切片" class="headerlink" title="等份数切片"></a>等份数切片</h3><p>1.<strong>切片选择工具 –&gt;划分</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img27.png" srcset="/study.github.io/img/loading.gif" alt="等分数切片"></p><p>2.选择等份切片方式</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img28.png" srcset="/study.github.io/img/loading.gif" alt="划分"></p><p>3.存储</p><h4 id="清除全部切片和辅助线"><a href="#清除全部切片和辅助线" class="headerlink" title="清除全部切片和辅助线"></a>清除全部切片和辅助线</h4><p>1.视图 –&gt; 清除切片</p><p>2.视图 –&gt; 清除参考线</p><h4 id="切片注意"><a href="#切片注意" class="headerlink" title="切片注意"></a>切片注意</h4><p><strong>1.当切片时发现有其他图层盖住了目标图层，用利用“小眼睛”将其他图层隐藏</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img24.png" srcset="/study.github.io/img/loading.gif" alt="切片注意"></p><p><strong>2.切片存储时，若要一次存储多个切片，可按住shift再点击目标切片</strong></p><h2 id="5-Photoshop的快捷键"><a href="#5-Photoshop的快捷键" class="headerlink" title="5.Photoshop的快捷键"></a>5.Photoshop的快捷键</h2><ol><li>Ctrl+Z //撤销上一步</li><li>Alt+Ctrl+Z //撤销多步</li><li>Alt+滚轮 //放大、缩小</li><li>Ctrl+滚轮 //左右移动</li><li>Ctrl+D //取消选择</li><li>Ctrl+shift+D //重新选择</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Npm与Yarn的使用</title>
    <link href="/study.github.io/2018/06/21/Npm%E4%B8%8EYarn%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/06/21/Npm%E4%B8%8EYarn%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-amp-YARN"><a href="#NPM-amp-YARN" class="headerlink" title="NPM&amp;YARN"></a>NPM&amp;YARN</h1><h2 id="npm常用的命令"><a href="#npm常用的命令" class="headerlink" title="npm常用的命令"></a>npm常用的命令</h2><p>全局安装：默认安装在Node.js环境的node_modules目录下，全局安装的包一般用于命令行工具</p><p>本地安装：一般用于开发某种具体的功能</p><p> 1、安装包（若不指定版本号 默认安装最新版本）</p><pre><code>npm install -g 安装包名称     （全局安装）npm install 安装包名称      （本地安装）</code></pre><pre><code>例： npm install es-checker     //安装es6例： npm install</code></pre><p>2、卸载包</p><pre><code>npm uninstall -g 安装包名称     （全局卸载）npm uninstall 安装包名称      （本地卸载）例： npm uninstall es-checker     //卸载es6</code></pre><p>3、更新包 （更新到最新版本号）</p><pre><code>npm updata -g 安装包名称</code></pre><p>4、添加依赖</p><pre><code>--save   （向生产环境添加依赖） 生产环境是项目部署上线之后的服务器环境--save-dev   （向开发环境添加依赖） 开发环境是平时开发使用的环境//例子：npm install es-checker --save//例子：npm install es-checker --save-dev</code></pre><p>安装服务器自动重启</p><pre><code>npm install -g nodemon</code></pre><h2 id="npm安装包的步骤"><a href="#npm安装包的步骤" class="headerlink" title="npm安装包的步骤"></a>npm安装包的步骤</h2><p>1、初始化</p><pre><code>npm init //初始化 生成package.json文件</code></pre><p>2、安装包</p><pre><code>npm install 安装包名称      （本地安装）</code></pre><p>3、若存在package.json文件 和 package-lock.json文件，恢复安装</p><pre><code>npm install</code></pre><h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p>安装yarn工具</p><pre><code>npm install -g yarn</code></pre><h2 id="yarn中的命令"><a href="#yarn中的命令" class="headerlink" title="yarn中的命令"></a>yarn中的命令</h2><p>1、初始化包</p><pre><code>npm init  //npm中的初始化方式yarn init  //yarn中初始化方式</code></pre><p>2、安装包</p><pre><code>npm install xxx --save //npm中的安装方式yarn add xxx  //yarn中的安装方式</code></pre><p>3、移除包</p><pre><code>npm uninstall xxx  //npm中的移除方式yarn remove xxx  //yarn中的移除方式</code></pre><p>4、更新包</p><pre><code>npm update xxxyarn upgrade xxx</code></pre><p>5、安装开发依赖的包</p><pre><code>npm install xxx --save-devyarn  add xxx --dev</code></pre><p>6、全局安装</p><pre><code>npm install -g xxxyarn globar add xxx</code></pre><p>7、设置下载镜像的地址</p><pre><code>npm config set registry urlyarn config set registry url</code></pre><p>8、安装所有依赖</p><pre><code>npm installyarn install</code></pre><p>9、执行包</p><pre><code>npm runyarn run</code></pre><h1 id="切换源"><a href="#切换源" class="headerlink" title="切换源"></a>切换源</h1><p>安装nrm</p><pre><code>npm install nrm</code></pre><p>查看源</p><pre><code>nrm ls</code></pre><p>切换</p><pre><code>nrm xxx</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于浮动的若干问题</title>
    <link href="/study.github.io/2018/06/20/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2018/06/20/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标准文档流"><a href="#1-标准文档流" class="headerlink" title="1.标准文档流"></a>1.标准文档流</h1><p>标准流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做标准流布局。</p><h1 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2.浮动"></a>2.浮动</h1><h2 id="2-1-浮动的机制"><a href="#2-1-浮动的机制" class="headerlink" title="2.1 浮动的机制"></a>2.1 浮动的机制</h2><p>当有两个div同时在标准刘文档中的时候，两个div会隔行显示：</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img1.png" srcset="/study.github.io/img/loading.gif" alt="img1"></p><pre><code>(2D图)</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img4.png" srcset="/study.github.io/img/loading.gif" alt="img4"></p><pre><code>**（3D图）**</code></pre><p>当将蓝色div对应的CSS添加浮动属性后，蓝色div会脱离标准流，而浮在标准流之上</p><pre><code>float: left;</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img2.png" srcset="/study.github.io/img/loading.gif" alt="img2"></p><pre><code>**（2D图）**</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img5.png" srcset="/study.github.io/img/loading.gif" alt="img5"></p><pre><code>**（3D图）**</code></pre><p>将蓝色div和红色div同时设置浮动属性后，两者都处于浮动的层次，显示方式默认为贴边水平并排显示</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img3.png" srcset="/study.github.io/img/loading.gif" alt="img3"></p><pre><code>**（2D图）**</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img6.png" srcset="/study.github.io/img/loading.gif" alt="img6"></p><pre><code>**（3D图）**</code></pre><h2 id="2-2-浮动的使用"><a href="#2-2-浮动的使用" class="headerlink" title="2.2 浮动的使用"></a>2.2 浮动的使用</h2><pre><code>选择器{float:属性值;}</code></pre><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">元素向左浮动</td></tr><tr><td align="center">right</td><td align="center">元素向右浮动</td></tr><tr><td align="center">none</td><td align="center">元素不浮动（默认值）</td></tr></tbody></table><h2 id="2-3-清除浮动"><a href="#2-3-清除浮动" class="headerlink" title="2.3 清除浮动"></a>2.3 清除浮动</h2><h3 id="2-3-1-为什么要清除浮动"><a href="#2-3-1-为什么要清除浮动" class="headerlink" title="2.3.1 为什么要清除浮动"></a>2.3.1 为什么要清除浮动</h3><p>浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。</p><p>由于<strong>浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</strong>，为了解决这些问题，此时就需要在该元素中清除浮动。</p><p>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p><h3 id="2-3-2-清除浮动的本质"><a href="#2-3-2-清除浮动的本质" class="headerlink" title="2.3.2 清除浮动的本质"></a>2.3.2 清除浮动的本质</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img7.jpg" srcset="/study.github.io/img/loading.gif" alt="img7"></p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img8.jpg" srcset="/study.github.io/img/loading.gif" alt="img8"></p><h3 id="2-3-3-清除浮动的方法"><a href="#2-3-3-清除浮动的方法" class="headerlink" title="2.3.3 清除浮动的方法"></a>2.3.3 清除浮动的方法</h3><h4 id="1-用clear属性清除浮动"><a href="#1-用clear属性清除浮动" class="headerlink" title="1)用clear属性清除浮动"></a>1)用clear属性清除浮动</h4><pre><code>选择器{clear:属性值;}</code></pre><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td align="center">right</td><td align="center">不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td align="center">both</td><td align="center">同时清除左右两侧浮动的影响</td></tr></tbody></table><h4 id="2-额外标签法"><a href="#2-额外标签法" class="headerlink" title="2)额外标签法"></a>2)额外标签法</h4><p>在浮动元素末尾添加一个大小为0，内容为空的标签，如：</p><pre><code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></pre><p><strong>（不推荐）</strong></p><h4 id="3-父级添加overflow属性方法"><a href="#3-父级添加overflow属性方法" class="headerlink" title="3)父级添加overflow属性方法"></a>3)父级添加overflow属性方法</h4><p>给父级元素添加</p><pre><code>overflow： hidden；  /*auto、scroll都可以*/</code></pre><h4 id="4-使用after伪元素清除浮动"><a href="#4-使用after伪元素清除浮动" class="headerlink" title="4) 使用after伪元素清除浮动"></a>4) 使用after伪元素清除浮动</h4><p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong> 。</p><pre><code>.clearfix::after {  content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden;  }   .clearfix {*zoom: 1;}   /*IE6、7 专有 ，星号表示IE7之下浏览器识别，其他浏览器不识别*/                                    /*然后给父元素加上clearfix类就可以了*/</code></pre><h4 id="5-使用before和after双伪元素清除浮动"><a href="#5-使用before和after双伪元素清除浮动" class="headerlink" title="5)使用before和after双伪元素清除浮动"></a>5)使用before和after双伪元素清除浮动</h4><pre><code>.clearfix::before,.clearfix::after {   content:&quot;&quot;;  display:table;  }.clearfix:after {  clear:both;}.clearfix {  *zoom:1;} /*然后给父元素加上clearfix类就可以了*/</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/study.github.io/2018/06/19/Ajax/"/>
    <url>/study.github.io/2018/06/19/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="什么是AJAX？"><a href="#什么是AJAX？" class="headerlink" title="什么是AJAX？"></a>什么是AJAX？</h2><p> Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p><p><strong>AJAX的好处</strong>：可以通过<code>js</code>代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能</p><h2 id="创建AJAX对象"><a href="#创建AJAX对象" class="headerlink" title="创建AJAX对象"></a>创建AJAX对象</h2><pre><code>//兼容性写法  ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);是为了兼容IE5 IE6var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);</code></pre><h2 id="AJAX的方法"><a href="#AJAX的方法" class="headerlink" title="AJAX的方法"></a>AJAX的方法</h2><pre><code>//设置请求方式ajax.open(&quot;post&quot;,&quot;url&quot;,true);  //第三个参数如果为true，则是异步，反之同步//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);//发送请求:get请求参数放在url后面，post请求参数send()方法里面ajax.send(&quot;数据&quot;); //监听ajax状态，当ajax的状态发生改变的时候执行ajax.onreadystatechange = function(){    //响应完成，浏览器已经可以获取到服务器响应结果了    if(this.readyState == 4){  //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性        //http响应的状态码        if(this.state == 200){  //还有302  301  404...            //获取响应内容            console.log(this.responseText); //用ajax.responseText获取服务器返回的数据                //responseText 获得字符串形式的响应数据。               //responseXML 获得XML 形式的响应数据        }    }}</code></pre><h2 id="数据渲染的两种方式"><a href="#数据渲染的两种方式" class="headerlink" title="数据渲染的两种方式"></a>数据渲染的两种方式</h2><h3 id="数据在服务器中渲染完毕，返回给客户端一个完整页面"><a href="#数据在服务器中渲染完毕，返回给客户端一个完整页面" class="headerlink" title="数据在服务器中渲染完毕，返回给客户端一个完整页面"></a>数据在服务器中渲染完毕，返回给客户端一个完整页面</h3><ol><li>浏览器发送请求至服务器</li><li>服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端</li><li>客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板）</li></ol><h3 id="服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"><a href="#服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示" class="headerlink" title="服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"></a>服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示</h3><ol><li>客户端发送数据请求给服务器</li><li>服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端</li><li>客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js）</li></ol><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML extensible Markup Language 扩展的标记语言，XML的标签可以自定义<br>HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个</p><p><strong>XML用途：</strong><br>1、 定义数据结构<br>2、 作为配置文件出现</p><p><strong>XML组成：</strong><br>1、 XML文档声明<br>2、 XML标签<br>3、 XML属性<br>4、 XML注释</p><p><strong>XML文档注意点：</strong><br>1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如<br>2）xml标签名称区分大小写。<br>3）xml标签一定要正确配对。<br>4）xml标签名中间不能使用空格<br>5）xml标签名不能以数字开头<br>6）注意： 在一个xml文档中，有且仅有一个根标签</p><pre><code>//使用xml设计一个通讯录&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;contact&gt;    &lt;person id=&quot;100&quot;&gt;         &lt;name&gt;张三&lt;/name&gt;         &lt;age&gt;18&lt;/age&gt;         &lt;phone&gt;12345678&lt;/phone&gt;         &lt;email&gt;12453@qq.com&lt;/email&gt;    &lt;/person&gt;    &lt;person id=&quot;101&quot;&gt;         &lt;name&gt;李四&lt;/name&gt;         &lt;age&gt;20&lt;/age&gt;         &lt;phone&gt;22345678&lt;/phone&gt;         &lt;email&gt;34453@qq.com&lt;/email&gt;    &lt;/person&gt;&lt;/contact&gt;</code></pre><p><strong>xml的使用</strong></p><pre><code>//服务器代码//返回XML格式的数据app.get(&quot;/getXML&quot;,(req,res)=&gt;{    //设置响应头，指定返回的数据是XML    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);    var xml =  &#39;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&#39;;//XML文档声明    xml += &#39;&lt;person&gt;&#39;;    xml += &#39;&lt;name&gt;羊杨&lt;/name&gt;&#39;;    xml += &#39;&lt;age&gt;16&lt;/age&gt;&#39;;    xml += &#39;&lt;gender&gt;男&lt;/gender&gt;&#39;;    xml += &#39;&lt;/person&gt;&#39;;    res.send(xml);})//客户端代码ajax.onreadystatechange = function(){    if(this.readyState == 4){        //获取响应的XML数据        var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据        var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据  但此时age是&lt;age&gt;16&lt;/age&gt;        console.log(age.innerHTML);//此处用innerText拿不到数据        console.log(xml.children);//xml的语法几乎与html语法类似    }}</code></pre><p>JSON</p><p>json数据的使用</p><pre><code>//服务器代码//返回JSON格式的数据app.get(&quot;/getJSON&quot;,(req,res)=&gt;{    //数组    let arr = [        {            name:&quot;zhangsan&quot;,            age:&quot;18&quot;,            gender:&quot;男&quot;,            id:001        },        {            name:&quot;lisi&quot;,            age:&quot;28&quot;,            gender:&quot;男&quot;,            id:002        }    ]    //将数组转换为JSON数据    res.status(200).send(JSON.stringify(arr));})//客户端代码ajax.onreadystatechange = function(){    if(this.readyState == 4){        console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象        var students = JSON.parse(this.responseText);        var html = template(&quot;generatorTable&quot;,{students:students});        container.innerHTML = html;    }}</code></pre><h2 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h2><p>推荐使用 方便的一批</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>客户端代码</p><pre><code>$.ajax({    //请求方式    type:&quot;get&quot;, //post    //请求路径    url:&quot;&quot;, //如http://localhost:3000/index    //请求参数，无论是get还是post请求，请求参数都可以写在这里    //注意：请求为get时  在服务器得到请求参数时 仍然使用res.query    //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify({[{},{}]})    data:{name:&quot;zhangsan&quot;},    //规定所要请求的数据的类型    dataType: &#39;&#39;,    //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写    //contentType: &quot;application/x-www-form-urlencoded&quot;,    //请求成功的回调    success:function(res){        console.log(res);//res是请求的到的数据    }    //请求出错的回调 推荐写    error:function(err){        console.log(err);    }    //无论请求的成功与否，只要请求结束都会执行此函数    complete:function(xhr){    }})</code></pre><p>服务器代码</p><pre><code>let express = require(&quot;express&quot;);let app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));//注意 当客户端中的data:JSON.stringify([{name:&#39;zhangsan&#39;},{name:&#39;lisi&#39;}])时，服务器需要此配置//以解析body中的json数据app.use(bodyParser.json({extended:false}));app.use(express.static(&quot;./views&quot;));//当ajax的url为&#39;/getJSON&#39;时 此接口响应 返回JSON格式的数据//此时ajax的dataType要设置为&#39;json&#39;app.get(&quot;/getJSON&quot;,(req,res)=&gt;{    //数组    let arr = [        {            name:&quot;zhangsan&quot;,            age:&quot;18&quot;,            gender:&quot;男&quot;,            id:001        },        {            name:&quot;lisi&quot;,            age:&quot;28&quot;,            gender:&quot;男&quot;,            id:002        }    ]    arr.forEach((user,idx)={        if(user.name == req.body.name){            res.status(200).send(JSON.stringify(user));        }    })})//当ajax的url为&#39;/getXML&#39;时 此接口响应 返回XML格式的数据//此时ajax的dataType要设置为&#39;xml&#39;app.get(&quot;/getXML&quot;,(req,res)=&gt;{    //设置响应头，指定返回的数据是XML    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);    var xml =  &#39;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&#39;;    xml += &#39;&lt;person&gt;&#39;;    xml += &#39;&lt;name&gt;zhangsan&lt;/name&gt;&#39;;    xml += &#39;&lt;age&gt;16&lt;/age&gt;&#39;;    xml += &#39;&lt;gender&gt;男&lt;/gender&gt;&#39;;    xml += &#39;&lt;/person&gt;&#39;;    res.send(xml);})</code></pre><p>发送也接受html或script数据</p><p>服务器代码</p><pre><code>const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.use(express.static(&#39;views&#39;));app.get(&#39;/getScript&#39;,(req,res)=&gt;{    res.header(&#39;content-type&#39;,&#39;application/javascript;charset=utf-8&#39;);    res.send(&#39;alert(123);&#39;);});app.get(&#39;/getHtml&#39;,(req,res)=&gt;{    res.header(&#39;content-type&#39;,&#39;text/html;charset=utf-8&#39;)    res.send(&#39;&lt;h1&gt;HTML&lt;/h1&gt;&#39;);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><p>客户端代码</p><pre><code>$(&#39;#btn1&#39;).click(function(){    $.ajax({        type: &#39;get&#39;,        url: &#39;/getHtml&#39;,        data: &#39;&#39;,        dataType: &#39;html&#39;,        success:function(res){            //因为dataType为html  jQuery。AJAX会自动设置响应头为text/html  则 可以直接追加res到页面中            $(&#39;#info&#39;).append(res);        },        error:function(err){            console.log(err);        }    });});$(&#39;#btn2&#39;).click(function(){    $.ajax({        type: &#39;get&#39;,        url: &#39;/getScript&#39;,        data: &#39;&#39;,        dataType: &#39;script&#39;,        success:function(res){            //之所以alert()能执行  是因为将script代码打印到控制台  控制台会执行script代码            //也可以用script标签的对res进行封装 追加到页面中 也可以执行            console.log(res);        },        error:function(err){            console.log(err);        }    });});</code></pre><h3 id="dataType"><a href="#dataType" class="headerlink" title="dataType"></a>dataType</h3><p><strong>dataType取值有xml、html、json、jsonp、script或者text</strong></p><p>当dataType取值为<strong>json</strong>，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。<br>服务器应该设置这个响应头：<strong>res.header(“content-type”, “application/json;charset=utf-8”);</strong></p><p>当dataType为<strong>xml或者text</strong>的时候，返回的数据不会另做处理<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/xml”);</strong><br><strong>res.header(“content-type”,”text/plain;charset=utf-8”);</strong></p><p>当dataType为<strong>html</strong>的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”text/html;charset=utf-8”);</strong></p><p>当dataType为<strong>script</strong>的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><p>当dataType为<strong>jsonp</strong>的时候，会向服务器发送一个jsonp请求<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><h2 id="nprogress的使用（全局事件处理）"><a href="#nprogress的使用（全局事件处理）" class="headerlink" title="nprogress的使用（全局事件处理）"></a>nprogress的使用（全局事件处理）</h2><p>1、在html文件中引入nprogress.js 和 nprogress.css</p><p>2</p><pre><code>$(document).ajaxStart(function(){//请求数据开始    NProgress.start();//数据加载动画}).ajaxStop(function(){//请求数据结束    NProgress.done();//数据加载完毕动画});</code></pre><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p><strong>同源策略</strong>是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口完全相同</strong> ，只有同源的地址才可以相互通过AJAX的方式请求。</p><p>同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为<strong>跨域请求</strong></p><p>例如</p><pre><code>http://localhost:8000  是不可以通过ajax访问  http://locally.uieee.com/categories的因为两者不满足同源的条件</code></pre><h3 id="如何进行跨域请求"><a href="#如何进行跨域请求" class="headerlink" title="如何进行跨域请求"></a>如何进行跨域请求</h3><ol><li>CORS</li><li>JSONP</li><li>代理服务器</li><li>修改document.domain</li><li>Iframe</li><li>Location.hash</li><li>Window.postMessage()</li><li>Websocket</li></ol><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax()</p><p>Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。</p><pre><code>//直接在服务器配置如下,客户端代码和以前一样写app.all(&#39;*&#39;, function(req, res, next) {    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-type&#39;);    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;);    res.header(&#39;Access-Control-Max-Age&#39;,6000);//预请求缓存10分钟    next();  });</code></pre><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求</p><p>需要服务器和客户端配合</p><pre><code>//此时客户端的地址为http://localhost:3000实现要点//客户端代码var script = document.createElement(&#39;script&#39;);script.src = &#39;http://localhost:9999/testJSONP&#39;;//向http://localhost:9999发送跨域请求document.body.appendChild(script)//服务器代码app.get(&quot;/testJSONP&quot;,(req,res)=&gt;{    //设置响应头 服务器给客户端发送了一个js代码块    res.header(&quot;content-type&quot;,&quot;application/javascript&quot;);    let data = JSON.stringify({&quot;name&quot;:&quot;zhangsan&quot;}) ;    //服务器发送 `foo(&#39;{&quot;name&quot;:&quot;zhangsan&quot;}&#39;)` 这个字符串给客户端    res.send(`foo(${data})`);})//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数function foo(data){    console.log(data);}</code></pre><p><strong>jQuery代码</strong></p><pre><code>//客户端代码$.ajax({    type:&quot;get&quot;,    url:&quot;http://localhost:9999/testJSONP&quot;,    data:&#39;&#39;,    dataType: &#39;jsonp&#39;,    success:function(res){        $(&#39;body&#39;).append(res);    }    error:function(err){        console.log(err);    }    complete:function(xhr){    }});function foo(data){    console.log(data);}//服务器http://localhost:3000代码const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.use(express.static(&#39;views&#39;));app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});//服务器http://localhost:8888代码const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.get(&#39;/getJsonp&#39;,(req,res)=&gt;{    res.send(&#39;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&#39;);});app.listen(8888,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>AJAX是通过<code>XMLHttpRequest</code>或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
