<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React+sockt.io实现简易聊天室</title>
    <link href="/study.github.io/2019/11/24/React-sockt-io%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/study.github.io/2019/11/24/React-sockt-io%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h1><blockquote><p>省略一万字</p></blockquote><h1 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h1><p><a href="https://socket.io/docs/server-api/" target="_blank" rel="noopener">服务器端</a></p><p><a href="https://socket.io/docs/client-api/" target="_blank" rel="noopener">客户端</a></p><h1 id="React-socket-io-实现简易聊天室"><a href="#React-socket-io-实现简易聊天室" class="headerlink" title="React + socket.io 实现简易聊天室"></a>React + socket.io 实现简易聊天室</h1><blockquote><p>我们由浅入深，先实现基础功能，再一步一步添加功能</p></blockquote><h2 id="第一步、React前端-与-服务器端建立链接"><a href="#第一步、React前端-与-服务器端建立链接" class="headerlink" title="第一步、React前端 与 服务器端建立链接"></a>第一步、React前端 与 服务器端建立链接</h2><blockquote><p>前言：</p><ul><li>简单理解socket.io中的<code>on</code>和 <code>emit</code>，相当于中央事件总线的<code>on</code>和<code>emit</code>；<code>on</code>表示接受对应事件，<code>emit</code>表示派发事件，两者是对应关系。</li><li>服务端和客户端的链接是一对多的关系</li><li>客户端 <code>emit</code>的事件只能被服务端的<code>on</code>接受，服务端的<code>emit</code>会被所有客户端的<code>on</code>接受</li><li>socket.io中的 <code>connect</code>与 <code>disconnect</code>事件是默认<code>emit</code>的</li></ul></blockquote><p><strong>服务端</strong></p><p>首先使用<code>npm</code>初始化一个项目，并在项目内安装 <code>socket.io</code></p><pre><code>// 服务端代码const io = require(&#39;socket.io&#39;)(4000, {  // 对应客户端的path  path: &#39;/socket.chat&#39;,  // serveClient 是否相应客户端请求  serveClient: true,  // transports 数组的前后顺序关系到socket创建实例，此处优先创建 ws    默认值为 [&#39;polling&#39;, &#39;websocket&#39;]  transports: [&#39;websocket&#39;, &#39;polling&#39;]});const connections = [];io.sockets.on(&#39;connect&#39;, function (socket) {  connections.push(socket);  io.sockets.emit(&#39;userCount&#39;, { msg: connections.length })  console.log(&#39;connected &gt;&gt;&gt; [ %s ] online, [ %s ]&#39;, connections.length, new Date())  socket.on(&#39;disconnect&#39;, function (data) {    connections.splice(connections.indexOf(socket), 1);    console.log(&#39;disconnect &gt;&gt;&gt; [ %s ] online&#39;, connections.length);    delete socket;  })})console.log(`Server running on prot ${process.env.PORT || 4000}`);// 启动$ nodemon App.js</code></pre><p><strong>客户端</strong></p><p>使用 <code>create-react-app</code>创建项目，并安装 <code>socket.io</code></p><pre><code>// 客户端代码import React, { useMemo, useEffect } from &#39;react&#39;import styles from &#39;./index.module.scss&#39;import io from &#39;socket.io-client&#39;;export default props =&gt; {    // 注意此处必须要使用useMemo来创建socket对象，    // 否则组件的State每改变一次，都会创建一个新的socket对象，而导致连接数不断增加    const socket = useMemo(() =&gt; {        // http://localhost:4000 对应的是服务器地址        return io(&#39;http://localhost:4000&#39;, {            // 对应服务器的path            path: &#39;/socket.chat&#39;,            // 默认值为 [ &#39;polling&#39; ]            transports: [&#39;websocket&#39;]        });    }, [])    useEffect(() =&gt; {        socket.on(&#39;connect&#39;, () =&gt; {            socket.connected ? console.log(&#39;已连接...&#39;) : console.error(&#39;连接失败&#39;);        });    }, [socket])    return &lt;div&gt;&lt;/div&gt;}// 启动项目$ npm start// 输入localhost:3000</code></pre><p>若连接成功，则显示</p><p><img src="https://howlcn1997.github.io/2019/11/12/React%20+%20socket.io%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%A4/%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" srcset="/study.github.io/img/loading.gif" alt="建立连接"></p><p>浏览器新开一个标签页，后再输入 <code>localhost:3000</code></p><p><img src="https://howlcn1997.github.io/2019/11/12/React%20+%20socket.io%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%81%8A%E5%A4%A9%E5%AE%A4/%E5%BB%BA%E7%AB%8B%E9%93%BE%E6%8E%A52.png" srcset="/study.github.io/img/loading.gif" alt="建立链接2"></p><p>若其他设备与本机在同一局域网下时，输入本机对应局域网 ip 地址加端口号，也可以连接到服务器而建立链接。</p><h2 id="第二步、发送消息并在各设备间同步"><a href="#第二步、发送消息并在各设备间同步" class="headerlink" title="第二步、发送消息并在各设备间同步"></a>第二步、发送消息并在各设备间同步</h2><p><strong>服务端</strong></p><pre><code>const io = require(&#39;socket.io&#39;)(4000, {    path: &#39;/socket.chat&#39;,    serveClient: true,    transports: [&#39;websocket&#39;, &#39;polling&#39;]});const connections = [];io.sockets.on(&#39;connect&#39;, function (socket) {    connections.push(socket);    console.log(&#39;connected &gt;&gt;&gt; [ %s ] online, [ %s ]&#39;, connections.length, new Date())    socket.on(&#39;disconnect&#39;, function (data)               connections.splice(connections.indexOf(socket), 1);              console.log(&#39;disconnect &gt;&gt;&gt; [ %s ] online&#39;, connections.length);    delete socket;})// 设置接收器socket.on(&#39;sendMessage&#39;, function (data) {    console.log(data)    // 接收到消息后，再广播到各个设备    io.sockets.emit(&#39;newMessage&#39;, { msg: data })})})console.log(`Server running on prot ${process.env.PORT || 4000}`);</code></pre><p><strong>客户端</strong></p><pre><code>import React, { useState, useMemo, useCallback, useEffect } from &#39;react&#39;import styles from &#39;./index.module.scss&#39;import io from &#39;socket.io-client&#39;;export default props =&gt; {    const [sendMessage, setSendMessage] = useState(&#39;&#39;);    const [receiveMessage, setReceiveMessage] = useState([]);    const socket = useMemo(() =&gt; {        return io(&#39;http://localhost:4000&#39;, {            path: &#39;/socket.chat&#39;,            transports: [&#39;websocket&#39;]        });    }, [])    useEffect(() =&gt; {        socket.on(&#39;connect&#39;, () =&gt; {            socket.connected ? console.log(&#39;已连接...&#39;) : console.error(&#39;连接失败&#39;);        });        socket.on(&#39;disconnect&#39;, () =&gt; {            socket.disconnected ? console.log(&#39;已断开链接...&#39;) : console.error(&#39;断开失败&#39;);        });        socket.on(&#39;newMessage&#39;, ({ msg }) =&gt; {            setReceiveMessage(state =&gt; ([                ...state,                msg            ]))        });    }, [socket])    //     const sendMsg = useCallback((msg) =&gt; {        socket.emit(&#39;sendMessage&#39;, { data: msg });    }, [socket])    return &lt;div className={styles.wrap}&gt;        &lt;div className={styles.chatBox}&gt;            {receiveMessage.length &gt; 0 &amp;&amp; receiveMessage.map(item =&gt; &lt;p key={String(Date() + Math.random())}&gt;{item.data}&lt;/p&gt;)}        &lt;/div&gt;        &lt;div className={styles.chatInput}&gt;            &lt;div className={styles.chatInputLeft}&gt;&lt;/div&gt;            &lt;div className={styles.chatInputMid}&gt;                {/* 将原生 `input`改造成受控组件 */}                &lt;input type=&quot;text&quot; className={styles.inputText} value={sendMessage} onChange={(e) =&gt; { setSendMessage(e.target.value) }} placeholder=&quot;请输入...&quot; /&gt;            &lt;/div&gt;            &lt;button className={styles.chatInputRight} onClick={() =&gt; { sendMsg(sendMessage); setSendMessage(&#39;&#39;); }}&gt;发送&lt;/button&gt;        &lt;/div&gt;    &lt;/div &gt;}// style.wrap {    height: 100%;    background-color: skyblue;    display: flex;    flex-direction: column;    position: relative;    font-size: 14px;    .chatBox {        background-color: skyblue;    }    .chatInput {        width: 100%;        height: 35px;        position: absolute;        bottom: 0;        left: 0;        display: flex;        &amp;Left {            width: 50px;            height: 100%;        }        &amp;Mid {            flex: 1;            display: flex;            align-items: center;            background-color: #fff;            .inputText {                width: 100%;                height: 90%;                border: 1px solid #eee;                padding: 0px 10px;                line-height: 35px;            }        }        &amp;Right {            width: 50px;            height: 100%;            text-align: center;            line-height: 35px;            background-color: rgb(62, 139, 253);            border-radius: 10px;            color: #fff;        }    }}</code></pre><h2 id="第三步、添加断开连接功能，各设备之间同步链接数"><a href="#第三步、添加断开连接功能，各设备之间同步链接数" class="headerlink" title="第三步、添加断开连接功能，各设备之间同步链接数"></a>第三步、添加断开连接功能，各设备之间同步链接数</h2><p><strong>服务端</strong></p><pre><code>const io = require(&#39;socket.io&#39;)(4000, {    path: &#39;/socket.chat&#39;,    serveClient: true,    transports: [&#39;websocket&#39;, &#39;polling&#39;]});const connections = [];io.sockets.on(&#39;connect&#39;, function (socket) {    connections.push(socket);    io.sockets.emit(&#39;userCount&#39;, { msg: connections.length })    console.log(&#39;connected &gt;&gt;&gt; [ %s ] online, [ %s ]&#39;, connections.length, new Date())    socket.on(&#39;disconnect&#39;, function (data) {        connections.splice(connections.indexOf(socket), 1);        io.sockets.emit(&#39;userCount&#39;, { msg: connections.length});        console.log(connections.length)        console.log(&#39;disconnect &gt;&gt;&gt; [ %s ] online&#39;, connections.length);        delete socket;    })    socket.on(&#39;sendMessage&#39;, function (data) {        console.log(data)        io.sockets.emit(&#39;newMessage&#39;, { msg: data })    })})console.log(`Server running on prot ${process.env.PORT || 4000}`);</code></pre><p><strong>客户端</strong></p><pre><code>import React, { useState, useMemo, useCallback, useEffect } from &#39;react&#39;import styles from &#39;./index.module.scss&#39;import io from &#39;socket.io-client&#39;;import { Link } from &#39;react-router-dom&#39;export default props =&gt; {    const [userCount, setUserCount] = useState(0)    const [sendMessage, setSendMessage] = useState(&#39;&#39;);    const [receiveMessage, setReceiveMessage] = useState([]);    const socket = useMemo(() =&gt; {        return io(&#39;http://localhost:4000&#39;, {            path: &#39;/socket.chat&#39;,            // 默认值为 [ &#39;polling&#39; ]            transports: [&#39;websocket&#39;]        });    }, [])    useEffect(() =&gt; {        socket.on(&#39;connect&#39;, () =&gt; {            socket.connected ? console.log(&#39;已连接...&#39;) : console.error(&#39;连接失败&#39;);        });        socket.on(&#39;disconnect&#39;, () =&gt; {            socket.disconnected ? console.log(&#39;已断开链接...&#39;) : console.error(&#39;断开失败&#39;);        });        socket.on(&#39;userCount&#39;, ({ msg }) =&gt; {            console.log(&quot;%s 人在线&quot;, msg); // true            setUserCount(msg)        });        socket.on(&#39;newMessage&#39;, ({ msg }) =&gt; {            setReceiveMessage(state =&gt; ([                ...state,                msg            ]))        });    }, [socket])    // 断开链接申请    const emitDisconnect = useCallback((msg) =&gt; {        console.log(&#39;提交断开连接申请&#39;)        socket.close();    }, [socket])    const sendMsg = useCallback((msg) =&gt; {        socket.emit(&#39;sendMessage&#39;, { data: msg });    }, [socket])    return &lt;div className={styles.wrap}&gt;        &lt;div className={styles.chatBox}&gt;            &lt;Link to=&quot;/home&quot; &gt;chat&lt;/Link&gt;            &lt;div&gt;{userCount} 人在线&lt;/div&gt;            {receiveMessage.length &gt; 0 &amp;&amp; receiveMessage.map(item =&gt; &lt;p key={String(Date() + Math.random())}&gt;{item.data}&lt;/p&gt;)}        &lt;/div&gt;        &lt;button onClick={() =&gt; { emitDisconnect(&#39;wwww&#39;) }}&gt;注销&lt;/button&gt;        &lt;div className={styles.chatInput}&gt;            &lt;div className={styles.chatInputLeft}&gt;&lt;/div&gt;            &lt;div className={styles.chatInputMid}&gt;                &lt;input type=&quot;text&quot; className={styles.inputText} value={sendMessage} onChange={(e) =&gt; { setSendMessage(e.target.value) }} placeholder=&quot;请输入...&quot; /&gt;            &lt;/div&gt;            &lt;button className={styles.chatInputRight} onClick={() =&gt; { sendMsg(sendMessage); setSendMessage(&#39;&#39;); }}&gt;发送&lt;/button&gt;        &lt;/div&gt;    &lt;/div &gt;}</code></pre><p>以上三步的完成，可以基本实现一个聊天室的功能了，但是这远远不够。</p><p>接下来会增加更高级的功能，但为了文章简洁，将只会贴出关键性代码。</p><h1 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h1><ol><li>用户登陆校验</li><li>客户端分组</li></ol><h1 id="思维扩展"><a href="#思维扩展" class="headerlink" title="思维扩展"></a>思维扩展</h1><p>除了可以实现聊天室，也可以实现在线下棋对战等实时对战游戏。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>creat-react-app</title>
    <link href="/study.github.io/2019/11/20/creat-react-app/"/>
    <url>/study.github.io/2019/11/20/creat-react-app/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以此文章记录如何创建一个react app和一些常用配置，会不定期更新</p></blockquote><h1 id="1、初始化React-App"><a href="#1、初始化React-App" class="headerlink" title="1、初始化React App"></a>1、初始化React App</h1><h2 id="1-1、安装"><a href="#1-1、安装" class="headerlink" title="1.1、安装"></a>1.1、安装</h2><pre><code># 全局安装npm install -g create-react-app</code></pre><h2 id="1-2、创建一个app项目"><a href="#1-2、创建一个app项目" class="headerlink" title="1.2、创建一个app项目"></a>1.2、创建一个app项目</h2><pre><code># 构建一个my-app的项目npm init react-app my-app</code></pre><h2 id="1-3、启动编译"><a href="#1-3、启动编译" class="headerlink" title="1.3、启动编译"></a>1.3、启动编译</h2><pre><code>npm start</code></pre><h1 id="2、webpack配置"><a href="#2、webpack配置" class="headerlink" title="2、webpack配置"></a>2、webpack配置</h1><h2 id="2-1、react-app-rewired"><a href="#2-1、react-app-rewired" class="headerlink" title="2.1、react-app-rewired"></a>2.1、react-app-rewired</h2><blockquote><p>使用 react-app-rewired 添加或修改 webpack 的 配置</p></blockquote><h3 id="2-1-1、安装"><a href="#2-1-1、安装" class="headerlink" title="2.1.1、安装"></a>2.1.1、安装</h3><pre><code>npm i react-app-rewired --save-dev</code></pre><h3 id="2-1-2、修改package-json"><a href="#2-1-2、修改package-json" class="headerlink" title="2.1.2、修改package.json"></a>2.1.2、修改package.json</h3><pre><code>&quot;scripts&quot;: {    &quot;start&quot;: &quot;react-app-rewired start&quot;,    &quot;build&quot;: &quot;react-app-rewired build&quot;,    &quot;test&quot;: &quot;react-app-rewired test&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  },</code></pre><h3 id="2-1-3、新建配置文件"><a href="#2-1-3、新建配置文件" class="headerlink" title="2.1.3、新建配置文件"></a>2.1.3、新建配置文件</h3><blockquote><p>在根目录下新建config-override.js</p></blockquote><h4 id="1-配置路径"><a href="#1-配置路径" class="headerlink" title="(1) 配置路径"></a>(1) 配置路径</h4><pre><code>const path = require(&#39;path&#39;);function resolve(dir) {    return path.join(__dirname, &#39;.&#39;, dir)}module.exports = function override(config, env) {    config.resolve.alias = {        &#39;@components&#39;: resolve(&#39;src/components&#39;),        &#39;@pages&#39;: resolve(&#39;src/pages&#39;),        &#39;@util&#39;: resolve(&#39;src/util&#39;),        &#39;@config&#39;: resolve(&#39;config&#39;)    }    return config;}</code></pre><h4 id="2-配置-loader"><a href="#2-配置-loader" class="headerlink" title="(2) 配置 loader"></a>(2) 配置 loader</h4><pre><code></code></pre><h2 id="2-2、proxy代理配置"><a href="#2-2、proxy代理配置" class="headerlink" title="2.2、proxy代理配置"></a>2.2、proxy代理配置</h2><h3 id="2-2-1、安装"><a href="#2-2-1、安装" class="headerlink" title="2.2.1、安装"></a>2.2.1、安装</h3><pre><code>npm http-proxy-middleware -dev</code></pre><h3 id="2-2-2、-新建配置文件"><a href="#2-2-2、-新建配置文件" class="headerlink" title="2.2.2、 新建配置文件"></a>2.2.2、 新建配置文件</h3><pre><code>const proxy = require(&#39;http-proxy-middleware&#39;);module.exports = function (app) {    app.use(        proxy(&#39;/api&#39;, {            target: &#39;http://localhost:4000&#39;,            changeOrigin: true,            pathRewrite: {                &quot;^/api&quot;: &quot;&quot;            }        })    );    app.use(proxy(...));};</code></pre><p>注意：代理路径匹配是懒惰的，当满足正则时则停止匹配。因此，当添加多个代理配置时，要注意代理路径的冲突，如：</p><pre><code>app.use(    proxy(&#39;/api/&#39;, {        target: &#39;http://localhost:3000&#39;,    }));app.use(    proxy(&#39;/api2&#39;,{        target: &#39;http://localhost:4000&#39;,    }));</code></pre><p>当请求路径为<code>/api2/audio</code> 时，我们想代理到 4000端口，但 却被3000端口代理了，这是因为<code>/api</code>满足<code>/api2</code>,则我们在配置时应该参照如下：</p><pre><code>app.use(    proxy(&#39;/api&#39;, {        target: &#39;http://localhost:3000&#39;,    }));app.use(    proxy(&#39;/api2/&#39;,{        target: &#39;http://localhost:4000&#39;,    }));</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reack Hook</title>
    <link href="/study.github.io/2019/08/12/Reack-Hook/"/>
    <url>/study.github.io/2019/08/12/Reack-Hook/</url>
    
    <content type="html"><![CDATA[<h1 id="Reack-Hook"><a href="#Reack-Hook" class="headerlink" title="Reack Hook"></a>Reack Hook</h1><h2 id="Hook简介"><a href="#Hook简介" class="headerlink" title="Hook简介"></a>Hook简介</h2><blockquote><p>React 16.7.0开始推行Hook，到 React 16.8.0 Hook 稳定，Hooks开始被推广使用，它解决了传统使用生命周期而导致的相关代码逻辑分离、不相关代码逻辑混合在一个生命周期中、class中复杂的this指向、class不能被很好的压缩、class可能导致热重载不稳定</p></blockquote><blockquote><p>Hook为开发者提供了可以使用function创建微state，且一个state由一个对应的函数管理，还提供了专门处理副作用、实现redux、性能优化等功能，并且100%向后兼容，个人认为Hook是react未来发展的趋势，但并不意味着摒弃class。</p></blockquote><h2 id="Hook-API"><a href="#Hook-API" class="headerlink" title="Hook API"></a>Hook API</h2><h3 id="1、useState"><a href="#1、useState" class="headerlink" title="1、useState"></a>1、useState</h3><blockquote><p>useState返回一个数组，第一个值为state，第二个值为状态管理函数</p><p>值得注意的是：为了使得状态的操作函数 与其他函数区别开且和其对应的状态联系起来，在命名上有如下约定规则： set + 状态名</p><p>如有状态count，则对应状态管理函数命名为 setCount</p></blockquote><p>函数签名</p><pre><code>const [状态名, 状态管理函数] = useState(状态初始值);</code></pre><p>使用实例</p><pre><code>import React, { useState } from &#39;react&#39;;function Example() {  // 解构赋值获取useState返回的值，并给他们取名为count和setCount  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;{count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );}</code></pre><p>状态管理函的实参必须有返回值，且此返回值会赋值给对应状态。</p><p>除上述使用形式外，还可以如下使用</p><pre><code>setCount(()=&gt;{    return count+1;})</code></pre><p>对应使用场景</p><pre><code>// 在原有state的基础上改变数据const [person,setPerson] = useState({    name: &#39;王老板&#39;,    age: 18})setState( state =&gt; ({    ...person,    age: ++state.age}) )</code></pre><p><strong>踩坑记录</strong></p><ul><li><code>useState</code>中的数据务必是<code>immutable</code>数据，若两次传入同一对象则不会触发组件更新，如：</li></ul><pre><code>import React, { useState } from &#39;react&#39;export default props =&gt; {    const [list, setList] = useState([1, 5, 3, 9])    return &lt;&gt;        &lt;ul&gt;            {list.map((item, idx) =&gt; &lt;li key={String(idx)}&gt;{item}&lt;/li&gt;)}        &lt;/ul&gt;        {/* sort 不生成副本，直接返回原数组 */}        &lt;button onClick={()=&gt; {setList(list.sort((a, b) =&gt; a - b))}}&gt;sort&lt;/button&gt;        {/* slice 返回一个新的副本数组 */}        &lt;button onClick={()=&gt; {setList(list.slice().sort((a, b) =&gt; a - b))}}&gt;slice&lt;/button&gt;    &lt;/&gt;}</code></pre><p>点击sort按钮后并不会出发更新！</p><ul><li><p><code>useState</code>对应的state只要发生改变，无论组件是否使用了<code>state</code>，该组件都会发生更新；</p><p><code>useRef</code>所保存的值，只有在组件中被使用且发生改变时，组件才会更新；</p><p>可以参照两者的区别，根据不同场景来判断使用哪种方式保存数据。</p></li><li><p>useState 是将新值直接覆盖掉旧值，而不是合并</p><pre><code>const [temp,setTemp] = useState({a: 1, b: 2});setTemp({a: 2}); // temp = {a: 2}</code></pre></li></ul><h3 id="2、useEffect"><a href="#2、useEffect" class="headerlink" title="2、useEffect"></a>2、useEffect</h3><blockquote><p>使用<code>useEffect</code>来处理副作用</p></blockquote><p>函数签名</p><pre><code>//1  组件初次渲染后执行一次，依赖项每次改变时执行一次useEffect(()=&gt;{    //副作用动作},[依赖项])//2  组件初次渲染后执行一次useEffect(()=&gt;{    //副作用动作},[])//3  组件初次渲染后执行一次，组件每次更新后执行一次useEffect(()=&gt;{    //副作用动作})</code></pre><p>例子：</p><pre><code>import React, { useState, useEffect, useRef } from &#39;react&#39;export default function Example() {    const [count, setCount] = useState(0);    const [val, setVal] = useState(0);    const num = useRef(0);    useEffect(()=&gt;{        console.log(&#39;1&#39;)    },[count]);    useEffect(()=&gt;{        console.log(&#39;2&#39;)    },[]);    useEffect(()=&gt;{        console.log(&#39;3&#39;)    });    return &lt;div&gt;        &lt;button onClick={()=&gt;{setCount(count + 1)}}&gt;COUNT&lt;/button&gt;        &lt;button onClick={()=&gt;{setVal(val + 1)}}&gt;VAL&lt;/button&gt;        &lt;button onClick={()=&gt;{num.current += 1}}&gt;NUM&lt;/button&gt;    &lt;/div&gt;}//该组件初次渲染后的执行结果123//点击一次 COUNT按钮 后的执行结果13//点击一次 VAL按钮 后的执行结果3//点击一次 NUM按钮 后的执行结果</code></pre><h4 id="（1）处理无需清除的effect"><a href="#（1）处理无需清除的effect" class="headerlink" title="（1）处理无需清除的effect"></a>（1）处理无需清除的effect</h4><blockquote><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p></blockquote><p>使用实例</p><p> 需求：监听url的变化来发送网络请求，保存返回结果</p><pre><code>import React, { useState, useEffect } from &#39;react&#39;import ajax from &#39;@utils/ajax&#39;export default function Example({ location }) {    const [data, setData] = useState({});    useEffect(()=&gt;{        getData();    },[location]);    const getData = () =&gt; {        ajax.post().then(res =&gt; {            setData(res);        })    }    return &lt;div&gt;{data}&lt;/div&gt;}</code></pre><p>当location发生变化时，useEffect中函数就会自动执行</p><h4 id="（2）处理需要清除的effect"><a href="#（2）处理需要清除的effect" class="headerlink" title="（2）处理需要清除的effect"></a>（2）处理需要清除的effect</h4><blockquote><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p></blockquote><p>在useEffect中可选的返回一个清除函数，该清除函数会在组件卸载时自动执行，以达到清除effect的目的</p><p>函数签名</p><pre><code>//useEffect的第二个参数不影响 ‘清除effect’ 动作useEffect(()=&gt;{    //副作用动作    return () =&gt; {        //清除effect    }})</code></pre><p>使用示例</p><pre><code>useEffect(() =&gt; {    function handleStatusChange(status) {        setIsOnline(status.isOnline);    }    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    return () =&gt; {        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    };});</code></pre><p><strong>踩坑记录</strong></p><ul><li>在<code>useEffect</code>和<code>useLayoutEffect</code>中使用<code>async</code>和<code>await</code>语法时，要注意分离<code>async</code>默认返回的<code>promise</code>与<code>useEffect</code>和<code>useLayoutEffect</code>的<code>cleanup</code>函数，不要将<code>async</code>的返回函数返给<code>useEffect</code>。使用<code>IIFE</code>解决</li></ul><pre><code>useEffect(() =&gt; {    (async () =&gt; {        await fetchSomething();    })();}, []);</code></pre><h3 id="3、useMemo与useCallback"><a href="#3、useMemo与useCallback" class="headerlink" title="3、useMemo与useCallback"></a>3、useMemo与useCallback</h3><blockquote><ol><li>当组件state被修改时就会触发组件的重新渲染，无论前后state是否一致</li><li>父组件更新，子组件会自动更新</li><li>组件更新时，会卸载所有function，并重新创建function</li></ol></blockquote><p>这就出现了性能问题，当更新前后状态一致时，是无需更新的。</p><p>在之前使用生命周期时，我们通常的解决方案是调用生命周期钩子函数<code>shouldComponentUpdate</code>来判断新老props、states是否发生变化来决定当前组件是否需要更新（原理可参见 React 的 Diff）</p><p>Hooks出现后，我们可以直接使用function的形式来创建组件状态，但function自身并没有<code>shouldComponentUpdate</code>判断前后状态的能力。并且，每当函数组件被调用都会执行内部的所有的逻辑，其性能损耗显而易见。</p><p><strong>useMemo 与 useCallback 的区别与联系</strong></p><p>实际上<code>useCallback</code>是基于<code>useMemo</code>实现的</p><pre><code>function useCallback(callback, args) {    return useMemo(() =&gt; callback, args);}</code></pre><ol><li><code>useMemo</code>是返回<code>callback</code>执行后的结果</li><li><code>useCallback</code> 是直接返回被<code>useMemo</code>修饰的<code>callback</code>函数</li></ol><h4 id="（1）useMemo"><a href="#（1）useMemo" class="headerlink" title="（1）useMemo"></a>（1）useMemo</h4><pre><code>import React from &#39;react&#39;;export default function WithoutMemo() {    const [count, setCount] = useState(1);    const [val, setValue] = useState(&#39;&#39;);    function expensive() {        console.log(&#39;compute&#39;);        let sum = 0;        for (let i = 0; i &lt; count * 100; i++) {            sum += i;        }        return sum;    }    return &lt;div&gt;        &lt;h4&gt;{count}-{val}-{expensive()}&lt;/h4&gt;        &lt;div&gt;            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+c1&lt;/button&gt;            &lt;input value={val} onChange={event =&gt; setValue(event.target.value)}/&gt;        &lt;/div&gt;    &lt;/div&gt;;}</code></pre><p>在这个组件中含有一个计算量很大的函数<code>expensive</code>，当我们修改 <code>conut</code> <code>val</code>任意一个状态时，<code>expensive</code>都会被触发，尽管<code>val</code>与<code>expensive</code>的计算毫无关系。</p><p>使用<code>useMemo</code>来解决该问题</p><pre><code>import React from &#39;react&#39;;export default function WithoutMemo() {    const [count, setCount] = useState(1);    const [val, setValue] = useState(&#39;&#39;);    //使用useMemo    const expensive = useMemo(() {        console.log(&#39;compute&#39;);        let sum = 0;        for (let i = 0; i &lt; count * 100; i++) {            sum += i;        }        return sum;    },[count])    return &lt;div&gt;        &lt;h4&gt;{count}-{val}-{expensive}&lt;/h4&gt;        &lt;div&gt;            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+c1&lt;/button&gt;            &lt;input value={val} onChange={event =&gt; setValue(event.target.value)}/&gt;        &lt;/div&gt;    &lt;/div&gt;;}</code></pre><p>我们可知，<code>expensive</code>的计算只与count相关，则可使用<code>useMome</code>添加依赖值<code>count</code></p><p>当且仅当count发生有效改变时才会执行相应函数，并返回缓存值给<code>expensive</code></p><h4 id="（2）useCallback"><a href="#（2）useCallback" class="headerlink" title="（2）useCallback"></a>（2）useCallback</h4><p><code>useCallback</code>的特点、作用和用法与<code>useMemo</code>类似，但是他返回一个缓存的函数。</p><p>除了利用<code>useMemo</code>和<code>useCallback</code>的缓存特性以达到 ”减少某函数不必要的计算“ 外，还可以利用这特性实现 “避免子组件不必要的更新”，这里以<code>useCallback</code>为例</p><pre><code>import React, { useState, useCallback, useEffect } from &#39;react&#39;;function Parent() {    const [count, setCount] = useState(1);    const [val, setVal] = useState(&#39;&#39;);    const callback = useCallback(() =&gt; {        return count;    }, [count]);    return &lt;div&gt;        &lt;h4&gt;{count}- {val}&lt;/h4&gt;        &lt;Child callback={callback}/&gt;    &lt;/div&gt;;}function Child({ callback }) {    const [count, setCount] = useState(() =&gt; callback());    useEffect(() =&gt; {        setCount(callback());    }, [callback]);    return &lt;div&gt;        {count}    &lt;/div&gt;}</code></pre><p>例子中的Child组件中 是依赖于父组件传递来的callback来创建的函数，一旦父组件中的callback发生改变则Child组件就会发生更新，若父组件中的callback不使用useCallback来封装，则父组件中的任意变量发生改变都会导致callback的变化进而导致子组件不必要的更新。</p><p>此外，所有依赖state或props来创建的函数，需要用到缓存函数的地方都是useCallback的使用场景。</p><p><strong>踩坑记录</strong></p><p>使用<code>lodash</code>中的<code>debounced</code></p><pre><code>import React, { useState } from &#39;react&#39;import { debounce } from &#39;lodash&#39;const Example = () =&gt; {    const [value, setValue] = useState(&#39;&#39;);    const _debounce = debounce((value)=&gt;{        console.log(value)    },3000);    const _onChange = (e) =&gt; {        let value = e.target.value;        setValue(value)        _debounce(value);    }    return &lt;div&gt;        &lt;input type=&quot;text&quot; onChange={_onChange} value={value} /&gt;    &lt;/div&gt;}export default Example</code></pre><p>每当<code>onChange</code>被触发一次，都会执行<code>setValue</code>，进而导致刷新组件，使得每次都生成新的<code>debounce</code>，这就失去了函数防抖的效果。而此处的矛盾点就是“函数刷新导致生成了新的<code>debounce</code>”，这里就可以使用<code>useCallback</code>来解决。</p><pre><code>import React, { useState, useCallback } from &#39;react&#39;import { debounce } from &#39;lodash&#39;const Example = () =&gt; {    const [value, setValue] = useState(&#39;&#39;);    const _debounce = useCallback(debounce((value)=&gt;{        console.log(value);    },3000),[]);    const _onChange = (e) =&gt; {        let value = e.target.value;        setValue(value);        _debounce(value);    }    return &lt;div&gt;        &lt;input type=&quot;text&quot; onChange={_onChange} value={value} /&gt;    &lt;/div&gt;}export default Example</code></pre><p>这样每次组件刷新后执行的debounce都是同一个函数，进而使得debounce的防抖效果生效。</p><h3 id="4、useContext与useReducer"><a href="#4、useContext与useReducer" class="headerlink" title="4、useContext与useReducer"></a>4、useContext与useReducer</h3><h4 id="（1）useContext"><a href="#（1）useContext" class="headerlink" title="（1）useContext"></a>（1）useContext</h4><blockquote><p>实现同一子树下所有节点可统一共享子树根节点的数据</p></blockquote><p>函数签名</p><pre><code>const value = useContext(MyContext);</code></pre><blockquote><p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 `` 的 <code>value</code> prop 决定。</p><p>当组件上层最近的 `` 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。</p><p>别忘记 <code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p><ul><li><strong>正确：</strong> <code>useContext(MyContext)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li></ul><p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。</p></blockquote><p>使用实例：</p><pre><code>import React, { useContext } from &#39;react&#39;//创建Context对象，并附默认值 {count: 1}const MyContext = React.createContext({ count: 1 })const [count, setState] = useState(1)export default function Example() {    const Son = () =&gt; {        return &lt;div&gt;            &lt;Grandson&gt;&lt;/Grandson&gt;        &lt;/div&gt;    }    const Grandson = () =&gt; {        //使用useContext获取Context对象        const obj = useContext(MyContext);        return &lt;div&gt;            Grandson---{obj.count}        &lt;/div&gt;    }    return &lt;MyContext.Provider value={{ count: count }}&gt;        &lt;button onClick={() =&gt; { setState(count + 1) }}&gt;ADD&lt;/button&gt;        &lt;Son&gt;&lt;/Son&gt;    &lt;/MyContext.Provider&gt;}</code></pre><p>当点击按钮改变count时，所有消费者组件都会随之发生更新，这也就达到了跨层级组件直接共享数据的目的。</p><h4 id="（2）useReducer"><a href="#（2）useReducer" class="headerlink" title="（2）useReducer"></a>（2）useReducer</h4><p>函数签名</p><pre><code>// reducer就是平时redux那种reducer函数// initialState 初始化的state状态// init 一个函数用于惰性计算state初始值const [state, dispatch] = useReducer(reducer, initialArg, init);</code></pre><blockquote><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（统一管理数据，并对<code>action</code>加以限制）</p><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p></blockquote><p><code>initialArg</code>作为<code>state</code>的初始值，若存在<code>init</code>,则<code>init</code>会将<code>initalArg</code>处理后的值作为<code>state</code>的初始值</p><pre><code>reducer`对应于`dispatch`,使用dispatch所传入的实参对应于`reducer`的`action</code></pre><p>使用实例</p><pre><code>import React, { useReducer } from &#39;react&#39;const initialState = 0;const init = (initialCount) =&gt; {    return { count: initialCount }}function reducer(state, action) {    switch (action.type) {        case &#39;increment&#39;:            return { count: state.count + 1 };        case &#39;decrement&#39;:            return { count: state.count - 1 };        case &#39;RESET&#39;:            return init(action.payload)        default:            throw new Error();    }}export default props =&gt; {    const [state, dispatch] = useReducer(reducer, initialState, init);    return &lt;div&gt;        Count: {state.count}        &lt;br /&gt;        &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;SUB&lt;/button&gt;        &lt;br /&gt;        &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;ADD&lt;/button&gt;        &lt;br /&gt;        &lt;button onClick={() =&gt; dispatch({ type: &#39;RESET&#39;, payload: initialState })}&gt;RESET&lt;/button&gt;    &lt;/div&gt;}</code></pre><h4 id="（3）useContext与useReducer结合使用"><a href="#（3）useContext与useReducer结合使用" class="headerlink" title="（3）useContext与useReducer结合使用"></a>（3）useContext与useReducer结合使用</h4><blockquote><p>结合使用useContext和useReducer以实现共享数据的统一管理和共享数据安全性保证</p></blockquote><p>使用实例</p><pre><code>import React, { useContext, useReducer } from &#39;react&#39;export default props =&gt; {    const MyContext = React.createContext({ count: 1 });    const init = (initalCount) =&gt; {        return { count: initalCount }    }    function reducer(state, action) {        switch (action.type) {            case &#39;increment&#39;:                return { count: state.count + 1 };            case &#39;decrement&#39;:                return { count: state.count - 1 };            case &#39;RESET&#39;:                return init(action.payload)            default:                throw new Error();        }    }    const initialCount = 0;    const [state, dispatch] = useReducer(reducer, initialCount, init);    const Son1 = () =&gt; {        return &lt;Grandson1&gt;&lt;/Grandson1&gt;    }    const Son2 = () =&gt; {        const obj = useContext(MyContext);        return &lt;div&gt;            Son2---{obj.count}        &lt;/div&gt;    }    const Grandson1 = () =&gt; {        const obj = useContext(MyContext);        return &lt;div&gt;            Grandson1---{obj.count}        &lt;/div&gt;    }    return &lt;MyContext.Provider value={{ count: state.count }}&gt;        &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;SUB&lt;/button&gt;        &lt;br /&gt;        &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;ADD&lt;/button&gt;        &lt;br /&gt;        &lt;button onClick={() =&gt; dispatch({ type: &#39;RESET&#39;, payload: initialCount })}&gt;RESET&lt;/button&gt;        &lt;Son1&gt;&lt;/Son1&gt;        &lt;Son2&gt;&lt;/Son2&gt;    &lt;/MyContext.Provider&gt;}</code></pre><p>我们现在已经完成了useContext与useReducer的配合使用，我们现在将代码抽离出来，使其可以在任何组件中都可以快速调用</p><p>目录结构</p><pre><code>-example    -components        -Son            -index.js        -Grandson            -index.js    -store        -index.js        -reducer.js    -index.js</code></pre><p>使用实例</p><pre><code>// example\store\index.jsimport React, { useReducer, useContext } from &#39;react&#39;import { defaultState, reducer, init } from &#39;./reducer&#39;const MyContext = React.createContext();const Context = props =&gt; {    //将useReducer的返回值 [state,dispatch] 作为参数    const contextValue = useReducer(reducer, defaultState, init);    return &lt;MyContext.Provider value={contextValue}&gt;        {props.children}    &lt;/MyContext.Provider&gt;}const useMyContext = () =&gt; {    return useContext(MyContext)}export {    Context,    useMyContext}// example\store\reducer.jsexport const defaultState = {    count: 0}export const init = (initalState) =&gt; {    return {         ...initalState,        count: initalState.count     }}export const reducer = (state, action) =&gt; {    switch (action.type) {        case &#39;increment&#39;:            return {                ...state,                count: state.count + 1            };        case &#39;decrement&#39;:            return {                ...state,                count: state.count - 1            };        case &#39;RESET&#39;:            return init(defaultState)        default:            throw new Error();    }}// example\components\Grandson\index.jsimport React from &#39;react&#39;import { useMyContext } from &#39;../../store&#39;export default props =&gt; {    const [state, dispatch] = useMyContext();    return &lt;div&gt;        Grandson --- {state.count}        &lt;button onClick={() =&gt; { dispatch({ type: &#39;increment&#39; }) }}&gt;Grandson ADD&lt;/button&gt;        &lt;button onClick={() =&gt; { dispatch({ type: &#39;decrement&#39; }) }}&gt;Grandson SUB&lt;/button&gt;        &lt;button onClick={() =&gt; { dispatch({ type: &#39;RESET&#39; }) }}&gt;Grandson RESET&lt;/button&gt;    &lt;/div&gt;}// example\components\Son\index.jsimport React from &#39;react&#39;import Grandson from &#39;../Grandson&#39;export default props =&gt; {    return &lt;Grandson&gt;&lt;/Grandson&gt;}//example\index.jsimport React from &#39;react&#39;import Son from &#39;./components/Son&#39;import { Context } from &#39;./store&#39;export default props =&gt; {    return &lt;Context&gt;        &lt;Son&gt;&lt;/Son&gt;    &lt;/Context&gt;}</code></pre><h3 id="5、useRef"><a href="#5、useRef" class="headerlink" title="5、useRef"></a>5、useRef</h3><p>函数签名</p><pre><code>const refContainer = useRef(initialValue);</code></pre><blockquote><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p></blockquote><p>使用实例</p><pre><code>import React from &#39;react&#39;export default props =&gt; {    const refContainer = useRef(null);    return &lt;div ref={refContainer}&gt;&lt;/div&gt;}</code></pre><p>除此之外，我们可以使子组件接受父组件的ref，让父组件有控制组件的能力，这里要借助<code>forwardRef</code></p><p>使用实例</p><pre><code>// fatherimport React, { useRef } from &#39;react&#39;import Son from &#39;./components/Son&#39;export default props =&gt; {    const refContainer = useRef(null);    const changeInput = () =&gt; {        refContainer.current.value = &#39;啊，我被改了！&#39;    }    return &lt;div &gt;        &lt;button onClick={changeInput}&gt;changeInput&lt;/button&gt;        &lt;Son ref={refContainer}&gt;&lt;/Son&gt;    &lt;/div&gt;}// Sonimport React, { forwardRef } from &#39;react&#39;const Son = (props,ref) =&gt; {    return &lt;div &gt;        &lt;input ref={ref}&gt;&lt;/input&gt;    &lt;/div&gt;}export default forwardRef(Son)</code></pre><p><strong>useRef 声明常量以保存可变值</strong></p><blockquote><p>除了使用useRef绑定DOM，它另一个重要作用就是声明一个常量保存可变值，绕开React的Capture Value特性</p><p>保存常量这一功能实际上是基于useMemo实现的</p><pre><code>&gt; function useRef (initialValue) {&gt;    return useMemo (() =&gt; ({ current : initialValue }), []);&gt; }&gt;</code></pre></blockquote><blockquote><p>可见 就是初始化的时候创建一个<code>{current:initialValue}</code>，不依赖任何数据，需要手动赋值修改</p></blockquote><p>使用实例</p><pre><code>import React, { useRef } from &#39;react&#39;export default props =&gt; {    const count = useRef(0);    const add = () =&gt; {        count.current += 1;    }    return &lt;div &gt;        &lt;h1&gt;{count.current}&lt;/h1&gt;        &lt;button onClick={add}&gt;ADD&lt;/button&gt;    &lt;/div&gt;}</code></pre><p><strong>踩坑记录</strong></p><ul><li>注意与useState的区别与联系</li></ul><h3 id="6、useImperativeHandle"><a href="#6、useImperativeHandle" class="headerlink" title="6、useImperativeHandle"></a>6、useImperativeHandle</h3><blockquote><p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用</p></blockquote><p>使用实例</p><pre><code>//fatherimport React, { useRef } from &#39;react&#39;import Son from &#39;./components/Son&#39;export default props =&gt; {    const refContainer = useRef(null);    const changeInput = () =&gt; {        refContainer.current.focus()        // console.log(refContainer)    }    return &lt;div &gt;        &lt;button onClick={changeInput}&gt;changeInput&lt;/button&gt;        &lt;Son ref={refContainer}&gt;&lt;/Son&gt;    &lt;/div&gt;}// Sonimport React, { useRef, forwardRef, useImperativeHandle } from &#39;react&#39;function Son(props, ref) {    //新建一个ref  将此ref绑定在本组建内的input上    const inputRef = useRef();    //将 使得本组件input获取焦点的方法赋给父组件传递来的ref上     useImperativeHandle(ref, () =&gt; ({        focus: () =&gt; {            inputRef.current.focus();        }    }));    return &lt;input ref={inputRef} /&gt;;}export default forwardRef(Son);</code></pre><h3 id="7、useLayoutEffect"><a href="#7、useLayoutEffect" class="headerlink" title="7、useLayoutEffect"></a>7、useLayoutEffect</h3><pre><code>useLayoutEffect( () =&gt; { }, [ 依赖项 ] );</code></pre><blockquote><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p><p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p></blockquote><h3 id="8、useDebugValue"><a href="#8、useDebugValue" class="headerlink" title="8、useDebugValue"></a>8、useDebugValue</h3><pre><code>useDebugValue(value)</code></pre><blockquote><p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p><pre><code>&gt; function useFriendStatus(friendID) {&gt;   const [isOnline, setIsOnline] = useState(null);&gt; &gt;   // ...&gt; &gt;   // 在开发者工具中的这个 Hook 旁边显示标签&gt;   // e.g. &quot;FriendStatus: Online&quot;&gt;   useDebugValue(isOnline ? &#39;Online&#39; : &#39;Offline&#39;);&gt; &gt;   return isOnline;&gt; }&gt;</code></pre></blockquote><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><blockquote><p>在自定义函数中封装原有的Hook</p><p>约定该函数的名称为 <code>use</code>开头</p></blockquote><p>官网案例</p><p>由于<code>isOnline</code>的值是监听网络的结果决定的，则只需要暴露<code>state</code>即可</p><pre><code>import React, { useState, useEffect } from &#39;react&#39;;function useFriendStatus(friendID) {  const [isOnline, setIsOnline] = useState(null);  useEffect(() =&gt; {    function handleStatusChange(status) {      setIsOnline(status.isOnline);    }    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);    return () =&gt; {      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);    };  });  return isOnline;}</code></pre><p>我的案例</p><p>当自定义一个Hook，和普通Hook一样使用时，也可以将state对应的操作函数暴露出来</p><pre><code>import React, { useState } from &#39;react&#39;//自定义Hookexport default function useFriendStatus(value) {    const [isOnline, setIsOnline] = useState(value || false);    return [isOnline, setIsOnline];}</code></pre><p>使用</p><pre><code>import React from &#39;react&#39;import { useFriendStatus } from &#39;./hooks&#39;;export default props =&gt; {    const [online, setOnline] = useFriendStatus(false);    return &lt;div&gt;        {online ? &#39;true&#39; : &#39;false&#39;}        &lt;button onClick={() =&gt; { setOnline(!online) }}&gt;SWITCH&lt;/button&gt;    &lt;/div&gt;}</code></pre><h2 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h2><h3 id="1、只在组件顶层中使用Hook"><a href="#1、只在组件顶层中使用Hook" class="headerlink" title="1、只在组件顶层中使用Hook"></a>1、只在组件顶层中使用Hook</h3><blockquote><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p></blockquote><pre><code>import React, { useState } from &#39;react&#39;function Example(props) {    const [count, setCount] = useState(0); //Yes    if(props.id){        // const [count, setCount] = useState(0); //No    }       const fn = () =&gt; {        // const [count, setCount] = useState(0); //No    }    return &lt;div&gt;&lt;/div&gt;}</code></pre><h3 id="2、只在React-函数中调用Hook"><a href="#2、只在React-函数中调用Hook" class="headerlink" title="2、只在React 函数中调用Hook"></a>2、只在React 函数中调用Hook</h3><blockquote><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p></blockquote><h3 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h3><ol><li>Hook在函数组件中使用（这里不称为 无状态组件），在class组件中是不起作用的</li><li>所有的Hook都是在DOM更新之后执行的</li></ol><h2 id="经验笔记"><a href="#经验笔记" class="headerlink" title="经验笔记"></a>经验笔记</h2><ol><li><p><strong>useState</strong>将函数入参给useState时，该函数是在DOM渲染前执行的</p><pre><code>const [value,setValue] = useState(()=&gt;{    console.log(&#39;笨鸟先飞&#39;);    return 0})</code></pre></li><li><p><strong>useEffect</strong>是在DOM渲染结束后执行的</p></li><li><p><strong>useLayoutEffect</strong>与DOM渲染同步进行，在此函数中获取DOM，会导致偶发性报错</p></li><li><p>组件不要声明在另一个组件内</p><pre><code>// 错误const FatherComponent = (props) =&gt; {    const SonComponent = () =&gt; { return &lt;div&gt;&lt;/div&gt;}    return &lt;div&gt;        &lt;SonComponent&gt;&lt;/SonComponent&gt;    &lt;/div&gt;}// 正确const SonComponent = () =&gt; { return &lt;div&gt;&lt;/div&gt;}const FatherComponent = (props) =&gt; {    return &lt;div&gt;        &lt;SonComponent&gt;&lt;/SonComponent&gt;    &lt;/div&gt;}</code></pre></li></ol><h2 id="参照文章："><a href="#参照文章：" class="headerlink" title="参照文章："></a>参照文章：</h2><ol><li><a href="https://react-1251415695.cos-website.ap-chengdu.myqcloud.com/docs/getting-started.html" target="_blank" rel="noopener">React官方文档</a></li><li><a href="https://blog.csdn.net/sinat_17775997/article/details/94453167" target="_blank" rel="noopener">useMemo与useCallback使用指南</a></li><li><a href="https://blog.csdn.net/gtLBTNq9mr3/article/details/93984397" target="_blank" rel="noopener">useReducerde使用和原理</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用GitLab</title>
    <link href="/study.github.io/2019/08/02/%E4%BD%BF%E7%94%A8GitLab/"/>
    <url>/study.github.io/2019/08/02/%E4%BD%BF%E7%94%A8GitLab/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>关于Git的相关内容请参见 <a href="https://howlcn1997.github.io/2019/09/20/Git/" target="_blank" rel="noopener">Git</a></p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><blockquote><p>GitLab 是一个用于仓库管理系统的开源项目，使用<a href="https://baike.baidu.com/item/Git" target="_blank" rel="noopener">Git</a>作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面</p><p><strong>GitLab</strong>是由GitLabInc.开发，使用<a href="https://baike.baidu.com/item/MIT许可证" target="_blank" rel="noopener">MIT许可证</a>的基于<a href="https://baike.baidu.com/item/网络" target="_blank" rel="noopener">网络</a>的<a href="https://baike.baidu.com/item/Git" target="_blank" rel="noopener">Git</a><a href="https://baike.baidu.com/item/仓库" target="_blank" rel="noopener">仓库</a>管理工具，且具有<a href="https://baike.baidu.com/item/wiki" target="_blank" rel="noopener">wiki</a>和issue跟踪功能。使用<a href="https://baike.baidu.com/item/Git" target="_blank" rel="noopener">Git</a>作为代码管理工具，并在此基础上搭建起来的web服务。</p><p>GitLab由乌克兰程序员DmitriyZaporozhets和ValerySizov开发，它使用<a href="https://baike.baidu.com/item/Ruby语言" target="_blank" rel="noopener">Ruby语言</a>写成。后来，一些部分用<a href="https://baike.baidu.com/item/Go语言" target="_blank" rel="noopener">Go语言</a>重写。截止2018年5月，该公司约有290名团队成员，以及2000多名开源贡献者。GitLab被IBM，Sony，JülichResearchCenter，NASA，Alibaba，Invincea，O’ReillyMedia，Leibniz-Rechenzentrum(LRZ)，CERN，SpaceX等组织使用。</p></blockquote><h2 id="注册GitLab账户"><a href="#注册GitLab账户" class="headerlink" title="注册GitLab账户"></a>注册GitLab账户</h2><p><a href="https://git.lug.ustc.edu.cn/users/sign_in" target="_blank" rel="noopener">https://git.lug.ustc.edu.cn/users/sign_in</a></p><p><img src="https://howlcn1997.github.io/2019/09/27/Git%E5%92%8CGitlab/Snipaste_2019-09-26_14-59-06.png" srcset="/study.github.io/img/loading.gif" alt="Snipaste_2019-09-26_14-59-06"></p><ol><li>方式一：科学上网后输入相关信息，傻瓜式注册</li><li>方式二：使用GitHub账户关联注册（推荐）</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>简述Js原型与原型链</title>
    <link href="/study.github.io/2019/07/26/%E7%AE%80%E8%BF%B0Js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/study.github.io/2019/07/26/%E7%AE%80%E8%BF%B0Js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="简述Js中的原型与原型链"><a href="#简述Js中的原型与原型链" class="headerlink" title="简述Js中的原型与原型链"></a>简述Js中的原型与原型链</h1><h2 id="1、原型"><a href="#1、原型" class="headerlink" title="1、原型"></a>1、原型</h2><p> Javascript是基于对象的编程语言，他其中也含有部分封装、继承的概念，而原型概念便是基于继承的。</p><p> 函数的原型类似于面向对象语言中子类的父类，而函数本身类似于子类。函数继承了函数原型中的属性和方法，即函数本身可以调用它原型中的属性和方法。</p><p> 知识点：若有函数Person，则它的函数原型为Person.prototype，函数原型本身是个对象。</p><pre><code>function Person (name) {  this.name = name;}Person.prototype.type = &#39;human&#39;Person.prototype.sayName = function () {  console.log(this.name + &#39;说话了&#39;)}//此时我们用Person构造函数构造了一个p对象var p = new Person(&#39;小王&#39;);//我们打印p.nameconsole.log(p.name); //结果是&#39;小王&#39;，因为Preson函数中已经预置了name属性并且接受了new对象时传入的&#39;小王&#39;，结果勿容置疑//我们再打印p.type 调用p.sayName()  按常理说Preson构造函数中是不存在type属性和sayName方法，若调用应该会报错console.log(p.type); //结果  humanp.sayName(); // 结果  小王说话了//结果和我们预想的不同，这是为什么呢?//因为Person继承了它原型Person.prototype中的信息，当调用p.type时，会优先在Person类中找该属性，若找到了则直接使用，若没找到则在他的原型中找并使用。因为我们设置了Person原型的type属性的，则p可以直接使用</code></pre><p>在上面的例子中涉及到了 构造函数、对象和函数原型，接下来给出三者之间的关系图；</p><h2 id="2、构造函数、实例、原型三者之间的关系"><a href="#2、构造函数、实例、原型三者之间的关系" class="headerlink" title="2、构造函数、实例、原型三者之间的关系"></a>2、构造函数、实例、原型三者之间的关系</h2><p><img src="https://howlcn1997.github.io/2019/09/27/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" srcset="/study.github.io/img/loading.gif" alt="三者关系"></p><p>由图中我们可以很直观的看到三者之间的关系。</p><p>p对象由Person构造函数构造</p><p>p对象通过<strong>proto</strong>属性访问到Person对象原型</p><p>Person对象原型通过constructor访问Person构造函数</p><p>Person函数通过prototype属性访问到Person原型对象</p><p>注意：对象是通过<strong>proto</strong>属性访问对象原型，函数是通过prototype访问对象原型，但两者访问到的对象原型是同一个</p><p>验证：</p><pre><code>console.log(p.__proto__ == Person.prototype); //结果为 true</code></pre><p>constructor的作用：可以使得对象访问到对应的构造函数</p><pre><code>function Person(){}var p = new Person();console.log(p.constructor);// 打印  function Person()</code></pre><p>知道以上的知识之后，我们还要了解，其实Person的原型也有原型，即存在Person.prototype.prototype，并且它是Person.prototype的原型，可以用图来直观了解这其中的关系，这便是一个简单的原型链。</p><h2 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h2><p><img src="https://howlcn1997.github.io/2019/09/27/%E7%AE%80%E8%BF%B0Js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" srcset="/study.github.io/img/loading.gif" alt="原型链"></p><h2 id="4、原型链中的搜索规则"><a href="#4、原型链中的搜索规则" class="headerlink" title="4、原型链中的搜索规则"></a>4、原型链中的搜索规则</h2><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p><p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性</p><ul><li>搜索首先从对象实例本身开始</li><li>如果在实例中找到了具有给定名字的属性，则返回该属性的值</li><li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性</li><li>如果在原型对象中找到了这个属性，则返回该属性的值</li></ul><p>也就是说，在我们调用 <code>p.sayName()</code> 的时候，会先后执行两次搜索：</p><ul><li>首先，解析器会问：“实例 p 有 sayName 属性吗？”答：“没有。</li><li>”然后，它继续搜索，再问：“ p 的原型有 sayName 属性吗？”答：“有。</li><li>”于是，它就读取那个保存在原型对象中的函数。</li></ul><p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p><p>总结：</p><ul><li>先在自己身上找，找到即返回</li><li>自己身上找不到，则沿着原型链向上查找，找到即返回</li><li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中冒泡机制</title>
    <link href="/study.github.io/2019/07/13/JavaScript%E4%B8%AD%E5%86%92%E6%B3%A1%E6%9C%BA%E5%88%B6/"/>
    <url>/study.github.io/2019/07/13/JavaScript%E4%B8%AD%E5%86%92%E6%B3%A1%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><h2 id="一、函数声明的实质"><a href="#一、函数声明的实质" class="headerlink" title="一、函数声明的实质"></a>一、函数声明的实质</h2><p>我们平时大量使用Function，但是真的懂Function吗？</p><p>声明一个函数的时所使用的代码</p><pre><code>function fn(num1,num2){    return num1+num2;}</code></pre><p>其实它的实质是使用了Function的构造函数</p><pre><code>//Function(参数1，参数2，...，函数体);var fn = new Function(&#39;num1&#39;,&#39;num2&#39;,&#39;return num1+num2&#39;);</code></pre><p>这两种声明方式是等同的，但从第二种写法上，我们可以很清晰的看出fn函数是由Function构造出来的。</p><h2 id="二、JavaScript对象"><a href="#二、JavaScript对象" class="headerlink" title="二、JavaScript对象"></a>二、JavaScript对象</h2><p>我们先来看一个例子</p><pre><code>console.log(typeof Object);console.log(typeof Function);</code></pre><p>打印结果都是Function，这是为什么了，为什么Object也是Function？</p><p>那是因为<strong>JS中所有的函数都是Function的实例</strong>，Object也是由构造函数构建的，那么Object的类型也是Function。</p><p>值得注意的是：<strong>Function自身能够生成自身，即Function的原型就是Function。</strong>即</p><p>我们用一张图来解释这其中的关系</p><p><img src="https://howlcn1997.github.io/2019/09/27/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B.png" srcset="/study.github.io/img/loading.gif" alt="函数原型"></p><p>结合上一章所介绍的原型链，综合给出一张关系图</p><p><img src="https://howlcn1997.github.io/2019/09/27/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%8A%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B.png" srcset="/study.github.io/img/loading.gif" alt="原型链加函数原型"></p><p>[声明]：本篇文章中部分引用 <a href="https://blog.csdn.net/swl979623074/article/details/78836767" target="_blank" rel="noopener">从Function说原型</a> 的文章。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数原型</title>
    <link href="/study.github.io/2019/06/30/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/"/>
    <url>/study.github.io/2019/06/30/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><h2 id="一、函数声明的实质"><a href="#一、函数声明的实质" class="headerlink" title="一、函数声明的实质"></a>一、函数声明的实质</h2><p>我们平时大量使用Function，但是真的懂Function吗？</p><p>声明一个函数的时所使用的代码</p><pre><code>function fn(num1,num2){    return num1+num2;}</code></pre><p>其实它的实质是使用了Function的构造函数</p><pre><code>//Function(参数1，参数2，...，函数体);var fn = new Function(&#39;num1&#39;,&#39;num2&#39;,&#39;return num1+num2&#39;);</code></pre><p>这两种声明方式是等同的，但从第二种写法上，我们可以很清晰的看出fn函数是由Function构造出来的。</p><h2 id="二、JavaScript对象"><a href="#二、JavaScript对象" class="headerlink" title="二、JavaScript对象"></a>二、JavaScript对象</h2><p>我们先来看一个例子</p><pre><code>console.log(typeof Object);console.log(typeof Function);</code></pre><p>打印结果都是Function，这是为什么了，为什么Object也是Function？</p><p>那是因为<strong>JS中所有的函数都是Function的实例</strong>，Object也是由构造函数构建的，那么Object的类型也是Function。</p><p>值得注意的是：<strong>Function自身能够生成自身，即Function的原型就是Function。</strong>即</p><p>我们用一张图来解释这其中的关系</p><p><img src="https://howlcn1997.github.io/2019/09/27/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B.png" srcset="/study.github.io/img/loading.gif" alt="函数原型"></p><p>结合上一章所介绍的原型链，综合给出一张关系图</p><p><img src="https://howlcn1997.github.io/2019/09/27/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%8A%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B.png" srcset="/study.github.io/img/loading.gif" alt="原型链加函数原型"></p><p>[声明]：本篇文章中部分引用 <a href="https://blog.csdn.net/swl979623074/article/details/78836767" target="_blank" rel="noopener">从Function说原型</a> 的文章。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于input禁用输入法的问题</title>
    <link href="/study.github.io/2019/04/06/%E5%85%B3%E4%BA%8Einput%E7%A6%81%E7%94%A8%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2019/04/06/%E5%85%B3%E4%BA%8Einput%E7%A6%81%E7%94%A8%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="关于input禁用中文输入法的问题"><a href="#关于input禁用中文输入法的问题" class="headerlink" title="关于input禁用中文输入法的问题"></a>关于input禁用中文输入法的问题</h1><p>完整代码：</p><pre><code>&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;    &lt;!-- &lt;input type=&quot;tel&quot;&gt; --&gt;    &lt;script&gt;        var input = document.getElementById(&#39;input&#39;);        input.onkeydown = function(e){ //检测键入的键的ASCLL码值            var event = e || window.event;            if(event.keyCode != 8 &amp;&amp; (event.keyCode &lt; 48 || event.keyCode &gt; 57)){                return false;            }            else                return true;   //中文输入法的兼容性问题  如何禁用中文输入法        }        var cpLock = false;//默认中文输入法关闭        //中文输入法开始时触发compositionstart事件        document.addEventListener(&#39;compositionstart&#39;,function(e){                cpLock = true;        });        //中文输入法结束时触发compositionend事件        document.addEventListener(&#39;compositionend&#39;,function(e){                cpLock = false;        });        input.oninput = function(){            if(cpLock){                //将input中的A~Z  a~z都替换成空字符                this.value = this.value.replace(/[A-Za-z]/g,&quot;&quot;);            }        }     &lt;/script&gt;&lt;/body&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用</title>
    <link href="/study.github.io/2019/03/29/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2019/03/29/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><img src="https://howlcn1997.github.io/2019/09/20/Git/git.png" srcset="/study.github.io/img/loading.gif" alt="git"></p><p><strong>专有名词：</strong></p><blockquote><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul></blockquote><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>代码拉取</p><pre><code>$ git clone + Git仓库的地址</code></pre><p>切换分支</p><pre><code>$ git branch -a  //查看分支$ git checkout -b dev-0930 origin/dev-0930  //切换分支</code></pre><p>代码提交</p><pre><code>$ git status   //查看已修改文件$ git add .    //提交到暂存区$ git commit -m &quot;更新描述&quot;    //提交到本地仓库$ git pull     //拉取$ git push     //提交到远程仓库</code></pre><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h3 id="代码的提交"><a href="#代码的提交" class="headerlink" title="代码的提交"></a>代码的提交</h3><pre><code># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><pre><code># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><pre><code># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 更新分支  （当远程创建新的分支后）$ git remote update origin --prune# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]    //相当于git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code># 生成一个可供发布的压缩包$ git archive</code></pre><h3 id="设置忽略上传文件"><a href="#设置忽略上传文件" class="headerlink" title="设置忽略上传文件"></a>设置忽略上传文件</h3><p>1、项目中生成<code>.gitignoe</code>文件</p><p>Git Bash 输入</p><pre><code>$ touch .gitignoe</code></pre><p>2、配置.gitignoe</p><p>如：忽略上传node_module</p><pre><code>/node_modules</code></pre><p>3、常用规则</p><ol><li><code>/mtk/</code>过滤整个文件夹</li><li><code>*.zip</code>过滤所有.zip文件</li><li><code>/mtk/do.c</code>过滤某个具体文件</li></ol><p>配置语法</p><ol><li>以斜杠“/”开头表示目录；</li><li>以星号“*”通配多个字符；</li><li>以问号“?”通配单个字符</li><li>以方括号“[]”包含单个字符的匹配列表；</li><li>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</li></ol><p>此外： git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p><p>如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。<br>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><strong>每次项目开发之前要保证项目是最新的版本</strong></p><pre><code>$ git pull   //从仓库中拉取最新代码合并到本地代码中</code></pre><p><strong>项目开发不要在master中开发，切换到已有分支，或者新建分支</strong></p><pre><code># 切换到指定分支，并更新工作区$ git checkout [branch-name]</code></pre><hr><p><strong>开发分支</strong>（本地分支）</p><blockquote><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>hotfix-上线日期<br>如：hotfix-20190926</p></blockquote><p>新建本地提测分支</p><pre><code># 新建一个分支，并切换到该分支$ git checkout -b hotfix-20190926</code></pre><p>将本地分支关联到远程提测分支</p><pre><code>$ git branch --set-upstream-to=远程分支名 本地分支名//如：$ git branch --set-upstream-to=origin/hotfix-20190926 hotfix-20190926</code></pre><p>将已修改的代码提交</p><p><strong>提测分支</strong></p><pre><code>//命名规则release/日期如：release/20190926</code></pre><p>本地若有release/20190926且关联了远程仓库分支则无需新建</p><p>若没有，</p><p>新建本地分支</p><pre><code>$ git checkout -b release/20190926</code></pre><p>本地分支关联到远程分支</p><pre><code>//如：$ git branch --set-upstream-to=origin/release/20190926 release/20190926</code></pre><p>拉取远程代码</p><pre><code>$ git pull</code></pre><p>将本地开发分支中已修改的代码合并到本地提测分支中</p><pre><code>$ git merge release/20190926</code></pre><p>将本地提测分支中的代码提交到远程提测分支中</p><pre><code>$ git push$ git push</code></pre><p>若项目中安装了<code>commitlint/cli</code>和<code>commitlint/config-conventional</code></p><blockquote><p>这是对git commit -m 中的desc做限制 写描述时要遵循声明的规则</p><p>规则一般写在 README.md中</p></blockquote><p>如：</p><pre><code>### git commit message 规范提交commit代码格式：git commit -m &lt;type&gt;[optional scope]: &lt;description&gt;type ：用于表明我们这次提交的改动类型，是新增了功能？还是修改了测试代码？又或者是更新了文档？总结以下 11 种类型：- build：主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交- ci：主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交- docs：文档更新- feat：新增功能- fix：bug 修复- perf：性能优化- refactor：重构代码(既没有新增功能，也没有修复 bug)- style：不影响程序逻辑的代码修改(修改空白字符，补全缺失的分号等)- test：新增测试用例或是更新现有测试- revert：回滚某个更早之前的提交- chore：不属于以上类型的其他类型(日常事务)optional scope：一个可选的修改范围。用于标识此次提交主要涉及到代码中哪个模块。description：一句话描述此次提交的主要内容，做到言简意赅。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>URL.js</title>
    <link href="/study.github.io/2019/03/10/URL-js/"/>
    <url>/study.github.io/2019/03/10/URL-js/</url>
    
    <content type="html"><![CDATA[<h1 id="URI-js"><a href="#URI-js" class="headerlink" title="URI.js"></a>URI.js</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>URI.js是一个用于处理URL的JavaScript库。可以对URI进行解析， 它提供了一个 jQuery风格 API（Fluent Interface，Method Chaining）来读写所有常规组件和一些方便的方法，如.directory（）和.authority（）。</p><p>URI.js提供了简单但强大的查询字符串处理方式，具有许多URI规范化函数并转换相对/绝对路径。</p><p>而URI.js提供了一个jQuery插件。 URI.js本身不依赖于 jQuery 。 您不需要jQuery来使用URI.js</p></blockquote><h2 id="API示例"><a href="#API示例" class="headerlink" title="API示例"></a>API示例</h2><pre><code>URI(&quot;http://example.org/foo.html?hello=world&quot;)    .username(&quot;rodneyrehm&quot;)// -&gt; http://rodneyrehm@example.org/foo.html?hello=world    .username(&quot;&quot;)// -&gt; http://example.org/foo.html?hello=world    .directory(&quot;bar&quot;)// -&gt; http://example.org/bar/foo.html?hello=world   添加路径    .suffix(&quot;xml&quot;)// -&gt; http://example.org/bar/foo.xml?hello=world    添加后缀    .query(&quot;&quot;)// -&gt; http://example.org/bar/foo.xml                添加查询条件    .tld(&quot;com&quot;)// -&gt; http://example.com/bar/foo.xml                修改域名后缀    .query({ foo: &quot;bar&quot;, hello: [&quot;world&quot;, &quot;mars&quot;] });// -&gt; http://example.com/bar/foo.xml?foo=bar&amp;hello=world&amp;hello=mars// 简化URI(&quot;?&amp;foo=bar&amp;&amp;foo=bar&amp;foo=baz&amp;&quot;)    .normalizeQuery();// -&gt; ?foo=bar&amp;foo=baz// 获取相对路径URI(&quot;/foo/bar/baz.html&quot;)    .relativeTo(&quot;/foo/bar/world.html&quot;);// -&gt; ./baz.html// 获取绝对路径URI(&quot;/foo/bar/baz.html&quot;)    .relativeTo(&quot;/foo/bar/sub/world.html&quot;)// -&gt; ../baz.html    .absoluteTo(&quot;/foo/bar/sub/world.html&quot;);// -&gt; /foo/bar/baz.html// uri模板URI.expand(&quot;/foo/{dir}/{file}&quot;, {    dir: &quot;bar&quot;,    file: &quot;world.html&quot;});// -&gt; /foo/bar/world.html</code></pre><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><pre><code>var uri = new URI(); //相当于 new URI(location.href)var uri = new URI(&quot;http://example.org&quot;); //新建一个urivar uri = new URI(new URI(&quot;http://example.org&quot;)); //clone一个urivar uri = new URI(&quot;http://example.org&quot;).clone(); //clone一个urivar uri = new URI({    protocol: &quot;http&quot;, // no trailing :    username: &quot;user&quot;,    password: &quot;pass&quot;,    hostname: &quot;example.org&quot;,    port: &quot;80&quot;, // 这里是string，不是数字    path: &quot;/foo/bar.html&quot;,      query: &quot;foo=bar&amp;bar=baz&quot;, // 注意，是&quot;query&quot;，不是&quot;search&quot;，而且，不要在前面加&quot;?&quot;    fragment: &quot;frag&quot; // 注意，是&quot;fragment&quot;，不是&quot;hash&quot;，而且，不要在前面加&quot;#&quot;}); //用对象方式新建urivar parts = {    protocol: &quot;http&quot;,    username: null,    password: null,    hostname: &quot;example.org&quot;,    port: null,    path: &quot;/foo.html&quot;,    query: null,    fragment: null};URI.build(parts) === &quot;http://example.org/foo.html&quot;;var parts = {    username: &quot;user&quot;,    password: &quot;pass&quot;,    hostname: &quot;example.org&quot;,    port: &quot;8080&quot;};URI.buildAuthority(parts) === &quot;user:pass@example.org:8080&quot;;var parts = {    username: &quot;user&quot;,    password: &quot;pass&quot;};URI.buildUserinfo(parts) === &quot;user:pass@&quot;;var parts = {    hostname: &quot;example.org&quot;,    port: &quot;8080&quot;};URI.buildHost(parts) === &quot;example.org:8080&quot;;var data = {    foo: &quot;bar&quot;,    hello: [&quot;world&quot;, &quot;mars&quot;, &quot;mars&quot;],    bam: &quot;&quot;,    yup: null,    removed: undefined};// 注意，默认情况下，同一个键相同的值会被合并URI.buildQuery(data) === &quot;foo=bar&amp;hello=world&amp;hello=mars&amp;bam=&amp;yup&quot;;// 调用时传入true则会保留相同的值URI.buildQuery(data, true) === &quot;foo=bar&amp;hello=world&amp;hello=mars&amp;hello=mars&amp;bam=&amp;yup&quot;;</code></pre><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><pre><code>var uri = new URI(&quot;http://user:pass@example.org:80/foo/hello.html&quot;);uri.href() === &quot;http://user:pass@example.org:80/foo/hello.html&quot;;uri.toString() === &quot;http://user:pass@example.org:80/foo/hello.html&quot;;uri.protocol(); // &quot;http&quot;，protocol()别名为scheme()uri.username(); // &quot;user&quot;uri.password(); // &quot;pass&quot;uri.hostname(); // &quot;example.org&quot;，注意，hostname()返回的hostname不包含porturi.port(); // &quot;80&quot;uri.host(); // &quot;example.org:80&quot;uri.userinfo(); // &quot;user:pass&quot;，即username+passworduri.authority(); // &quot;user:pass@example.org:80&quot;，即username+password+hostname+porturi.origin(); // &quot;http://user:pass@example.org:80&quot;，即protocol+authorityuri.domain(); // &quot;example.org&quot;。如果url是“www.example.org”，那么hostname为“www.example.org”，而domain为“example.org”uri.subdomain(); // &quot;&quot;，如果url是“www.example.org”，那么返回&quot;www&quot;uri.tld(); // &quot;org&quot;uri.pathname(); // &quot;/foo/hello.html&quot;，pathname()别名为path()uri.directory(); // &quot;/foo&quot; 结尾没斜杠//关于特殊字符有以下情况//uri.directory(&quot;/hello world/&quot;);//uri.directory() === &quot;/hello%20world&quot;;//uri.directory(true) === &quot;/hello world&quot;;uri.filename(); // &quot;hello.html&quot; 开头没斜杠//关于特殊字符有以下情况//uri.filename(&quot;hello world.html&quot;);//uri.filename() === &quot;hello%20world.html&quot;;//uri.filename(true) === &quot;hello world.html&quot;;uri.suffix(); // &quot;html&quot; 开头没“.”//关于特殊字符有以下情况//uri.suffix(&quot;würgh&quot;);//uri.suffix() === &quot;w%C3%BCrgh&quot;;//uri.suffix(true) === &quot;würgh&quot;;uri.segment(); // 返回[&quot;foo&quot;, &quot;hello.html&quot;]，表示路径的directory//uri.segment([&quot;foo&quot;, &quot;bar&quot;, &quot;foobar.html&quot;]); // 将路径设置为http://user:pass@example.org:80/foo/bar/foobar.htmluri.segment(0); // 返回&quot;foo&quot;uri.segmentCoded(); // 返回[&quot;foo&quot;, &quot;hello.html&quot;]，功能与segment相同，只是会在返回结果时自动解码var result = URI.parse(&quot;http://example.org/foo.html&quot;);result === {    protocol: &quot;http&quot;,    username: null,    password: null,    hostname: &quot;example.org&quot;,    port: null,    path: &quot;/foo.html&quot;,    query: null,    fragment: null};var parts = {};var result = URI.parseAuthority(&quot;user:pass@example.org:8080/foo.html&quot;, parts);result === &quot;/foo.html&quot;;parts === {    username: &quot;user&quot;,    password: &quot;pass&quot;,    hostname: &quot;example.org&quot;,    port: &quot;8080&quot;};var parts = {};var result = URI.parseUserinfo(&quot;user:pass@example.org:8080/foo.html&quot;, parts);result === &quot;example.org:8080/foo.html&quot;;parts === {    username: &quot;user&quot;,    password: &quot;pass&quot;};var parts = {};var result = URI.parseHost(&quot;example.org:8080/foo.html&quot;, parts);result === &quot;/foo.html&quot;;parts === {    hostname: &quot;example.org&quot;,    port: &quot;8080&quot;};var result = URI.parseQuery(&quot;?foo=bar&amp;hello=world&amp;hello=mars&amp;bam=&amp;yup&quot;);result === {    foo: &quot;bar&quot;,    hello: [&quot;world&quot;, &quot;mars&quot;],    bam: &quot;&quot;,    yup: null};</code></pre><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><h4 id="附带参数解析"><a href="#附带参数解析" class="headerlink" title="? 附带参数解析"></a><code>?</code> 附带参数解析</h4><pre><code>var uri = new URI(&quot;http://example.org/foo/hello.html?foo=bar&amp;bar=baz&quot;);uri.search(); // 返回&quot;?foo=bar&amp;bar=baz&quot;，以&quot;?&quot;开头uri.query(); // 返回&quot;foo=bar&amp;bar=baz&quot;uri.search(true); // 返回{ foo: &quot;bar&quot;, bar : &quot;baz&quot; }</code></pre><h4 id="附带参数"><a href="#附带参数" class="headerlink" title="#附带参数"></a><code>#</code>附带参数</h4><pre><code>var uri = new URI(&quot;http://example.org/foo/hello.html#world&quot;);uri.hash(); // 返回&quot;#world&quot;，以&quot;#&quot;开头uri.fragment(); // 返回&quot;world&quot;</code></pre><h4 id="附带参数地修改"><a href="#附带参数地修改" class="headerlink" title="?附带参数地修改"></a><code>?</code>附带参数地修改</h4><blockquote><p>setSearch 是 setQuery 的别称</p></blockquote><pre><code>var uri = new URI(&quot;?hello=world&quot;);uri.setSearch(&quot;hello&quot;, &quot;mars&quot;); // 返回一个uri，uri内容为&quot;?hello=mars&quot;uri.setSearch({ foo: &quot;bar&quot;, goodbye : [&quot;world&quot;, &quot;mars&quot;] });// 返回一个uri，uri内容为&quot;?hello=mars&amp;foo=bar&amp;goodbye=world&amp;goodbye=mars&quot;uri.setSearch(&quot;goodbye&quot;, &quot;sun&quot;);// 返回一个uri，uri内容为&quot;?hello=mars&amp;foo=bar&amp;goodbye=sun&quot;uri = new URI(&quot;?hello=world&quot;);uri.addSearch(&quot;hello&quot;, &quot;mars&quot;); // 返回一个uri，uri内容为&quot;?hello=world&amp;hello=mars&quot;uri.addSearch({ foo: &quot;bar&quot;, goodbye : [&quot;world&quot;, &quot;mars&quot;] });// 返回一个uri，uri内容为&quot;?hello=world&amp;hello=mars&amp;foo=bar&amp;goodbye=world&amp;goodbye=mars&quot;uri.addSearch(&quot;no-value&quot;);//返回一个uri，uri内容为&quot;?hello=world&amp;hello=mars&amp;foo=bar&amp;goodbye=world&amp;goodbye=mars&amp;no-value&quot;uri = new URI(&quot;?hello=world&amp;hello=mars&amp;foo=bar&quot;);uri.removeSearch(&quot;hello&quot;); // 返回一个uri，uri内容为&quot;?foo=bar&quot;uri.search(&quot;?hello=world&amp;hello=mars&amp;foo=bar&quot;);uri.removeSearch(&quot;hello&quot;, &quot;world&quot;); // 返回一个uri，uri内容为&quot;?hello=mars&amp;foo=bar&quot;uri.search(&quot;?hello=world&amp;hello=mars&amp;foo=bar&amp;mine=true&quot;);uri.removeSearch([&quot;hello&quot;, &quot;foo&quot;]); // 返回一个uri，uri内容为&quot;?mine=true&quot;uri.search(&quot;?hello=world&amp;hello=mars&amp;foo=bar&amp;mine=true&amp;a=1&amp;a=2&amp;a=3&quot;);uri.removeSearch({hello: &quot;world&quot;, foo: undefined, a: [&quot;1&quot;, &quot;3&quot;]});// 返回一个uri，uri内容为&quot;?hello=mars&amp;mine=true&amp;a=2&quot;uri.search(&quot;?foo=bar&amp;foo=baz&amp;foo=bam&amp;obj=bam&amp;bar=bar&amp;bar=baz&amp;bar=bam&quot;);uri.removeSearch(&#39;foo&#39;, /[rz]$/);// 返回一个uri，uri内容为&quot;?foo=bam&amp;obj=bam&amp;bar=bar&amp;bar=baz&amp;bar=bam&quot;</code></pre><h4 id="附带参数地判断"><a href="#附带参数地判断" class="headerlink" title="?附带参数地判断"></a><code>?</code>附带参数地判断</h4><pre><code>var uri = URI(&quot;?string=bar&amp;list=one&amp;list=two&amp;number=123&amp;null&amp;empty=&quot;);// 检查参数是否存在（不管此参数是否有值）uri.hasQuery(&quot;string&quot;) === true;uri.hasQuery(&quot;nono&quot;) === false;// 检查参数的值bool化后为true还是falseuri.hasQuery(&quot;string&quot;, true) === true;uri.hasQuery(&quot;string&quot;, false) === false;uri.hasQuery(&quot;empty&quot;, true) === false;uri.hasQuery(&quot;empty&quot;, false) === true;// 检查参数的值是否为指定值uri.hasQuery(&quot;string&quot;, &quot;bar&quot;) === true;uri.hasQuery(&quot;number&quot;, 123) === true;// 检查参数的值是否在给定的列表中uri.hasQuery(&quot;list&quot;, &quot;two&quot;, true) === true;uri.hasQuery(&quot;list&quot;, [&quot;two&quot;], true) === true;uri.hasQuery(&quot;list&quot;, &quot;three&quot;, true) === false;uri.hasQuery(&quot;list&quot;, [&quot;two&quot;, &quot;three&quot;], true) === false;uri.hasQuery(&quot;list&quot;, /ne$/, true) === true;// 检查参数的值是否符合正则表达式uri.hasQuery(&quot;string&quot;, /ar$/) === true;// 检查是否有参数的名称符合正则表达式uri.hasQuery(/^str/) === true;// 检查符合正则表达式的参数的值是否为指定值uri.hasQuery(/^li/, &quot;two&quot;) === false;// 通过传入方法判断uri.hasQuery(&quot;string&quot;, function(value, name, data) {    // value === &quot;bar&quot;;    // name === &quot;string&quot;;    // data === uri.query(true);    return true;}) === true;</code></pre><h3 id="路径转换"><a href="#路径转换" class="headerlink" title="路径转换"></a>路径转换</h3><blockquote><p>relativeTo()和absoluteTo()可以将路径转换为相对路径/绝对路径。</p></blockquote><pre><code>var uri = new URI(&quot;/relative/path&quot;);// make path relativevar relUri = uri.relativeTo(&quot;/relative/sub/foo/sub/file&quot;); // 返回一个uri，uri内容为&quot;../../../path&quot;var anotherUri = relUri.absoluteTo(&quot;/relative/sub/foo/sub/file&quot;); // 返回一个uri，uri内容为&quot;/relative/path&quot;</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>URI.commonPath(&quot;/foo/bar/baz.html&quot;, &quot;/foo/bar/world.html&quot;);// 返回&quot;/foo/bar/&quot;URI.joinPaths(&#39;/a/b&#39;, &#39;/c&#39;, &#39;d&#39;, &#39;/e&#39;);// 返回URI(&quot;/a/b/c/d/e&quot;)var data = {};URI.addQuery(data, &quot;hello&quot;, &quot;mars&quot;);data === {hello: &quot;mars&quot;};URI.addQuery(data, &quot;hello&quot;, &quot;world&quot;);data === {hello: [&quot;mars&quot;, &quot;world&quot;]};URI.addQuery(data, {foo: &quot;bar&quot;, goodbye : [&quot;world&quot;, &quot;mars&quot;]});data === {hello: [&quot;mars&quot;, &quot;world&quot;], foo: &quot;bar&quot;, goodbye : [&quot;world&quot;, &quot;mars&quot;]};URI.removeQuery(data, &quot;hello&quot;);data === {foo: &quot;bar&quot;, goodbye : [&quot;world&quot;, &quot;mars&quot;]};// 移除指定值data = {hello: [&quot;world&quot;, &quot;mars&quot;], foo: &quot;bar&quot;};URI.removeQuery(data, &quot;hello&quot;, &quot;world&quot;);data === {hello: [&quot;mars&quot;], foo: &quot;bar&quot;} // yes, still an array// 移除多个键data = {hello: [&quot;world&quot;, &quot;mars&quot;], foo: &quot;bar&quot;, mine: &quot;true&quot;}URI.removeQuery(data, [&quot;hello&quot;, &quot;foo&quot;]);data === {mine: &quot;true&quot;};// 移除多个键的指定值data = {hello: [&quot;world&quot;, &quot;mars&quot;], foo: &quot;bar&quot;, mine: &quot;true&quot;, a: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]}URI.removeQuery(data, {hello: &quot;world&quot;, foo: undefined, a: [&quot;1&quot;, &quot;3&quot;]});data === {hello: [&quot;mars&quot;], mine: &quot;true&quot;, a: [&quot;2&quot;]}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工具函数</title>
    <link href="/study.github.io/2019/02/27/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    <url>/study.github.io/2019/02/27/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h1><h2 id="1、数组去重"><a href="#1、数组去重" class="headerlink" title="1、数组去重"></a>1、数组去重</h2><p>原理：利用Js中对象的属性名不可重复的特点对数组进行去重操作</p><p>若有数组:</p><pre><code>arr = [&#39;a&#39;,&#39;v&#39;,&#39;a&#39;,&#39;b&#39;,&#39;e&#39;,&#39;b&#39;,&#39;w&#39;,&#39;x&#39;]&lt;script&gt;    var object = {};    for(var key in arr)        if(!object[arr[key]])            object[arr[key]] = 1;&lt;/script&gt;</code></pre><p>打印结果：</p><pre><code>Object    a: 1    b: 1    e: 1    v: 1    w: 1    x: 1</code></pre><p>此时object对象中的属性名便是去重后的结果。</p><h2 id="2、在字符串中找到所有的字符-o，并返回其下标"><a href="#2、在字符串中找到所有的字符-o，并返回其下标" class="headerlink" title="2、在字符串中找到所有的字符 o，并返回其下标"></a>2、在字符串中找到所有的字符 o，并返回其下标</h2><p>若有字符串</p><pre><code>var s = &#39;oresdfrgosdfsdo&#39; &lt;script&gt;      var index = -1;    while(true){        index = s.indexOf(&quot;o&quot;,index+1)        if(index == -1)            break;            console.log(index);    }&lt;/script&gt;</code></pre><p>结果：</p><pre><code>0814</code></pre><hr><p>2019 年 10 月 24 日 更新</p><h2 id="3、返回给定参数的数据类型"><a href="#3、返回给定参数的数据类型" class="headerlink" title="3、返回给定参数的数据类型"></a>3、返回给定参数的数据类型</h2><pre><code>/***    getType*    @description 返回给定参数的数据类型*    @param {Any} 需要做类型检测的参数*    @return {String}*/function getType(args){    if (typeof arg === &#39;number&#39; &amp;&amp; isNaN(arg)) return &#39;NaN&#39;;    let reg = /\s(\w{1,})\]$/g;    let str = Object.prototype.toString.call(args);    let type = reg.exec(str)[1];    return type}</code></pre><p>测试</p><pre><code>var a = 1;var b = false;var c = &#39;ss&#39;;var d;var e = null;var f = NaN;var g = {};var h = () =&gt; {}var i = [];console.log(checkType(a));console.log(checkType(b));console.log(checkType(c));console.log(checkType(d));console.log(checkType(e));console.log(checkType(f));console.log(checkType(g));console.log(checkType(h));console.log(checkType(i));</code></pre><h2 id="4、什么时候-val-1-amp-amp-val-2-amp-amp-val-3-为-true？"><a href="#4、什么时候-val-1-amp-amp-val-2-amp-amp-val-3-为-true？" class="headerlink" title="4、什么时候 val === 1 &amp;&amp; val === 2 &amp;&amp; val === 3 为 true？"></a>4、什么时候 val === 1 &amp;&amp; val === 2 &amp;&amp; val === 3 为 true？</h2><pre><code>var i= 0;Object.defineProperty(window,&#39;val&#39;,{    get:function(){        return ++i;    },    set:function(){        console.log(&#39;set&#39;)    }})console.log(val === 1 &amp;&amp; val === 2 &amp;&amp; val === 3);</code></pre><h2 id="5、计算一段文本的宽度"><a href="#5、计算一段文本的宽度" class="headerlink" title="5、计算一段文本的宽度"></a>5、计算一段文本的宽度</h2><p><strong>React</strong></p><pre><code>/** * @name: text-width ; * @author: admin ; * @description: 获取字符串宽度 ; * */import memoize from &#39;lodash/memoize&#39;;export default memoize((text, fontSize, options) =&gt; {    const {fontFamily, fontWeight} = Object.assign({fontFamily: &#39;Arial&#39;, fontWeight: &#39;normal&#39;}, options);    const canvas = document.createElement(&#39;canvas&#39;),          ctx = canvas.getContext(&#39;2d&#39;);    ctx.font = `${fontSize} ${fontFamily} ${fontWeight}`;    return ctx.measureText(text).width;}, (text, fontSize, options) =&gt; {    const obj = Object.assign({}, options, {text, fontSize});    return Object.keys(obj).map((key) =&gt; `${key}-${obj[key]}`).join(&#39;,&#39;);});</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Canvas的基本使用</title>
    <link href="/study.github.io/2019/02/20/Canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2019/02/20/Canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Canvas的基本使用"><a href="#Canvas的基本使用" class="headerlink" title="Canvas的基本使用"></a>Canvas的基本使用</h1><blockquote><p>canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。<br>基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。<br><canvas> 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。</p></blockquote><h3 id="体验Canvas"><a href="#体验Canvas" class="headerlink" title="体验Canvas"></a>体验Canvas</h3><h4 id="什么是Canvas？"><a href="#什么是Canvas？" class="headerlink" title="什么是Canvas？"></a>什么是Canvas？</h4><p>HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。<br>画布是一个矩形区域，您可以控制其每一像素。<br>canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p><h4 id="创建Canvas元素"><a href="#创建Canvas元素" class="headerlink" title="创建Canvas元素"></a>创建Canvas元素</h4><p>向 HTML5 页面添加 canvas 元素。<br>规定元素的 id、宽度和高度：</p><pre><code>&lt;!--1.准备画布--&gt;&lt;!--1.1 画布是白色的 而且默认300*150--&gt;&lt;!--1.2 设置画布的大小  width=&quot;600&quot; height=&quot;400&quot; --&gt;&lt;canvas width=&quot;600&quot; height=&quot;400&quot; &gt;&lt;/canvas&gt;&lt;!--2.准备绘制工具--&gt;&lt;!--3.利用工具绘图--&gt;</code></pre><p>注意：canvas的大小要在标签内定义，否则会出现意料之外的效果。</p><h4 id="Canvas坐标系"><a href="#Canvas坐标系" class="headerlink" title="Canvas坐标系"></a>Canvas坐标系</h4><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/location.jpg" srcset="/study.github.io/img/loading.gif" alt="img"></p><h4 id="通过JavaScript来绘制"><a href="#通过JavaScript来绘制" class="headerlink" title="通过JavaScript来绘制"></a>通过JavaScript来绘制</h4><pre><code>/*获取元素*/var myCanvas = document.querySelector(&#39;#myCanvas&#39;);/*获取上下文 绘制工具箱 *//*目前canvas只支持2d*//*若要达到3d效果，需要想象一个3d坐标系后，再投影到canvas上*//*或者配合WebGL达到3d效果*/var context = myCanvas.getContext(&#39;2d&#39;);/*设置绘图的起始位置*/context.moveTo(100,100);/*绘制路径*/context.lineTo(200,200);/*描边*/context.stroke();</code></pre><h3 id="Canvas的基本使用-1"><a href="#Canvas的基本使用-1" class="headerlink" title="Canvas的基本使用"></a>Canvas的基本使用</h3><h4 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h4><p>1、开启新的路径</p><pre><code>ctx.beginPath();</code></pre><p>2、画路径</p><pre><code>ctx.moveTo(100,100);  //将画笔放置在100px 100px的位置ctx.lineTo(200,100);  //从（100，100）向（200，100）画一条轨迹ctx.lineTo(200,200);  //从（200，100）向（200，200）画一条轨迹</code></pre><p>此时，是看不出线条的，因为此时仅仅是一条没有颜色的轨迹。</p><p>3、给路径描边（上色）</p><pre><code>ctx.strokeStyle = &quot;red&quot;; //设置画笔颜色ctx.stroke();  //开始描边</code></pre><p>4、闭合路径</p><pre><code>ctx.closePath();  //将路径的起点与终点连接</code></pre><h4 id="填充规则-非零环绕"><a href="#填充规则-非零环绕" class="headerlink" title="填充规则(非零环绕)"></a>填充规则(非零环绕)</h4><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/zero.jpg" srcset="/study.github.io/img/loading.gif" alt="img"></p><h4 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h4><h5 id="画笔的状态"><a href="#画笔的状态" class="headerlink" title="画笔的状态"></a>画笔的状态</h5><ul><li><p>lineWidth 线宽，默认1</p></li><li><p>lineCap 线末端类型：(butt默认)、round、square</p><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/lineCap.png" srcset="/study.github.io/img/loading.gif" alt="lineJoin"></p></li><li><p>lineJoin 相交线的拐点 miter(默认)、round、bevel</p><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/lineJoin.png" srcset="/study.github.io/img/loading.gif" alt="lineJoin"></p></li><li><p>strokeStyle 线的颜色</p><pre><code>ctx.strokeStyle = &quot;blue&quot;;</code></pre></li><li><p>fillStyle 填充颜色</p><pre><code>ctx.fillStyle  = &quot;blue&quot;;</code></pre></li><li><p>setLineDash() 设置虚线</p><pre><code>ctx.setLineDash([50,10]);</code></pre><p>setLineDash方法规定虚线的特征，它的参数是一个具有两个元素的数组。</p><p>第一个数组元素规定虚线尺寸，也就是我们可见的部分，比如上面的红色小线段。</p><p>第二个数组元素规定虚线与虚线之间的间隔，通过线段与间隔交替出现，构成了一个完整的虚线。</p></li><li><p>getLineDash() 获取虚线宽度集合</p><pre><code>console.log(ctx.getLineDash());</code></pre><p>打印结果：<code>(2) [500, 10]</code></p></li><li><p>lineDashOffset 设置虚线偏移量（负值向右偏移）</p><pre><code>/*如果是正的值 往后偏移*//*如果是负的值 往前偏移*//*ctx.lineDashOffset = 10;*/ctx.lineDashOffset = -10;</code></pre></li></ul><h5 id="线性颜色渐变填充"><a href="#线性颜色渐变填充" class="headerlink" title="线性颜色渐变填充"></a>线性颜色渐变填充</h5><ul><li><p>利用循环绘制从黑道白道的渐变</p><pre><code>ctx.lineWidth = 30;for (var i = 0; i &lt; 255; i++) {    ctx.beginPath();    ctx.moveTo(100+i-1,100);    ctx.lineTo(100+i,100);    ctx.strokeStyle = &#39;rgb(&#39;+i+&#39;,&#39;+i+&#39;,&#39;+i+&#39;)&#39;;    ctx.stroke();}</code></pre></li><li><p>createLinearGradient</p><p>1、先利用createLinearGradient创建出一个颜色渐变的样式</p><pre><code>/*1、确定渐变方向*//*渐变起点x  起点y   终点x  终点y*//*由（100px,100px）渐变至（500,400px）*/var linearGradient = ctx.createLinearGradient(100,100,500,400);/*调节起始与终止点的位置  使之在水平对齐  渐变效果为由上而下渐变*/// var linearGradient = ctx.createLinearGradient(100,150,200,150);/*调节起始与终止点的位置  使之在垂直对齐  渐变效果为由左而右渐变*/// var linearGradient = ctx.createLinearGradient(250,100,250,200);/*2、确定渐变颜色*//*位置（取值为0~1）   颜色*/linearGradient.addColorStop(0,&#39;pink&#39;);linearGradient.addColorStop(0.5,&#39;red&#39;);linearGradient.addColorStop(1,&#39;blue&#39;);</code></pre><p>2、给画笔上渐变色！</p><pre><code>ctx.fillStyle = linearGradient;</code></pre><p>3、填充</p><pre><code>ctx.rect(0,0,200,100);ctx.fill();  //对stroke()失效</code></pre></li></ul><h5 id="径向颜色渐变填充"><a href="#径向颜色渐变填充" class="headerlink" title="径向颜色渐变填充"></a>径向颜色渐变填充</h5><ul><li><p>createRadialGradient(x0,y0,r0,x1,y1,r1,x2,y2,r2……)</p><p>x0,y0,r0 第一个圆 圆心的x，圆心的y，圆心的半径</p><p>。。。以此类推</p><pre><code>var canvas = document.getElementById(&quot;myCanvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);//绘制一个以坐标点(100,100)为圆心、半径为50px的圆形ctx.arc(100, 100, 50, 0, Math.PI * 2, false);//创建一个表示放射性颜色渐变的CanvasGradient对象//该对象的作用域是以(100,100)为圆心、半径为10px的内圆和以(100,100)为圆心、半径为50px的外圆之间的环状区域var canvasGradient = ctx.createRadialGradient(100, 100, 10, 80, 100, 80);//在offset为0的位置(即内圆的圆圈处)添加一个蓝色的渐变canvasGradient.addColorStop(0, &quot;blue&quot;);//在offset为0.5的位置(环状区域从内到外放射50%的中间位置)添加一个绿色的渐变canvasGradient.addColorStop(0.5, &quot;pink&quot;);//在offset为0的位置(即外圆的圆圈处)添加一个红色的渐变canvasGradient.addColorStop(1, &quot;orange&quot;);//将fillStyle的属性值设为该CanvasGradient对象ctx.fillStyle = canvasGradient;ctx.fill();</code></pre></li></ul><h3 id="Canvas图形绘制"><a href="#Canvas图形绘制" class="headerlink" title="Canvas图形绘制"></a>Canvas图形绘制</h3><h4 id="矩形绘制"><a href="#矩形绘制" class="headerlink" title="矩形绘制"></a>矩形绘制</h4><ul><li><p>rect(x,y,w,h) 只创造出矩形而不绘制（stroke fill），也不结束绘画</p><pre><code>ctx.rect(100,100,200,100); //左上角x轴坐标  左上角y轴坐标 宽 高</code></pre></li><li><p>strokeRect(x,y,w,h) 有独立路径，会自动绘制（stroke），自动结束绘画，不影响下次绘画。</p></li><li><p>fillRect(x,y,w,h) 有独立路径，不影响别的绘制</p></li><li><p>clearRect(x,y,w,h) 擦除矩形区域</p></li></ul><h4 id="圆弧绘制"><a href="#圆弧绘制" class="headerlink" title="圆弧绘制"></a>圆弧绘制</h4><p>arc(x,y,r,startAngle,endAngle,anticlockwise)</p><ul><li>x 圆心横坐标</li><li>y 圆心纵坐标</li><li>r 半径</li><li>startAngle 开始角度</li><li>endAngle 结束角度</li><li>anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针）</li></ul><pre><code>context.arc(200,200,150,0,Math.PI/3,false);  //默认 顺时针// context.arc(w/2,h/2,150,0,Math.PI/3,true);  //逆时针</code></pre><h4 id="扇形的绘制"><a href="#扇形的绘制" class="headerlink" title="扇形的绘制"></a>扇形的绘制</h4><pre><code>ctx.moveTo(200,200);// arc是紧接着上一次笔触的地方开始画// ctx.beginPath();  //当重新开始路劲时效果会发生变化ctx.arc(200,200,100,0,Math.PI/3,true);  //这里暗含着 lineTo(300,200);ctx.closePath();ctx.stroke();</code></pre><h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><ul><li>ctx.font = ‘微软雅黑’ 设置字体</li><li>strokeText()</li><li>fillText(text,x,y,maxWidth)<ul><li>text 要绘制的文本</li><li>x,y 文本绘制的坐标（文本左下角）</li><li>maxWidth 设置文本最大宽度，可选参数</li></ul></li><li>ctx.textAlign文本水平对齐方式，相对绘制坐标来说的<ul><li>left</li><li>center</li><li>right</li><li>start 默认</li><li>end</li></ul></li><li>ctx.direction属性css(rtl ltr) start和end于此相关<ul><li>如果是ltr,start和left表现一致</li><li>如果是rtl,start和right表现一致</li></ul></li><li>ctx.textBaseline 设置基线（垂直对齐方式 ）<ul><li>top 文本的基线处于文本的正上方，并且有一段距离</li><li>middle 文本的基线处于文本的正中间</li><li>bottom 文本的基线处于文本的证下方，并且有一段距离</li><li>hanging 文本的基线处于文本的正上方，并且和文本粘合</li><li>alphabetic 默认值，基线处于文本的下方，并且穿过文字</li><li>ideographic 和bottom相似，但是不一样</li></ul></li><li>measureText() 获取文本宽度obj.width</li></ul><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/01base.gif" srcset="/study.github.io/img/loading.gif" alt="01base"></p><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/02base.gif" srcset="/study.github.io/img/loading.gif" alt="02base"></p><p>一个点确定曲线（一次）</p><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/bezier02.gif" srcset="/study.github.io/img/loading.gif" alt="bezier02"></p><p>两个点确定曲线（二次）</p><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/bezier03.gif" srcset="/study.github.io/img/loading.gif" alt="bezier03"></p><p>三个点确定曲线（三次）</p><p><img src="https://howlcn1997.github.io/2019/08/19/canvas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/bezier04.gif" srcset="/study.github.io/img/loading.gif" alt="bezier04"></p><pre><code>&lt;canvas id=&quot;canvas&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;&lt;/canvas&gt;//1.拿到画布var canvas = document.getElementById(&quot;canvas&quot;);//2.拿到画布的上下文var context = canvas.getContext(&#39;2d&#39;);//3.一次贝塞尔曲线context.beginPath();context.moveTo(300,100);context.quadraticCurveTo(100, 100, 300, 300);context.stroke();//4.二次贝塞尔曲线context.beginPath();context.moveTo(300,100);context.bezierCurveTo(100, 100, 300, 300,200,400);context.stroke();</code></pre><h3 id="做动画"><a href="#做动画" class="headerlink" title="做动画"></a>做动画</h3><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><h5 id="创建图片对象"><a href="#创建图片对象" class="headerlink" title="创建图片对象"></a>创建图片对象</h5><pre><code>var img = new Image();img.src = &quot;./image/img1.jpg&quot;;</code></pre><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><pre><code>//图片加载完毕 触发事件img.onload() = function(){    //ctx.drawImage();}</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li>drawImage()<ul><li>三个参数drawImage(img,x,y)<ul><li>img 图片对象、canvas对象、video对象</li><li>x,y 图片绘制的左上角</li></ul></li><li>五个参数drawImage(img,x,y,w,h)<ul><li>img 图片对象、canvas对象、video对象</li><li>x,y 图片绘制的左上角</li><li>w,h 图片绘制尺寸设置(图片缩放，不是截取)</li></ul></li><li>九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1)<ul><li>img 图片对象、canvas对象、video对象</li><li>x,y,w,h 图片中的一个矩形区域（从图片上截取一部分）</li><li>x1,y1,w1,h1 画布中的一个矩形区域</li></ul></li></ul></li></ul><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><ul><li>平移 移动画布的原点<ul><li>translate(x,y) 参数表示移动目标点的坐标</li></ul></li><li>缩放<ul><li>scale(x,y) 参数表示宽高的缩放比例</li></ul></li><li>旋转<ul><li>rotate(angle) 参数表示旋转角度</li></ul></li></ul><h4 id="绘制帧动画"><a href="#绘制帧动画" class="headerlink" title="绘制帧动画"></a>绘制帧动画</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/study.github.io/2019/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/study.github.io/2019/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则就是对字符串进行查找、匹配、替换等操作的一串“规则字符串”</p><p>使用方法：在一对斜杠之间添加正则表达式 如：<strong>/</strong> 正则表达式 <strong>/</strong></p><h2 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h2><ul><li>普通字符</li><li>特殊字符（元字符）：正则表达式中具有特殊意义的字符</li></ul><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="center"><strong>\d</strong></th><th align="center"><strong>表示数字</strong></th></tr></thead><tbody><tr><td align="center"><strong>\D</strong></td><td align="center"><strong>非数字</strong></td></tr><tr><td align="center"><strong>\s</strong></td><td align="center"><strong>空格符</strong></td></tr><tr><td align="center"><strong>\S</strong></td><td align="center"><strong>非空格符</strong></td></tr><tr><td align="center"><strong>\w</strong></td><td align="center"><strong>字母或数字或下划线</strong></td></tr><tr><td align="center"><strong>\W</strong></td><td align="center"><strong>非字母、数字、下划线</strong></td></tr><tr><td align="center"><strong>.</strong></td><td align="center"><strong>任意字符（不包含换行符）</strong></td></tr><tr><td align="center"><strong>\b</strong></td><td align="center"><strong>单词边界</strong></td></tr></tbody></table><p>实例1:</p><pre><code>var reg = /\d/; //新建一个正则对象 var str = &#39;1&#39;;console.log(reg.test(str)); //true  str中含有数字//test()是正则对象中的一个方法，它会判断str是否满足正则表达式，返回boolean</code></pre><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定之前表达式出现的次数</p><table><thead><tr><th align="center">*****</th><th align="center"><strong>重复0次或多次</strong></th></tr></thead><tbody><tr><td align="center"><strong>+</strong></td><td align="center"><strong>重复1次或多次</strong></td></tr><tr><td align="center"><strong>？</strong></td><td align="center"><strong>重复0次或1次</strong></td></tr><tr><td align="center"><strong>{n}</strong></td><td align="center"><strong>重复n次 (连续)</strong></td></tr><tr><td align="center"><strong>{n,}</strong></td><td align="center"><strong>重复至少n次 (连续)</strong></td></tr><tr><td align="center"><strong>{n,m}</strong></td><td align="center"><strong>重复n到m次 (连续)</strong></td></tr></tbody></table><pre><code>var reg = /\d*/;console.log(reg.test(&#39;w&#39;));//trueconsole.log(reg.test(&#39;12&#39;));//truevar reg = /\d+/;console.log(reg.test(&#39;w&#39;));//falseconsole.log(reg.test(&#39;12&#39;));//truevar reg = /\d?/;console.log(reg.test(&#39;w&#39;));//trueconsole.log(reg.test(&#39;12&#39;));//trueconsole.log(reg.test(&#39;w12&#39;));//true//这里12出现了两次，不满足“重复0次或1次”的条件为什么显示为true呢？//当执行test()时，只要字符串中有部分满足条件则返回true）//解决办法var reg = /^\d?$/;  加上开始结束符（后面会介绍）var reg = /\d{2}/;//{n}console.log(reg.test(&#39;2&#39;));//falseconsole.log(reg.test(&#39;23&#39;));//trueconsole.log(reg.test(&#39;2w3&#39;));//false  不连续时匹配失败console.log(reg.test(&#39;234&#39;));//true  (理应为false)原因同上console.log(reg.test(&#39;ab234&#39;));//true  (理应为false)原因同上  解决办法同上var reg = /\d{2,}/;//{n,}  //同样存在以上问题var reg = /\d{2,6}/;//{n,m}  //同样存在以上问题</code></pre><h2 id="范围符"><a href="#范围符" class="headerlink" title="范围符[ ]"></a>范围符[ ]</h2><p>1、[a-z]、[A-Z]、[0-9],也可以综合写成[a-zA-Z0-9]；当然这范围是自己定义的，比如[a-b]，范围是a到b。</p><p>2、[\u4e00-\u9fa5] 匹配汉字的范围 其中\u4e00，\u9fa5是中日韩汉字Unicode表中对应的编码 4e00对应“一” 9fa5对应“龥”</p><p><a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">中日韩汉字Unicode表</a></p><p>3、[ab5&amp;@],仅匹配 a 或 b 或 5 或 &amp; 或 @</p><p>4、<strong>[^ab5&amp;@]</strong> 匹配除 a 或 b 或 5 或 &amp; 或 @之外的内容 （注意此处^是在[ ]内的，<strong>区别于开始符^</strong>,两者所处位置不同）</p><p>5、3 | a 匹配3或者a字符</p><h2 id="开始结束符号"><a href="#开始结束符号" class="headerlink" title="开始结束符号"></a>开始结束符号</h2><table><thead><tr><th align="center"><strong>^</strong></th><th align="center"><strong>开始符（强制规定匹配开始的地方）</strong></th></tr></thead><tbody><tr><td align="center"><strong>$</strong></td><td align="center"><strong>结束符（强制规定匹配结束的地方）</strong></td></tr></tbody></table><p>实例：</p><pre><code>^\d 字符串要以数字开始，数字只能出现一次\d$  字符串要以数字结束，数字只能出现一次^\d$  字符串要以数字开始和结束，数字只能出现一次\d+$  字符串要以数字开始，以数字结束，数字只能出现一次^\d?$  字符串要以数字开头和结束，数字出现0次或1次</code></pre><p>我们来解释 <strong>var reg = /\d?/;</strong> 例子中出现的问题</p><pre><code>var reg = /\d?/;console.log(reg.test(&#39;w&#39;));//trueconsole.log(reg.test(&#39;12&#39;));//开始检测，当检测到 1 时，因为满足了数字出现0次，匹配成功，返回true，此时结束位置在1和2之间//加入开始结束符var reg = /^\d?$/;console.log(reg.test(&#39;w&#39;));//trueconsole.log(reg.test(&#39;12&#39;));//当加入开始结束字符后，开始匹配位置强制从1开始 2结束//则12是由两个数字的  不符合“重复0次或1次”的条件，则为false</code></pre><p>我们来解释 <strong>var reg = /\d{2}/;</strong> 例子中出现的问题</p><pre><code>var reg = /\d{2}/;//{n}console.log(reg.test(&#39;2&#39;));//falseconsole.log(reg.test(&#39;23&#39;));//trueconsole.log(reg.test(&#39;234&#39;));//true  开始字符为2  结束字符为3console.log(reg.test(&#39;ww234&#39;));//true 开始字符为2  结束字符为3var reg = /^\d{2}$/;//{n}console.log(reg.test(&#39;2&#39;));//falseconsole.log(reg.test(&#39;23&#39;));//trueconsole.log(reg.test(&#39;234&#39;));//false  开始字符为2  结束字符为4console.log(reg.test(&#39;ab234&#39;));//false 开始字符为a  结束字符为4</code></pre><h2 id="正则对象的创建方式"><a href="#正则对象的创建方式" class="headerlink" title="正则对象的创建方式"></a>正则对象的创建方式</h2><h3 id="1、new-RegExp"><a href="#1、new-RegExp" class="headerlink" title="1、new RegExp()"></a>1、new RegExp()</h3><p>RegExp(reg,msg) 参数一：正则表达式</p><p> 参数二：附加条件（如：i 忽略大小写，g 全局匹配）</p><p>实例：</p><pre><code>var reg = new RegExp(&#39;\\w+&#39;,&#39;ig&#39;);  //注意，此处第一个\是转义字符，因为参数一不能直接传入正则表达式var reg = new RegExp(&#39;[a-z]&#39;,&#39;ig&#39;);var str = &quot;AaaC2_&quot;;console.log(reg.test(str));//true</code></pre><h3 id="2、简写"><a href="#2、简写" class="headerlink" title="2、简写"></a>2、简写</h3><pre><code>var reg = /[a-z]/ig;var str = &quot;AaaC2_&quot;;console.log(reg.test(str));//true</code></pre><h2 id="正则对象的方法"><a href="#正则对象的方法" class="headerlink" title="正则对象的方法"></a>正则对象的方法</h2><p>RegExp.test(‘字符串’); 判断字符串知否满足正则表达式 返回布尔值</p><p>RegExp.exec(‘字符串’); 判断字符串知否满足正则表达式 将找到的内容以数组的形式返回</p><p>1、不使用 “<code>g</code>“ 标志时,每次都返回第一个找的内容 而不继续向后查找</p><p>2、当正则表达式使用 “<code>g</code>“ 标志时，可以多次执行 <code>exec</code> 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener"><code>lastIndex</code></a> 属性指定的位置开始</p><p><strong>lastIndex</strong>:</p><p>只有正则表达式使用了表示全局检索的 “<code>g</code>“ 标志时，该属性才会起作用。此时应用下面的规则：</p><ul><li>如果 <code>lastIndex</code> 大于字符串的长度，则 <code>regexp.test</code> 和 <code>regexp.exec</code> 将会匹配失败，然后 <code>lastIndex</code> 被设置为 0。</li><li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 <code>lastIndex</code> 开始的字符串。（then the regular expression matches input starting at <code>lastIndex</code>.）</li><li>如果 <code>lastIndex</code> 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，<code>lastIndex</code> 被设置为 0.。</li><li>否则，<code>lastIndex</code> 被设置为紧随最近一次成功匹配的下一个位置。</li></ul><p>实例：</p><pre><code>//找出所有三个英文字母组成的  并且以A开头的单词var str = &#39;Asd Asss wes sgetgs x Adv Wdf&#39;;var reg = /\bA[A-Za-z]{2}\b/g;console.log(reg.lastIndex);//初始值为0var word = reg.exec(str);//￥1￥console.log(reg.lastIndex);//3while(word){    console.log(word);    word = reg.exec(str);//￥2￥    console.log(reg.lastIndex);}onsole.log(word);//nullconsole.log(reg.lastIndex);//0</code></pre><p>该函数运行的实质：exec每一次执行都有开始位置，而这个开始位置是由RegExp对象的lastIndex属性值所决定的；</p><p>以下为该段代码的执行顺序与解析：</p><pre><code>1、reg.lastIndex 的初始值为02、执行￥1￥处的exec时，当前的lastIndex数值为0，则exec从字符串的0位置（即A字符）开始。执行结束，将**所找的字符串**（Asd）以数组的形式返回给word，并修改reg.lastIndex的值为&quot; **所找到的字符串最后一个的位置的下一个位置** &quot;（也就是d下标加一，为3），3、执行while循环，word此时为[Asd]数组，while语句判断成功4、执行￥2￥处的exec，此时reg.lastIndex为3，则从字符串中下标为3的字符开始执行，找到 &quot;Adv&quot;,  v的下标为24，则reg.lastIndex的值被设置为25，word此时为[Adv]数组5、判断while 成功6、执行￥2￥处的exec，此时reg.lastIndex为25，则从字符串中下标为25的字符开始执行，未找到满足条件的内容，则返回null给word，并将reg.lastIndex设为0；7、判断while,此时word为null，判断失败，则跳出循环8、程序结束</code></pre><h2 id="懒惰模式与贪婪模式"><a href="#懒惰模式与贪婪模式" class="headerlink" title="懒惰模式与贪婪模式"></a>懒惰模式与贪婪模式</h2><p>懒惰模式：在满足条件的前提下，尽可能<strong>少</strong>的匹配字符</p><p>贪婪模式：在满足条件的前提下，尽可能<strong>多</strong>的匹配字符</p><p>正则表达式的量词有：* + ？ {}</p><p>量词默认是贪婪模式，当在量词之后加上?时，将贪婪模式转换为懒惰模式。</p><h2 id="分组提取"><a href="#分组提取" class="headerlink" title="分组提取"></a>分组提取</h2><p>正则中（）表示分组</p><p>若存在</p><pre><code>((((a))((b)))(c))</code></pre><p>则第一组；(((a))((b)))(c)</p><p>第二组：((a))</p><p>第三组：(a)</p><p>第四组：(b)</p><p>第五组：(c)</p><p>找法：从左往右找左括号(</p><p>实例：</p><pre><code>var reg = /((\d+)(\w+))/;var str = &quot;123abc_c&quot;if(reg.test(str)){    //$后的数字 类似数组的下标    console.log(RegExp.$1);//获得第一组(\d+)(\w+)的内容  则是123abc_c    console.log(RegExp.$2);//获得第二组(\d+)的内容  则是123    console.log(RegExp.$3);//获得第二组(\w+)的内容  则是abc_c}</code></pre><h2 id="字符串中正则的使用"><a href="#字符串中正则的使用" class="headerlink" title="字符串中正则的使用"></a>字符串中正则的使用</h2><p>方法：</p><table><thead><tr><th align="center"><strong>String.match(正则对象)</strong></th><th align="center"><strong>返回符合正则条件的集合</strong></th></tr></thead><tbody><tr><td align="center"><strong>String.replace(正则对象,”替换的字符串”)</strong></td><td align="center"><strong>替换字符串，若要全局替换，正则对象要加g</strong></td></tr><tr><td align="center"><strong>String.search(正则对象)</strong></td><td align="center"><strong>查找字符串，返回查找内容的第一次出现的位置</strong></td></tr><tr><td align="center"><strong>String.split(正则对象)</strong></td><td align="center"><strong>切割字符串，返回切割后的数组</strong></td></tr></tbody></table><pre><code>//matchvar str=&quot;abc123ee23f90&quot;;//将字符串中所有出现的每一个数字提取出来var arr =  str.match(/\d/g);console.log(arr);//将字符串中所有出现的连续的数字提取出来var arr =  str.match(/\d+/g);console.log(arr);//replace//替换所有 - +var str = &quot;a-b-+b-c&quot;;console.log(str.replace(/-|\+/g,&quot;*&quot;));//结果a*b**b*c//若不加g  则结果为a*b-+b-c//search//忽略大小写  找到第一个b的下标var str = &quot;a-b-b-c&quot;;console.log(str.search(/B/i));//结果2//splitvar str=&quot;a|b|c|&quot;;console.log(str.split(/\|/));//结果  &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS垃圾回收机制</title>
    <link href="/study.github.io/2019/01/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/study.github.io/2019/01/19/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>“垃圾回收”是将程序中不再使用的内存空间进行回收的通俗说法。</p><p>C++等于语言的回收机制是由程序员编写<strong>析构函数</strong>进行垃圾回收</p><p>java等语言中的回收机制是<strong>由系统完成</strong>，无需程序员考虑</p><p>而javascript的回收机制就属于<strong>由系统完成回收</strong>。而细分javascript的回收机制又有两种：标记清除法、引用计数法。其中标记清除法现是主流，而引用计数法是在低版本的IE浏览器中使用。</p><h2 id="二、引用计数法"><a href="#二、引用计数法" class="headerlink" title="二、引用计数法"></a>二、引用计数法</h2><p>简而言之就是一个对象被引用几次，那么它的引用计数就是几。而javascript中的回收机制会实时扫描对象的引用计数是0时就回收此对象。</p><pre><code>A ---------&gt; B ---------&gt; C//例如对象A有一个属性指向B，而B也有一个属性指向C。即使当前作用域中只有对象A有效，但由于指针的关系所有3个对象都必须保留在内存中。当离开A的当前作用域时（例如代码执行到声明A的函数的末尾处），垃圾收集器就可以释放A占用的内存。此时，由于没有什么指向B，因此B可以释放，最后，C也可以释放。</code></pre><p>但此方法会发生内存泄露的问题</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏是指程序中己动态分配的<strong>堆内存</strong>由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>若有如下引用关系</p><p><img src="https://howlcn1997.github.io/2019/05/12/%E7%AE%80%E8%BF%B0JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" srcset="/study.github.io/img/loading.gif" alt="循环引用"></p><p>B引用了C，C引用了B，构成循环引用，则它们的引用计数最低为1，则不会被回收机制回收（尽管它们对于程序的运行无任何作用）。</p><p>当使用引用计数法垃圾回收机制时，若内存中存在两个或多个对象的引用链形成回路时，则此时发生<strong>循环引用</strong>，系统无法释放该内存，而导致内存泄漏，这是内存泄露的一种。</p><h3 id="循环引用以及解决办法"><a href="#循环引用以及解决办法" class="headerlink" title="循环引用以及解决办法"></a>循环引用以及解决办法</h3><h4 id="闭包发生循环引用"><a href="#闭包发生循环引用" class="headerlink" title="闭包发生循环引用"></a>闭包发生循环引用</h4><p>例1</p><pre><code>function outerfn(){    var obj = {        name: &quot;张三&quot;    }    function innerfn(){        return obj;    }    obj.objfn = innerfn;        return innerfn;    };    console.log(outerfn()());//此情况中 innerfn函数引用了obj  obj中也引用了innerfn  此时构成循环引用//解决办法 去除obj.objfn = innerfn;</code></pre><p>例2</p><pre><code>function outerfn(){    var obj = {        name: &quot;张三&quot;    }    function innerfn(){        return &#39;in&#39;;    }    obj.objfn = innerfn;    return innerfn;};console.log(outerfn()());//此情况中 innerfn函数虽未直接引用obj  但是却存在隐式引用  obj中引用了innerfn  此时构成循环引用//解决办法 去除obj.objfn = innerfn;</code></pre><h4 id="DOM与JavaScript的循环引用"><a href="#DOM与JavaScript的循环引用" class="headerlink" title="DOM与JavaScript的循环引用"></a>DOM与JavaScript的循环引用</h4><pre><code>window.onload = function(){    var box = document.ElementById(&#39;box&#39;);    box.onclick = function(){        //打印box        console.log(box);    }}//此情况中 onclick函数引用了box(打印box)  box引用了onclick(box.onclick)  此时构成循环引用//解决办法  将内部函数的声明写在外部函数的外面window.onload = function(){    var box = document.ElementById(&#39;box&#39;);    box.onclick = doOnclick;}function doOnclick(){    console.log(this);}</code></pre><p>引用计数法的内存泄漏问题严重(已被大量浏览器抛弃使用)，所以有了标记清除发来解决这一问题。</p><h2 id="三、标记清除法"><a href="#三、标记清除法" class="headerlink" title="三、标记清除法"></a>三、标记清除法</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> 大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。</p><p>标记清除算法由以下步骤组成：<br>1.垃圾回收器构建”roots”列表。Roots通常是代码中保留引用的全局变量。在JavaScript中，”window”对象可以作为 root 全局变量示例。<br>2.所有的”roots”被检查并标记为active（即不是垃圾）。所有的children也被递归检查。从”root”能够到达的一切都不被认为是垃圾。<br>3.所有为不被标记为active的内存可以被认为是垃圾了。收集器限制可以释放这些内存并将其返回到操作系统</p><p>PS：类似与数据结构中图的深度优先遍历形成一个连通图。而不在连通图中的节点就会被释放。</p><p><img src="https://howlcn1997.github.io/2019/05/12/%E7%AE%80%E8%BF%B0JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95.gif" srcset="/study.github.io/img/loading.gif" alt="标记清除法"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度优先广度优先遍历DOM</title>
    <link href="/study.github.io/2018/10/13/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DOM/"/>
    <url>/study.github.io/2018/10/13/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先与广度优先遍历DOM-递归与非递归"><a href="#深度优先与广度优先遍历DOM-递归与非递归" class="headerlink" title="深度优先与广度优先遍历DOM(递归与非递归)"></a>深度优先与广度优先遍历DOM(递归与非递归)</h1><p>若存在以下的DOM树结构我们改如何遍历所有的DOM节点;</p><pre><code>&lt;div id=&quot;root&quot;&gt;    &lt;div&gt;        &lt;p&gt;            &lt;span&gt;&lt;/span&gt;        &lt;/p&gt;        &lt;h1&gt;        &lt;/h1&gt;        &lt;div&gt;            &lt;p&gt;                &lt;span&gt;&lt;/span&gt;            &lt;/p&gt;            &lt;p&gt;                &lt;span&gt;&lt;/span&gt;            &lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;div&gt;            &lt;span&gt;                &lt;p&gt;                    &lt;input type=&quot;text&quot;&gt;                &lt;/p&gt;            &lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div&gt;            &lt;input type=&quot;text&quot;&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h2 id="方法一：深度优先遍历算法"><a href="#方法一：深度优先遍历算法" class="headerlink" title="方法一：深度优先遍历算法"></a>方法一：深度优先遍历算法</h2><p><strong>什么是深度优先算法？</strong></p><p>这里以二叉树为例</p><p>若有二叉树</p><p><img src="https://howlcn1997.github.io/2019/05/11/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DOM-%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92/%E4%BA%8C%E5%8F%89%E6%A0%91.png" srcset="/study.github.io/img/loading.gif" alt="二叉树"></p><p>深度优先遍历的结果：1 2 4 7 8 3 5 6 9 （若要深入了解，请自行百度”二叉树” “数据结构 图” “c语言 数据结构 深度优先遍历算法”）</p><p>根据此算法编写JS代码</p><h3 id="递归实现深度优先遍历"><a href="#递归实现深度优先遍历" class="headerlink" title="递归实现深度优先遍历"></a>递归实现深度优先遍历</h3><pre><code>var nodes = [];function DFS(node){    var child = node.children;    if(child){        for(var i = 0; i &lt; child.length;i++){            nodes.push(child[i]);            child[i].children &amp;&amp; DFS(child[i]);        }    }    else return;}var root = document.getElementById(&#39;root&#39;);DFS(document.getElementById(&#39;root&#39;));console.log(nodes);</code></pre><p>递归实现深度优先遍历代码优化</p><pre><code>var nodes = [];function DFS(node){    if(node){        nodes.push(node);        for(var i = 0;i &lt; node.children.length;i++)            DFS(node.children[i]);    }}var root = document.getElementById(&#39;root&#39;);DFS(root);console.log(nodes);</code></pre><p>闭包封装DFS</p><pre><code>function DFS(node){    var nodes = [];    function fn(node){        if(node){            nodes.push(node);            for(var i = 0;i &lt; node.children.length;i++)            fn(node.children[i]);        }    }    fn(node);    return nodes;}var root = document.getElementById(&#39;root&#39;);console.log(DFS(root));</code></pre><h3 id="非递归实现深度优先遍历"><a href="#非递归实现深度优先遍历" class="headerlink" title="非递归实现深度优先遍历"></a>非递归实现深度优先遍历</h3><pre><code>function DFS(node){    var nodes = [];//记录遍历到的节点    if(node){        var stark = [];//栈        stark.push(node);        while(stark.length){ //若栈不为空则一直出栈            var temp = stark.pop();            nodes.push(temp);            if(temp.children)                // for(var i = 0;i &lt; temp.children.length;i++) //此法导致nodes中的元素顺序与页面上的顺序是相反的                for(var i = temp.children.length-1;i &gt;= 0 ;i--)                    stark.push(temp.children[i]);//进栈            else continue;        }    }    return nodes;}   var root = document.getElementById(&#39;root&#39;);console.log(DFS(root));</code></pre><h2 id="方法二：广度优先遍历算法"><a href="#方法二：广度优先遍历算法" class="headerlink" title="方法二：广度优先遍历算法"></a>方法二：广度优先遍历算法</h2><p>广度优先遍历二叉树结果:1 2 3 4 5 6 7 8 9（若要深入了解，请自行百度”二叉树” “数据结构 图” “c语言 数据结构 广度优先遍历算法”）</p><p>根据此算法编写JS代码</p><h3 id="递归实现广度优先算法"><a href="#递归实现广度优先算法" class="headerlink" title="递归实现广度优先算法"></a>递归实现广度优先算法</h3><pre><code>//最近头发掉的多了  懂的自然懂</code></pre><h3 id="非递归实现广度优先算法"><a href="#非递归实现广度优先算法" class="headerlink" title="非递归实现广度优先算法"></a>非递归实现广度优先算法</h3><pre><code>function BFS(node){    var nodes = [];//记录获取到的节点    if(node){        var queue  = [];        queue.push(node); //进队        while(queue.length){  //只要队列不为空 就让其出队            var temp = queue.shift();            nodes.push(temp);            if(temp.children)                for(var i = 0;i &lt; temp.children.length;i++)                    queue.push(temp.children[i]);            else continue;        }    }    return nodes;}var root = document.getElementById(&#39;root&#39;);console.log(BFS(root));</code></pre><p>到此，已用JS代码实现深度优先 广度优先算法，若有更好，效率更高的解决办法，欢迎与我讨论。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue中路由跳转view不更新的问题及解决办法</title>
    <link href="/study.github.io/2018/10/10/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%ACview%E4%B8%8D%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/study.github.io/2018/10/10/Vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%ACview%E4%B8%8D%E6%9B%B4%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="vue中路由跳转view却不更新的问题与解决办法"><a href="#vue中路由跳转view却不更新的问题与解决办法" class="headerlink" title="vue中路由跳转view却不更新的问题与解决办法"></a>vue中路由跳转view却不更新的问题与解决办法</h1><p>一般情况下路由从<code>/myrouter</code>跳转至<code>/yourrouter</code>时，view会发生更新。</p><pre><code>若遇到/products/:id这样只改变id号的场景。就不会发生更新</code></pre><p>情况如下：</p><pre><code>router.js{    path: &quot;/products/:id&quot;,    name: &quot;product&quot;,    components: Product}</code></pre><p>现在路由<code>/products/:id</code>对应一个组件<code>Product.vue</code>,组件中有</p><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;test1&lt;/h1&gt;        &lt;p&gt;msg: {{msg}}&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    mounted(){        this.init(this.$router.history.current.params.id);    }，    methods:{        init(id){            this.msg = this.$router.history.current.params.id;        }    }&lt;/script&gt;</code></pre><p>为什么上述情况会导致view不更新呢？</p><pre><code>答：由于router-view是复用的，单纯的改变id号并不会刷新router-view。追根揭底就是因为data没有变化，只要路由跳转时触发 init() 函数来改变data就可以了。</code></pre><p>解决办法：</p><ol><li><p>用 :key 来阻止“复用”</p><p>在父组件中使用</p><pre><code>&lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;computed: {    key() {        return this.$route.name !== undefined? this.$route.name +new Date(): this.$route +new Date()    }}</code></pre><p>这种办法实质上是让每次路由跳转时重新构建该组件，我们在它的生命周期中写一个打印语句就能看出来。</p></li><li><p>通过 watch 监听路由</p><p>在子组件中使用</p><pre><code>watch: { //通过watch来监听路由变化    &#39;$route&#39;: function () {        this.init(this.$router.history.current.params.id);    }}</code></pre></li><li><p>通过 <code>vue-router</code>的钩子函数 <code>beforeRouteEnter</code> <code>beforeRouteUpdate</code> <code>beforeRouteLeave</code></p><pre><code>beforeRouteEnter (to, from, next) {   // 在渲染该组件的对应路由被 confirm 前调用   // 不！能！获取组件实例 `this`   // 因为当钩子执行前，组件实例还没被创建},beforeRouteUpdate (to, from, next) {   // 在当前路由改变，但是该组件被复用时调用   // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，   // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。   // 可以访问组件实例 `this`},beforeRouteLeave (to, from, next) {   // 导航离开该组件的对应路由时调用   // 可以访问组件实例 `this`}</code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/study.github.io/2018/09/30/MongoDB/"/>
    <url>/study.github.io/2018/09/30/MongoDB/</url>
    
    <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><pre><code>//缓存---&gt;文件---&gt;关系型数据库//1.数据保存到内存：优点：1）读写非常快缺点：1）程序关闭导致数据丢失//2.数据保存到文件：优点：1）数据可以永久保存缺点：1）频繁地IO操作，效率不高！2）数据管理不方便。例如查询某个数据需要全部读取出来，再匹配。//3.数据保存到数据库软件：优点：1）数据永久保存下来2）数据管理非常方便。（例如查询非常快速和方便）</code></pre><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><pre><code>关系型数据库（Mysql和Oracle） ： 表和表、表和字段、数据和数据存在着关系优点:1.数据之间有关系，进行数据的增删改查的时候是非常方便的2.关系型数据库是有事务操作的，保证数据的完整性和一致性。缺点：1.因为数据和数据是有关系的，底层是运行了大量的算法。大量算法会降低系统的效率，会降低性能2.数据存在硬盘中，面对海量数据的增删改查的时候会显的无能为力，面对海量数据对数据进行维护变得非常的无力3.限制字段：比如现在数据库中已经有10万条数据了（在今天10万条都不算大数据），如果想从下一条数据开始增加一些字段，此时之前的10万条数据都需要一同被更改。SQL中，表的字段是不能自由更改的，不能某一个条目有一些字段，另外的条目的没有。适合处理一般量级的数据（银行转账和钱）Oracle，甲骨文公司的产品。 当前最流行应用最广泛的数据库软件。适合中大型，中大应用。SQL Server: 是微软公司的产品。window平台应用非常广泛。和c#，net平台兼容非常好。DB2： IBM公司的产品。MySQL: 开源组织的产品。甲骨文公司的产品。免费</code></pre><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><pre><code>非关系数据库的（redis和MangDB）。为了处理海量数据，非关系数据库设计之初就是为了替代关系型数据库的优点：1.数据维护在缓存中，海量数据的增删改查和维护和处理非常轻松2.非关系型数据库简单易部署，基本都是开源软件3.非关系型数据库存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，非常灵活缺点：1.数据和数据没有关系，他们之间就是单独存在的2.数据维护在内存中，当有海量数据的时候会非常占内存，而内存的价格会比较高适合处理海量数据，保证效率，不一定安全（统计数据，例如微博数据）MongoDBRedis</code></pre><h3 id="非关系型数据库的分类"><a href="#非关系型数据库的分类" class="headerlink" title="非关系型数据库的分类"></a>非关系型数据库的分类</h3><pre><code>键值类数据库 ： Redis列存储数据库  :  HBase文档类数据库  : MongoDB图形数据库  : Graph</code></pre><h3 id="mongoDB的介绍"><a href="#mongoDB的介绍" class="headerlink" title="mongoDB的介绍"></a>mongoDB的介绍</h3><pre><code>MongoDB是一个高性能、开源、无模式的文档型数据库，设计用于提供高性能、水平可扩性、高可用性和高级可查询性，为Web应用提供可扩展的高性能数据存储解决方案。MongoDB的名称取自单词”humogous”中间的几个字符，是很大、巨大的意思。该数据库由10gen公司开发并提供技术支持，它属于NoSQL数据库家族中的一员，在许多场景下可以用来替代传统关系型数据库或key/value存储方式。MongoDB的设计目标是高性能、可扩展、易部署、易使用，存储数据非常方便。其主要功能特性如下： (1) 面向集合存储，容易存储对象类型的数据。在MongoDB中数据被分组存储在集合中，集合类似RDBMS中的表，一个集合可以存储无限多的文档。 (2) 模式自由，采用无模式结构存储。在MongoDB里的集合中，存储的是无模式的文档，采用无模式存储数据是集合(Collection)区别于RDBMS中的表(Table)的一个重要特征。 (3) 支持完全索引，可以在任意属性上建立索引，包含内部对象。MongoDB的索引和RDBMS的索引基本一样，可以在指定属性、内部对象上创建索引以提高查询的速度。除此之外，MongoDB还可以提供创建基于地理空间的索引的能力。 (4) 支持查询。MongoDB支持丰富的查询操作，MongoDB几乎支持SQL中的大部分查询。 (5) 强大的聚合工具。MongoDB除了提供丰富的查询功能外，还提供强大的聚合工具，如count、group等，支持使用MapReduce完成复杂的聚合任务。 (6) 支持复制和数据恢复。MongoDB支持主从复制机制，可以实现数据备份、故障恢复、读扩展等功能。而基于副本集的复制机制提供了自动故障恢复的功能，确保了集群数据不会丢失。 (7) 使用高效的二进制数据存储，包括大型对象(如视频)。使用二进制格式存储，可以保存任何类型的数据对象。 (8) 自动处理分片，以支持云计算层次的扩展。MongoDB支持集群自动切分数据，对数据进行分片可以使集群存储更多的数据，实现更大的负载，也能保证存储的负载均衡。      https://cloud.tencent.com/developer/article/1138683(9) 支持Perl、PHP、Java、C# 、JavaScript、Ruby、C和C++语言的驱动程序，Mon提供了当前所有主流开发语言的数据库驱动包，开发人员使用任何一种主流开发语言都可以轻松编程，实现访问MongoDB数据库。 (10) 文件存储格式为BSON(JSON的一种拓展)。BSON是二进制格式JSON的简称，BSON支持文档和数组的嵌套。 (11) 可以通过网络远程访问MongoDB数据库。</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、安装mongodb数据库 下载链接</p><p> 注意 安装时不要勾选安装图形化界面。</p><p>2、安装NoSQLBooster for MongoDB</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、将mongodb安装目录下的bin路径，添加至系统环境变量path中</p><p>2、在c盘根目录下新建data文件夹，在data文件夹中新建db文件夹</p><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>在cmd下键入</p><pre><code>mongod --version</code></pre><p>若正确显示版本号，则安装配置成功</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1.启动MongoDB数据库 会默认使用C:/data/db作为数据存储目录，所以在使用mongod命令之前需要先在c盘中新建一个data目录，在data目录下新建db目录，才能启动成功</p><p>在cmd下键入</p><pre><code>mongod //启动数据库</code></pre><p>在cmd下键入</p><pre><code>mongod --datapath=数据存储目录    //修改mongoDB默认数据存储目录mongod –dbpath 数据存储目录  //启动</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>在cmd下键入</p><pre><code>mongo   //链接数据库exit    //断开链接</code></pre><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>在cmd下按下</p><pre><code>ctrl + c</code></pre><h2 id="mongo数据库操作"><a href="#mongo数据库操作" class="headerlink" title="mongo数据库操作"></a>mongo数据库操作</h2><h3 id="NoSQLBooster中mongode使用"><a href="#NoSQLBooster中mongode使用" class="headerlink" title="NoSQLBooster中mongode使用"></a>NoSQLBooster中mongode使用</h3><p>才使用mongo之前先给出常用命令</p><pre><code>show dbs        //显示所有的数据库use library       //使用某个数据库db                 //显示当前使用的数据库//向library中的books集合中插入一条数据 (虽然一开始没有library仓库和books集合，但是不妨碍我们使用)db.books.insertOne({&quot;name&quot;:&quot;tom&quot;})    show  collections    //显示当前library仓库下的所有集合db.books.find()   //显示igeek仓库下的books集合中的所有数据//再插入一条数据db.books.insertOne({&quot;name&quot;:&quot;kitty&quot;,&quot;age&quot;:18})db.books.find()  //删除数据库db.dropDatabase()//在当前数据库下创建集合db.createCollection(&quot;igeek&quot;)//删除当前仓库下的igeek集合db.igeek.drop()//插入文档db.igeek.insert({name:&quot;hello&quot;})//删除指定的文档数据db.igeek.remove({&#39;name&#39;:&#39;hello&#39;})//更新文档数据db.igeek.update(    {name:&quot;hello&quot;},    {$set:{name:&quot;xxx&quot;}},    {        //upsert:true 如果要更新的文档不存在会插入一条新的记录        upsert:true,        multi:true    })//根据id更新数据//save方法有更新和插入两种功能，到底是插入还是更新文档取决于save的参数。db.igeek.save({    &quot;_id&quot; : ObjectId(&quot;5c09f5deaf853bfb8a003425&quot;),    &quot;name&quot; : &quot;kkk&quot;,    &quot;tags&quot; : [            &quot;mongodb&quot;,            &quot;NoSQL&quot;    ],    &quot;likes&quot; : 110})</code></pre><p> <strong>新建链接</strong></p><pre><code>打开NoSQLBooster for MongoDB --&gt; connect --&gt; create --&gt; save &amp; connect</code></pre><p><img src="https://howlcn1997.github.io/2019/03/16/MongoDB/%E5%BB%BA%E7%AB%8B%E9%93%BE%E6%8E%A5.png" srcset="/study.github.io/img/loading.gif" alt="建立链接"></p><p><strong>创建一个数据库并写入一条文件</strong></p><pre><code>use library  //指定使用library数据库  此时db关键字就代表library了db.books.insertOne({&quot;name&quot;:&quot;红楼梦&quot;})  //向library数据库中的books集合新增一条数据</code></pre><p><strong>通过NoSQLBooster for MongoDB将文件内容写入数据库</strong></p><pre><code>//1.在桌面创建这个文件，JSON和JSON之间没有逗号：{&quot;uname&quot;:&quot;李灵黛&quot;,&quot;age&quot;:12,&quot;sex&quot;:&quot;男&quot;,&quot;provice&quot;:&quot;上海&quot;}{&quot;uname&quot;:&quot;柳辰飞&quot;,&quot;age&quot;:13,&quot;sex&quot;:&quot;女&quot;,&quot;provice&quot;:&quot;北京&quot;}{&quot;uname&quot;:&quot;江城子&quot;,&quot;age&quot;:17,&quot;sex&quot;:&quot;男&quot;,&quot;provice&quot;:&quot;广东&quot;}{&quot;uname&quot;:&quot;萧合凰&quot;,&quot;age&quot;:37,&quot;sex&quot;:&quot;女&quot;,&quot;provice&quot;:&quot;河北&quot;}{&quot;uname&quot;:&quot;西粼宿&quot;,&quot;age&quot;:16,&quot;sex&quot;:&quot;男&quot;,&quot;provice&quot;:&quot;广东&quot;}{&quot;uname&quot;:&quot;千湄&quot;,&quot;age&quot;:13,&quot;sex&quot;:&quot;女&quot;,&quot;provice&quot;:&quot;广东&quot;}{&quot;uname&quot;:&quot;林墨瞳&quot;,&quot;age&quot;:13,&quot;sex&quot;:&quot;女&quot;,&quot;provice&quot;:&quot;吉林&quot;}{&quot;uname&quot;:&quot;柳婵诗&quot;,&quot;age&quot;:14,&quot;sex&quot;:&quot;女&quot;,&quot;provice&quot;:&quot;河北&quot;}{&quot;uname&quot;:&quot;李念儿&quot;,&quot;age&quot;:19,&quot;sex&quot;:&quot;女&quot;,&quot;provice&quot;:&quot;广东&quot;}//2.运行命令导入数据$ mongoimport -d 仓库名 -c 集合名 C:\Users\Danny\Desktop\1.txt-d参数表示需要往哪个数据库中导入数据-c 参数表示需要往哪个集合(表)中导入数据</code></pre><p>在NoSQLBooster for MongoDB中输入命令可以对数据库进行操作，此处不加赘述，仅介绍通过node如何对数据库进行增删改查操作</p><h3 id="node中mongo的使用"><a href="#node中mongo的使用" class="headerlink" title="node中mongo的使用"></a>node中mongo的使用</h3><p> node中对mongo数据库的操作需要用到 mongoose包</p><p> mongoose关于Model给出的关于操作数据的常用API</p><p>首先要创建Model对象，如obb,具体创建过程，下文有述</p><pre><code>/////////////////////////////////增 将obb数据对象添加到集合中obb.save().then(function(data){    //回调刚刚保存的数据对象})//当一个页面发出post保存表单数据到数据库中时的操作router.post(&#39;/add&#39;,(req,res)=&gt;{    //添加id    req.body._id = mongoose.Types.ObjectId();    //声明一个Student Model    let stu = new Student();    //将表单数据浅拷贝到stu Model对象中    Object.assign(stu,req.body);    //保存    stu.save().then(function(){        res.redirect(&#39;/student/studentList&#39;);    },function(err){        res.render(&#39;studentAdd.html&#39;,{err_msg:err.message})    });});/////////////////////////////////删Book.remove({name:&quot;红楼梦&quot;}).then(function(msg){    //回调刚刚删除的数据对象})/////////////////////////////////改//new 默认为false 返回修改之前的数据     true返回修改之后的数据Book.findByIdAndUpdata(_id,{要加入数据库的对象},{new:true}).then(function(data){});/////////////////////////////////查Book.find();//查询所有数据//Book.find().then(function(data){});//中返回的data是封装过的对象，我们要的数据其实是data._docBook.find({ name: &#39;红楼梦&#39;, price: { $gte: 20 }}); //加入查询条件  与Book.find({$or:[{name:&#39;三国演义&#39;},{price:{$gte:20}}]); //加入查询条件  或Book.findOne(条件);          Book.findById();</code></pre><h4 id="1、新建node项目（文件夹）"><a href="#1、新建node项目（文件夹）" class="headerlink" title="1、新建node项目（文件夹）"></a>1、新建node项目（文件夹）</h4><h4 id="2、在项目中安装第三方包-mongoose"><a href="#2、在项目中安装第三方包-mongoose" class="headerlink" title="2、在项目中安装第三方包 mongoose"></a>2、在项目中安装第三方包 mongoose</h4><pre><code>npm init -ynpm install mongoose</code></pre><h4 id="3-新建js文件（如server-js）"><a href="#3-新建js文件（如server-js）" class="headerlink" title="3.新建js文件（如server.js）"></a>3.新建js文件（如server.js）</h4><h5 id="1）引入mongoose"><a href="#1）引入mongoose" class="headerlink" title="1）引入mongoose"></a>1）引入mongoose</h5><pre><code>const mongoose = require(&#39;mongoose&#39;)；</code></pre><h5 id="2）建立连接"><a href="#2）建立连接" class="headerlink" title="2）建立连接"></a>2）建立连接</h5><pre><code>//mongoose.connect(&#39;mongodb://域名/数据库名&#39;, {useNewUrlParser: true});mongoose.connect(&#39;mongodb://localhost:27017/library&#39;, {useNewUrlParser: true});</code></pre><h5 id="3）连接对象的回调"><a href="#3）连接对象的回调" class="headerlink" title="3）连接对象的回调"></a>3）连接对象的回调</h5><pre><code>var db = mongoose.connection;//拿到链接对象db.on(&#39;error&#39;, console.error.bind(console, &#39;connection error:&#39;));//db.once(&#39;open&#39;, function() {  // we&#39;re connected!});</code></pre><h5 id="4-创建一个schema"><a href="#4-创建一个schema" class="headerlink" title="4)创建一个schema"></a>4)创建一个schema</h5><p>这个schema是与数据库中表的schema是一一对应的</p><p><strong>这种机制是ORM object relational model 对象关系映射模型</strong></p><pre><code>var bookSchema = new mongoose.Schema({  name: String  //是否全部借出   isLendAll: Boolean});</code></pre><p>schema数据类型除了String类型 还有以下几种</p><pre><code>• String• Number• Date• Boolean• Buffer   //流，音频 视频等文件可以由此保存• ObjectId  // 使用  mongoose.Schema.Types.ObjectId• Mixed   //混合数据格式  使用  mongoose.Schema.Types.Mixed• Array</code></pre><p>schema数据字段中还可以更细化的限制其取值，例：</p><pre><code>var bookSchema = new mongoose.Schema({    name: {        type: String,        minlength: 1,//规定字符串最小长度        maxlenght:10 //规定字符串最大长度        match:   //限定字符串格式，正则表达式    }String    price: {    type: Number,    min: 0, //限定最小值    max: 100 //限定最大值}    //是否全部借出    isLendAll:{    type: Boolean,    enum: [0,1],  //枚举 用数据限定isLendAll可以取到的值    default: 0   //默认值}});</code></pre><h5 id="5-新建一个model对象"><a href="#5-新建一个model对象" class="headerlink" title="5)新建一个model对象"></a>5)新建一个model对象</h5><p>此时 Book对象 与 数据库中books集合形成一一对应关系，对Book的操作，便是对集合books的操作，接下来的操作都是建立在此基础上的。</p><pre><code>var Book = mongoose.model(&#39;book&#39;, bookSchema); //注意此处创建对象时，model中入参 &#39;book&#39; 时，那么数据库中对应的集合应该以 books 命名，不然无法对响应表进行操作</code></pre><h5 id="查询一条数据"><a href="#查询一条数据" class="headerlink" title="查询一条数据"></a>查询一条数据</h5><pre><code>Book.find({name: &#39;红楼梦&#39;},function(err,arr){      if(err){        return;    }else{        console.log(arr);    }});//打印结果 [ { _id: 5cf3c3f19cad171ee8e202ca, name: &#39;红楼梦&#39; } ]//是一个数组  就算只有一条数据 最后得到的数据也是数组</code></pre><h5 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h5><pre><code></code></pre><p>最后更新： 2019年09月02日 11:07</p><p>原始链接： <a href="https://howlcn1997.github.io/2019/03/16/MongoDB/" target="_blank" rel="noopener">https://HowlCN1997.github.io/2019/03/16/MongoDB/</a></p><p><a href="https://howlcn1997.github.io/" target="_blank" rel="noopener"><img src="https://howlcn1997.github.io/images/logo.png" srcset="/study.github.io/img/loading.gif" alt="HowlCN">HowlCN</a></p><p><a href="javascript:;">赏</a></p><p><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#MongoDB" target="_blank" rel="noopener">MongoDB</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#关系型数据库" target="_blank" rel="noopener">关系型数据库</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#非关系型数据库" target="_blank" rel="noopener">非关系型数据库</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#非关系型数据库的分类" target="_blank" rel="noopener">非关系型数据库的分类</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#mongoDB的介绍" target="_blank" rel="noopener">mongoDB的介绍</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#安装" target="_blank" rel="noopener">安装</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#配置" target="_blank" rel="noopener">配置</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#检测" target="_blank" rel="noopener">检测</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#启动" target="_blank" rel="noopener">启动</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#链接" target="_blank" rel="noopener">链接</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#关闭" target="_blank" rel="noopener">关闭</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#mongo数据库操作" target="_blank" rel="noopener">mongo数据库操作</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#NoSQLBooster中mongode使用" target="_blank" rel="noopener">NoSQLBooster中mongode使用</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#node中mongo的使用" target="_blank" rel="noopener">node中mongo的使用</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#1、新建node项目（文件夹）" target="_blank" rel="noopener">1、新建node项目（文件夹）</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#2、在项目中安装第三方包-mongoose" target="_blank" rel="noopener">2、在项目中安装第三方包 mongoose</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#3-新建js文件（如server-js）" target="_blank" rel="noopener">3.新建js文件（如server.js）</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#1）引入mongoose" target="_blank" rel="noopener">1）引入mongoose</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#2）建立连接" target="_blank" rel="noopener">2）建立连接</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#3）连接对象的回调" target="_blank" rel="noopener">3）连接对象的回调</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#4-创建一个schema" target="_blank" rel="noopener">4)创建一个schema</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#5-新建一个model对象" target="_blank" rel="noopener">5)新建一个model对象</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#查询一条数据" target="_blank" rel="noopener">查询一条数据</a><a href="https://howlcn1997.github.io/2019/03/16/MongoDB/#新增数据" target="_blank" rel="noopener">新增数据</a></p><p>[vue中路由跳转view却不更新的问题与解决办法](<a href="https://howlcn1997.github.io/2019/05/05/vue中路由跳转" target="_blank" rel="noopener">https://howlcn1997.github.io/2019/05/05/vue中路由跳转</a> view不发生更新的问题/)<a href="https://howlcn1997.github.io/2019/03/15/MySQL/" target="_blank" rel="noopener">MySQL</a></p><p>总访客数：117 总访问量：717</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>h5</title>
    <link href="/study.github.io/2018/09/28/h5/"/>
    <url>/study.github.io/2018/09/28/h5/</url>
    
    <content type="html"><![CDATA[<h1 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h1><h2 id="HTML接口"><a href="#HTML接口" class="headerlink" title="HTML接口"></a>HTML接口</h2><p>1、监听网络状态接口（只在移动端起作用）</p><pre><code>//online 网络连接事件window.add//offline 网络链接事件</code></pre><p>2、全屏接口</p><pre><code>//请求全屏(操作对象是DOM元素)if(DOM.requestFullScreen){    DOM.requestFullScreen();}else if(DOM.webkitRequestFullScreen){    DOM.webkitRequestFullScreen();}else if(DOM.mozRequestFullScreen){    DOM.mozRequestFullScreen();}else if(DOM.msRequestFullScreen){    DOM.msRequestFullScreen();}//退出全屏(操作对象是document)if(document.cancelFullScreen){    document.cancelFullScreen();}else if(document.webkitCancelFullScreen){    document.webkitCancelFullScreen();}else if(document.mozCancelFullScreen){    document.mozCancelFullScreen();}else if(document.msCancelFullScreen){    document.msCancelFullScreen();}//是否是全屏状态(操作对象是document)if(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement){    console.log(&#39;true&#39;); //全屏}else{    console.log(&#39;false&#39;);//非全屏}</code></pre><p>3、文件读取接口</p><pre><code>&lt;body&gt;    &lt;input type=&quot;file&quot; id=&quot;subfile&quot;&gt;    &lt;img src=&quot;&quot; id=&quot;img&quot;&gt;&lt;/body&gt;var img = document.getElementById(&#39;img&#39;);var file = document.getElementById(&#39;subfile&#39;);//onchange 当file input内容发生改变时触发file.onchange = function(){    //创建一个文件读取对象    var reader = new FileReader();    if (this.files &amp;&amp; this.files.length &gt; 0) {        //读取上文头像的数据        reader.readAsDataURL(this.files[0]);        //数据读取成功之后回调函数        reader.onload = function(){            img.src = reader.result        }        //读取文件错误        reader.onerror = function(){            console.log(&#39;读取文件错误&#39;);        }        //读取的进度        reader.onprogress=function(e){            var percent = e.loaded/e.total*100+&quot;%&quot;;            console.log(percent);        }    }    }</code></pre><p>4、拖拽接口</p><pre><code>//作用于被拖动元素的    //ondragstart  拖动开始    //ondragend    拖动结束    //ondrag       拖动过程中    //作用于目标元素的    //ondragenter   进入目标元素    //ondragleave   移开目标元素    //ondragover    在目标元素上移动。要在这个方法中阻止默认时间，ondrop方法才会执行    //ondrop        在目标元素上丢下    //向剪切板中存了一条数据（key是element，值是被拖动元素的id信息）e.dataTransfer.setData(&quot;element&quot;,e.target.id);//从剪切板中获取数据var id = e.dataTransfer.getData(&quot;element&quot;);</code></pre><p>例子</p><pre><code>&lt;body&gt;    &lt;div id=&quot;box1&quot;&gt;        &lt;p id=&quot;p1&quot;&gt;xxxxxxxxxxx&lt;/p&gt;        &lt;p id=&quot;p2&quot;&gt;xxxxxxxxxxx&lt;/p&gt;    &lt;/div&gt;    &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;var p1 = document.getElementById(&#39;p1&#39;);var p2 = document.getElementById(&#39;p2&#39;);document.ondragstart = function(e){    //e.dataTransfer类似剪贴板 且只保存字符串形式的数据    e.dataTransfer.setData(&#39;ele&#39;,e.target.id);    // e.target.style.cursor = &#39;move&#39;; }document.ondragend = function(){}document.ondrag = function(e){}document.ondragenter = function(){}document.ondragleave = function(){}document.ondragover = function(e){    e.preventDefault();}//若要是ondrop生效 需要取消ondragover的默认操作document.ondrop = function(e){    var id = e.dataTransfer.getData(&#39;ele&#39;);    e.target.appendChild(document.getElementById(id));}</code></pre><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><pre><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;);   //以key来存储一条数据localStorage.getItem(&quot;key&quot;);        //以key来获取数据localStorage.removeItem(&quot;key&quot;);    //以key来移除数据localStorage. clear();              //清除localStorage中的内容</code></pre><h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、创建一个扩展名是appcache的文件，并进行配置，配置如下</p><pre><code>CACHE MANIFEST#上面一句代码必须是当前文档的第一句#后面写注释#需要缓存的文件清单列表CACHE:#下面就是需要缓存的清单列表../第1阶段HTML/img/三国演义.jpg../第1阶段HTML/img/水浒传.jpg../第1阶段HTML/img/红楼梦.jpg# *:代表所有文件#配置每一次都需要重新从服务器获取的文件清单列表NETWORK:../第1阶段HTML/img/西游记.jpg#配置如果文件无法通过网络获取该文件则使用指定的文件进行替代FALLBACK:../第1阶段HTML/img/西游记.jpg ../第1阶段HTML/img/1.PNG# /:代表所有文件</code></pre><p>2、在html页面中的标签中添加属性<strong>manifest=”demo.appcache”</strong></p><p>html文件如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;!--manifest=&quot;应用程序缓存清单文件的路径  建议文件的扩展名是appcache,这个文件的本质就是一个文本文件&quot;--&gt;&lt;html lang=&quot;en&quot; manifest=&quot;demo.appcache&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;style&gt;            img{                width: 100px;                display: block;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;img src=&quot;../第1阶段HTML/img/三国演义.jpg&quot;&gt;        &lt;img src=&quot;../第1阶段HTML/img/水浒传.jpg&quot;&gt;        &lt;img src=&quot;../第1阶段HTML/img/红楼梦.jpg&quot;&gt;        &lt;img src=&quot;../第1阶段HTML/img/西游记.jpg&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>3、运行</p><p>在vscode中安装 live server插件，安装完成后，右键选择Open with live server打开。</p><p>4、测试</p><p>f12 –&gt; Network –&gt; Offline</p><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><pre><code>video.paused   视频是否正在播放video.pause()   暂停视频播放video.play()     开始视频播放video.duration   获取视频的总时长video.currentTime  获取视频当前播放的时长//视频处于能够播放状态video.oncanplay = function(){}//视频播放过程中执行的回调函数video.ontimeupdate = function(){}//视频播放完毕video.onended = function(){}</code></pre><p>例子</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;        &lt;script src=&quot;./jquery-1.12.2.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;./common.js&quot;&gt;&lt;/script&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;style&gt;            body {                padding: 0;                margin: 0;                font-family: &#39;microsoft yahei&#39;, &#39;Helvetica&#39;, simhei, simsun, sans-serif;                background-color: #F7F7F7;            }            a {                text-decoration: none;            }            .playerTitle{                width:100%;                margin: 0 auto;                line-height:100px;                font-size: 40px;                text-align: center;            }            .player{                width: 720px;                height: 360px;                margin: 0 auto;                background: url(&quot;./images/loading.gif&quot;) center no-repeat;                background-size: cover;                position: relative;            }            video{                height:100%;                width: 100%;                margin: 0 auto;                display: none;            }            .controls {                width: 720px;                height: 40px;                position: absolute;                left: 0px;                bottom: -40px;                background-color: #000;            }            .controls &gt; .switch{                width: 20px;                height: 20px;                display: block;                font-size: 20px;                color: #fff;                position: absolute;                left: 10px;                top: 10px;            }            .controls &gt; .expand{                width: 20px;                height: 20px;                display: block;                font-size: 20px;                color: #fff;                position: absolute;                right: 10px;                top: 10px;            }            .controls &gt; .progress{                width: 430px;                height: 10px;                position: absolute;                left:40px;                bottom:15px;                background-color: #555;            }            .controls &gt; .progress &gt; .bar{                width:100%;                height:100%;                border-radius: 3px;                cursor: pointer;                position: absolute;                left: 0;                top: 0;                opacity: 0;                z-index: 999;            }            .controls &gt; .progress &gt; .elapse{                width:0%;                height:100%;                background-color: #fff;                border-radius: 3px;                position: absolute;                left: 0;                top: 0;                z-index: 3;            }            .controls &gt; .time{                height: 20px;                position: absolute;                left:490px;                top: 10px;                color: #fff;                font-size: 14px;            }        &lt;/style&gt;   &lt;body&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;./fonts/font-awesome.css&quot;&gt;        &lt;h3 class=&quot;playerTitle&quot;&gt;视频播放器&lt;/h3&gt;        &lt;div class=&quot;player&quot;&gt;            &lt;video src=&quot;./mp4/chrome.mp4&quot;&gt;&lt;/video&gt;            &lt;div class=&quot;controls&quot;&gt;                &lt;a href=&quot;javascript:;&quot; class=&quot;switch fa fa-play&quot;&gt;&lt;/a&gt;                &lt;a href=&quot;javascript:;&quot; class=&quot;expand fa fa-expand&quot;&gt;&lt;/a&gt;                &lt;div class=&quot;progress&quot;&gt;                    &lt;!--bar是透明的，主要作用用来控制拖动--&gt;                    &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt;                    &lt;!--elapse主要用来显示已经播放的进度--&gt;                    &lt;div class=&quot;elapse&quot;&gt;&lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;time&quot;&gt;                    &lt;span class=&quot;currentTime&quot;&gt;00:00:00&lt;/span&gt;                    \                    &lt;span class=&quot;totalTime&quot;&gt;00:00:00&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;            $(function(){                var video = $(&#39;video&#39;)[0];                var dur;                //屏幕点击播放或者暂停                $(video).click(function(){                    if(video.paused){                        video.play();                    }else{                        video.pause();                    }                    $(&#39;.switch&#39;).toggleClass(&#39;fa-play fa-pause&#39;);                });                //播放暂停按钮                $(&#39;.switch&#39;).click(function(){                    if(video.paused){                        video.play();                    }else{                        video.pause();                    }                    $(this).toggleClass(&#39;fa-play fa-pause&#39;);                });                //正在播放的处理                video.ontimeupdate = function(){                    //时长显示                    var cur = video.currentTime;                    $(&#39;.currentTime&#39;).text(getFormatStr(cur));                    //进度条显示                    var percent = cur/dur*100;                    console.log(percent);                    $(&#39;.elapse&#39;).css(&#39;width&#39;,percent+&#39;%&#39;);                }                //双击视频全屏                $(video).dblclick(function(){                    /*全屏&gt;&gt;不同浏览器需要添加不同的前缀&gt;&gt;能力测试*/                    if(video.requestFullScreen){                        video.requestFullScreen();                    }                    else if(video.webkitRequestFullScreen){                        video.webkitRequestFullScreen();                    }                    else if(video.mozRequestFullScreen){                        video.mozRequestFullScreen();                    }                    else if(video.msRequestFullScreen){                        video.msRequestFullScreen();                    }                });                //全屏                $(&quot;.expand&quot;).click(function(){                    /*全屏&gt;&gt;不同浏览器需要添加不同的前缀&gt;&gt;能力测试*/                    if(video.requestFullScreen){                        video.requestFullScreen();                    }                    else if(video.webkitRequestFullScreen){                        video.webkitRequestFullScreen();                    }                    else if(video.mozRequestFullScreen){                        video.mozRequestFullScreen();                    }                    else if(video.msRequestFullScreen){                        video.msRequestFullScreen();                    }                });                //视频加载完毕可以播放时 触发事件                video.oncanplay = function(){                    //多媒体总时长                    dur = video.duration;                    $(&#39;.totalTime&#39;).text(getFormatStr(dur));                    $(this).show();                }            })          &lt;/script&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="first-child-和-first-of-type"><a href="#first-child-和-first-of-type" class="headerlink" title="first-child 和 first-of-type"></a>first-child 和 first-of-type</h2><pre><code>/*找到P元素,通过P找到父元素，通过父元素找所有的子元素，找第一个元素，匹配判断类型(如果不是无效选择器)*/p:first-child{       background-color: red;}/*找到P元素，通过P找到父元素，通过父元素找子元素当中类型为P的，然再去找第几个*/p:first-of-type{       background-color: blue;}</code></pre><h2 id="伪类选择器与为元素选择器的区别"><a href="#伪类选择器与为元素选择器的区别" class="headerlink" title="伪类选择器与为元素选择器的区别"></a>伪类选择器与为元素选择器的区别</h2><p> css之后规定 伪类选择器为一个冒号: 元素选择器为两个冒号::</p><p><strong>伪类选择器</strong>之所以称作为伪类选择器，是因为作用域类选择器类似。</p><p> 可以认为，伪类选择器为指定元素以类选择器的方式设置样式。直接为当前元素设置样式。</p><p><strong>伪元素选择器</strong>实质上是临时给指定的内容外面包裹了一个元素(这个元素是无法知道的，下面我们以为例)。在对此元素增加样式。</p><p>如</p><pre><code>div::first-letter{  color:green;}&lt;div&gt;这是一个div&lt;/div&gt;&lt;!-- 经过伪元素选择器的修饰后 --&gt;&lt;div&gt;&lt;i style=&quot;color:green&quot;&gt;这&lt;/i&gt;是一个div&lt;/div&gt; &lt;!-- 实质上这个 i 元素我们是看不到的 --&gt;</code></pre><p>伪元素选择器</p><pre><code>::after::before::first-letter::first-line::selection::backdrop</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySql</title>
    <link href="/study.github.io/2018/09/23/MySql/"/>
    <url>/study.github.io/2018/09/23/MySql/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、确保已安装wamp并且启动成功"><a href="#1、确保已安装wamp并且启动成功" class="headerlink" title="1、确保已安装wamp并且启动成功"></a>1、确保已安装wamp并且启动成功</h2><p>详情请见<a href="https://howlcn.github.io/2019/05/12/wamp环境搭建/" target="_blank" rel="noopener">wamp环境搭建</a></p><h2 id="2、下载navicat-premium"><a href="#2、下载navicat-premium" class="headerlink" title="2、下载navicat premium"></a>2、下载navicat premium</h2><p>文件 -&gt; 新建连接</p><p>点击自己新建的链接，新建数据库 字符集uft8 排序规则utf8_bin</p><h2 id="3、在项目文件夹中安装mySQL"><a href="#3、在项目文件夹中安装mySQL" class="headerlink" title="3、在项目文件夹中安装mySQL"></a>3、在项目文件夹中安装mySQL</h2><pre><code>npm init -ynpm install mysqljs/mysql</code></pre><h2 id="4、在服务器js文件中使用mysql包"><a href="#4、在服务器js文件中使用mysql包" class="headerlink" title="4、在服务器js文件中使用mysql包"></a>4、在服务器js文件中使用mysql包</h2><h3 id="引入mysql包"><a href="#引入mysql包" class="headerlink" title="引入mysql包"></a>引入mysql包</h3><pre><code>const mysql = require(&#39;mysql&#39;);</code></pre><h3 id="创建数据库链接"><a href="#创建数据库链接" class="headerlink" title="创建数据库链接"></a>创建数据库链接</h3><pre><code>const connection = mysql.createConnection({    host: &#39;localhost&#39;, //数据库所在的服务器的域名（或ip地址）    user: &#39;me&#39;, //登录数据库的账号    password: &#39;secret&#39;, //登陆数据库的密码    database: &#39;book&#39; //数据库的名称});</code></pre><h3 id="执行链接操作"><a href="#执行链接操作" class="headerlink" title="执行链接操作"></a>执行链接操作</h3><pre><code>connection.connect();</code></pre><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>数据库的操作是异步的</p><pre><code>connection.query(&#39;数据库操作语句&#39;,function(error,results,fields){ //results 数据库语句执行完后的结果    if(error) throw error;    console.log(&#39;The solution is:&#39;,results[0].solution);})</code></pre><h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><pre><code>connection.end();</code></pre><h2 id="数据库常用语句"><a href="#数据库常用语句" class="headerlink" title="数据库常用语句"></a>数据库常用语句</h2><p>先给出代码大概框架</p><pre><code>const mysql = require(&#39;mysql&#39;);const connection = mysql.createConnection({    host: &#39;localhost&#39;, //数据库所在的服务器的域名（或ip地址）    user: &#39;root&#39;, //登录数据库的账号    password: &#39;&#39;, //登陆数据库的密码    database: &#39;book&#39; //数据库的名称});connection.connect();//此处开始进行数据库数据操作**********************之后的代码只有此处不同// ？ 是为了给后面的数据进行填充let sql = &#39;insert into book set ?&#39;;let data = {    name: &#39;百年孤独&#39;,    author: &#39;加西亚·马尔克斯&#39;};connection.query(sql,data,function(error,results,fields){ //results 数据库语句执行完后的结果 是个对象    if(error) throw error;    if(results.affectedRows == 1){        console.log(&#39;数据插入成功！&#39;);    }});//此处结束数据库数据操作************************connection.end();</code></pre><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><pre><code>// ？ 是为了给后面的数据进行填充let sql = &#39;insert into book set ?&#39;;let data = {    name: &#39;百年孤独&#39;,    author: &#39;加西亚·马尔克斯&#39;};connection.query(sql,data,function(error,results,fields){ //results 数据库语句执行完后的结果    if(error) throw error;    if(results.affectedRows == 1){        console.log(&#39;数据插入成功！&#39;);    }});</code></pre><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><pre><code>let sql = &#39;delete from book where id=?&#39;;let data = [2];connection.query(sql,data,function(error,results,fields){ //results 数据库语句执行完后的结果    if(error) throw error;    if(results.affectedRows == 1){        console.log(&#39;数据删除成功！&#39;);    }});</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code>let sql = &#39;update book set name=?,author=? where id=?&#39;;let data = [&#39;红楼梦&#39;,&#39;曹雪芹&#39;,2];connection.query(sql,data,function(error,results,fields){ //results 数据库语句执行完后的结果    if(error) throw error;    if(results.affectedRows == 1){        console.log(&#39;数据更新成功！&#39;);    }})</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code>//let sql = &#39;select * from book&#39;; // * 查询范围是全部数据//let data = null;let sql = &#39;select * from book where id = ?&#39;;  //从所有数据中查询id为？的数据let data = [1];connection.query(sql,data,function(error,results,fields){ //results 数据库语句执行完后的结果    if(error) throw error;    console.log(results[0].name);});</code></pre><p>不难发现对数据的增删改查在代码层面是类似的。</p><h3 id="封装对数据库的操作"><a href="#封装对数据库的操作" class="headerlink" title="封装对数据库的操作"></a>封装对数据库的操作</h3><p>新建一个db.js文件，此js中的代码如下</p><pre><code>const mysql = require(&#39;mysql&#39;);//当sql是插入操作时，data需要是一个对象//当sql是删改查时，data是一个数组数组中的数据与表中的字段顺序要一一对应exports.base = (sql,data,callback)=&gt;{    const connection = mysql.createConnection({        host: &#39;localhost&#39;,        user: &#39;root&#39;,        password: &#39;&#39;,        database: &#39;book&#39;    });    connection.connect();    connection.query(sql,data,function(error,results,fields){        if(error) throw error;        callback(results);    });    connection.end();}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React-Native的环境搭建</title>
    <link href="/study.github.io/2018/09/02/React-Native%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/09/02/React-Native%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Native-环境搭建"><a href="#React-Native-环境搭建" class="headerlink" title="React-Native 环境搭建"></a>React-Native 环境搭建</h1><p>声明：本人是在64位机上搭建的，32位机有所不同</p><h2 id="1、安装最新版本的-Java-JDK"><a href="#1、安装最新版本的-Java-JDK" class="headerlink" title="1、安装最新版本的 Java JDK"></a>1、安装最新版本的 Java JDK</h2><h2 id="2、安装Node-js环境"><a href="#2、安装Node-js环境" class="headerlink" title="2、安装Node.js环境"></a>2、安装Node.js环境</h2><p>传送门：<a href="https://howlcn.github.io/2018/01/01/HexoAndGit" target="_blank" rel="noopener">用Hexo和Git搭建github个人博客</a></p><h2 id="3、安装C-环境"><a href="#3、安装C-环境" class="headerlink" title="3、安装C++环境"></a>3、安装C++环境</h2><p>多数操作系统自带C++环境，react native运行时如有报无C++运行环境时，请手动安装visual studio中的C++环境</p><h2 id="4、安装Git环境"><a href="#4、安装Git环境" class="headerlink" title="4、安装Git环境"></a>4、安装Git环境</h2><p>传送门：<a href="https://howlcn.github.io/2018/01/01/HexoAndGit" target="_blank" rel="noopener">用Hexo和Git搭建github个人博客</a></p><h2 id="5、安装Python环境"><a href="#5、安装Python环境" class="headerlink" title="5、安装Python环境"></a>5、安装Python环境</h2><p>[下载](<a href="https://howlcn1997.github.io/2019/01/29/React-Native" target="_blank" rel="noopener">https://howlcn1997.github.io/2019/01/29/React-Native</a> 环境搭建/)</p><pre><code>注意：安装Python时候，只能**安装2.×的版本**，注意勾选安装界面上的`Add Python to path`，这样才能自动将Python安装到系统环境变量中；</code></pre><p>安装完毕之后，可以在命令行中运行<code>python</code>，检查是否成功安装了python。</p><h2 id="6、配置Android环境"><a href="#6、配置Android环境" class="headerlink" title="6、配置Android环境"></a>6、配置Android环境</h2><p>由于IOS环境搭建需要MAC，在此以Android为例</p><p>[下载](<a href="https://howlcn1997.github.io/2019/01/29/React-Native" target="_blank" rel="noopener">https://howlcn1997.github.io/2019/01/29/React-Native</a> 环境搭建/)</p><p>1、此压缩包已经安装好了必要的软件，解压到<code>c:/android</code>即可使用</p><p>2、在系统环境变量中新建<code>ANDROID_HOME</code>，值为android SDK Manager的安装路径<code>C:\android</code>，紧接着，在Path中新增<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;</code></p><p>若上面的压缩包不可用，解决步骤如下：</p><p>|—————-解决步骤开始—————-|</p><ol><li><p>下载配置android studio</p></li><li><p>初次启动android studio的时候配置proxy代理</p><pre><code>mirrors.neusoft.edu.cn:80点击clear passwords</code></pre></li></ol><p><img src="https://howlcn1997.github.io/2019/01/29/React-Native%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1562910885243.png" srcset="/study.github.io/img/loading.gif" alt="1562910885243"></p><p><img src="https://howlcn1997.github.io/2019/01/29/React-Native%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1562910917004.png" srcset="/study.github.io/img/loading.gif" alt="1562910917004"></p><p><img src="https://howlcn1997.github.io/2019/01/29/React-Native%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1562906726308.png" srcset="/study.github.io/img/loading.gif" alt="1562906726308"></p><p><img src="https://howlcn1997.github.io/2019/01/29/React-Native%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1562907136464.png" srcset="/study.github.io/img/loading.gif" alt="1562907136464"></p><p><img src="https://howlcn1997.github.io/2019/01/29/React-Native%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1562907475255.png" srcset="/study.github.io/img/loading.gif" alt="1562907475255"></p><p>|—————-解决步骤结束—————-|</p><h2 id="7、安装模拟器"><a href="#7、安装模拟器" class="headerlink" title="7、安装模拟器"></a>7、安装模拟器</h2><p>这里以夜神模拟器为例</p><ol><li>下载夜神模拟器并安装</li><li>将<code>C:\android\platform-tools\adb.exe</code>拷贝一份，重命名为<code>nox_adb.exe</code>，替换掉<code>D:\Program Files\Nox\bin</code>下的<code>nox_adb.exe</code>文件</li><li>打开夜神模拟器</li><li>使用<code>adb connect 127.0.0.1:62001</code>链接模拟器</li></ol><h2 id="8、使用ReactNative快速打包"><a href="#8、使用ReactNative快速打包" class="headerlink" title="8、使用ReactNative快速打包"></a>8、使用ReactNative快速打包</h2><h3 id="8-1、设置npm镜像"><a href="#8-1、设置npm镜像" class="headerlink" title="8.1、设置npm镜像"></a>8.1、设置npm镜像</h3><pre><code>npm config set registry https://registry.npm.taobao.org --global</code></pre><h3 id="8-2、安装Yarn、React-Native的命令行工具"><a href="#8-2、安装Yarn、React-Native的命令行工具" class="headerlink" title="8.2、安装Yarn、React Native的命令行工具"></a>8.2、安装Yarn、React Native的命令行工具</h3><pre><code>npm install -g yarn react-native-cli</code></pre><p>安装完毕后设置yarn镜像源</p><pre><code>yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global</code></pre><p>C:\Users\12037.gradle\wrapper\dists\gradle-5.4.1-all\3221gyojl5jsh0helicew7rwx`</p><h3 id="8-3、创建项目"><a href="#8-3、创建项目" class="headerlink" title="8.3、创建项目"></a>8.3、创建项目</h3><p>注意：所创建的项目路径中不能有中文！</p><pre><code>react-native init 项目名</code></pre><h3 id="8-4、打包编译安卓项目"><a href="#8-4、打包编译安卓项目" class="headerlink" title="8.4、打包编译安卓项目"></a>8.4、打包编译安卓项目</h3><p>在项目根目录下运行</p><pre><code>react-native run-android</code></pre><p>在打包编译时会下载<code>gradle-5.4.1-all.zip</code>速度会很慢，解决办法如下：</p><ol><li>下载<code>gradle-5.4.1-all.zip</code>压缩包 [下载](<a href="https://howlcn1997.github.io/2019/01/29/React-Native" target="_blank" rel="noopener">https://howlcn1997.github.io/2019/01/29/React-Native</a> 环境搭建/)</li><li>加压缩包放入<code>C:\Users\username\.gradle\wrapper\dists\gradle-5.4.1-all\3221gyojl5jsh0helicew7rwx</code>下</li></ol><p>完成以上步骤后再次运行<code>react-native run-android</code></p><p>过程中任然会下载资源，大约10分钟，网络不稳定的有可能中途下载失败并报错，不要灰心，再来一次。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6的语法学习</title>
    <link href="/study.github.io/2018/08/21/ES6%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/study.github.io/2018/08/21/ES6%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h1><p>ES6 = ECMAScript 6</p><h2 id="申明变量let和const"><a href="#申明变量let和const" class="headerlink" title="申明变量let和const"></a>申明变量let和const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h4 id="1、let申明变量不存在预解析；"><a href="#1、let申明变量不存在预解析；" class="headerlink" title="1、let申明变量不存在预解析；"></a>1、let申明变量不存在预解析；</h4><pre><code>console.log(flag);let flag = 123;//结果：报错</code></pre><h4 id="2、let声明的变量不允许重复"><a href="#2、let声明的变量不允许重复" class="headerlink" title="2、let声明的变量不允许重复"></a>2、let声明的变量不允许重复</h4><pre><code>let flag = 123;let flag = 456;console.log(flag);</code></pre><h4 id="3、ES6引入了块级作用域"><a href="#3、ES6引入了块级作用域" class="headerlink" title="3、ES6引入了块级作用域"></a>3、ES6引入了块级作用域</h4><p>块内部定义的变量，在外部无法访问(PS: 只要被 { } 包裹起来，就形成块级作用域)</p><pre><code>if (true){    let flag = 123;}console.log(flag);</code></pre><h4 id="4、let必须先声明在使用"><a href="#4、let必须先声明在使用" class="headerlink" title="4、let必须先声明在使用"></a>4、let必须先声明在使用</h4><p>因为用let申明的变量没有预解析</p><pre><code>tem = 123;let tem;  //报错</code></pre><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const声明的常量不能被重新赋值，且在申明的同时就要被初始化</p><pre><code>const n = 1;//申明的同时就要初始化n = 2;//此处报错</code></pre><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><pre><code>// var a =1,b=2,c=3;//js中的写法let [a,b,c] = [1,2,3];//node中 数组的解构赋值console.log(a,b,c);// 1 2 3//声明时赋初值let [a=123,b,c] = [,456,];console.log(a,b,c);// 123 456 undefined</code></pre><p>利用解构赋值交换两个变量的值</p><pre><code>let a = 1;let b = 2;[a, b] = [b, a];console.log(a,b);// 2 1</code></pre><p>对象的解构赋值</p><pre><code>let {foo,bar} = {foo : &#39;hello&#39;,bar : &#39;hi&#39;};console.log(foo,bar);</code></pre><p>字符串的解构赋值</p><pre><code>let [a,b,c,d,e] = &quot;hello&quot;;console.log(a,b,c,d,e);//h e l l o</code></pre><h2 id="字符串相关扩展"><a href="#字符串相关扩展" class="headerlink" title="字符串相关扩展"></a>字符串相关扩展</h2><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>include(str [,index]) str 所要匹配的字符串 ； index 从什么位置开始匹配</p><pre><code>console.log(&#39;hello world&#39;.includes(&#39;world&#39;);//trueconsole.log(&#39;hello world&#39;.includes(&#39;world&#39;,7);//false</code></pre><h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h3><p>判断字符串是否特定字符串开始</p><pre><code>console.log(&#39;admin/index.php&#39;.startsWith(&#39;admin&#39;));// true</code></pre><h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h3><p>判断字符串是否特定字符串结束</p><pre><code>console.log(&#39;admin/index.php&#39;.startsWith(&#39;php&#39;));// true</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>在js中若要拼接字符串</p><pre><code>var obj = {    name:&#39;张三&#39;,    age:13,    gender:&#39;男&#39;}var str = &#39;&lt;div&gt;&lt;span&gt;&#39;+obj.name+&#39;&lt;/span&gt;&lt;span&gt;&#39;+obj.age+&#39;&lt;/span&gt;&lt;span&gt;&#39;+obj.gender+&#39;&lt;/span&gt;&lt;/div&gt;&#39;;console.log(str);//&lt;div&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;/div&gt;</code></pre><p>利用模板字符串进行拼接</p><pre><code>let obj = {    name:&#39;张三&#39;,    age:13,    gender:&#39;男&#39;}let str = &#39;&lt;div&gt;                &lt;span&gt;${obj.name}&lt;/span&gt;                &lt;span&gt;${obj.age}&lt;/span&gt;                &lt;span&gt;${obj.gender}&lt;/span&gt;               &lt;span&gt;${1+1}&lt;/span&gt;               &lt;span&gt;${fn(&#39;你好&#39;)}&lt;/span&gt;          &lt;/div&gt;&#39;;console.log(str);//&lt;div&gt;//    &lt;span&gt;张三&lt;/span&gt;//    &lt;span&gt;13&lt;/span&gt;//    &lt;span&gt;男&lt;/span&gt;//      &lt;span&gt;2&lt;/span&gt;//      &lt;span&gt;你好&lt;/span&gt;//&lt;/div&gt;</code></pre><h2 id="函数的相关扩展"><a href="#函数的相关扩展" class="headerlink" title="函数的相关扩展"></a>函数的相关扩展</h2><p>1、参数的默认值</p><p>2、参数的解构赋值</p><p>3、rest参数</p><p>4、…扩展运算符</p><p>5、箭头函数</p><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>在js中的若要给函数参数指定默认值</p><pre><code>function foo(param){    let p = param || &#39;hello&#39;;    console.log(p);}//foo();//foo(&#39;nihao&#39;);</code></pre><p>在ES6中给函数参数指定默认值</p><pre><code>function foo(param = &#39;hello&#39;){    console.log(p);}//foo();//foo(&#39;nihao&#39;);</code></pre><h3 id="参数的解构赋值"><a href="#参数的解构赋值" class="headerlink" title="参数的解构赋值"></a>参数的解构赋值</h3><p>默认参数的做法</p><pre><code>function foo(param = &#39;hello&#39; , age = 12){    console.log(param,age);}//foo();//foo(&#39;nihao&#39;,18);</code></pre><p>参数的解构赋值的做法</p><pre><code>function foo({param,age}}){    console.log(param,age);}//foo({});  //注意 此时一定要传入一个对象//添加默认参数function foo({param = &#39;hello&#39;,age = 12}}){    console.log(param,age);}//foo({});  //注意 此时一定要传入一个对象//foo({param = &#39;nihao&#39;,age = 18})</code></pre><h3 id="rest参数（剩余参数）"><a href="#rest参数（剩余参数）" class="headerlink" title="rest参数（剩余参数）"></a>rest参数（剩余参数）</h3><pre><code>function foo(a,b,...param){ //...param会以数组的形式存储剩余的参数    console.log(param);}foo(1,2,3,4,5,6,7);//[3,4,5,6,7]</code></pre><h3 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h3><p>使用 … 将数组拆撒后入参</p><pre><code>function foo(a,b,c,d){    console.log(a + b + c + d);}//foo(1,2,3,4);//传统调用方式//当要传入一个数组时 arr = [1,2,3,4]//方法一 使用foo.apply(null,arr);//方法二 使用 ...   将数组拆散foo(...arr); //10</code></pre><p>使用 … 合并数组</p><pre><code>let arr1 = [1,2,3];let arr2 = [4,5,6];let arr3 = [...arr1,...arr2];console.log(arr3);//[1,2,3,4,5,6]</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><pre><code>//传统函数声明以及调用function foo(参数列表){    函数体}foo();//ES6 中新增的函数申明以及调用  =&gt;let foo = (形参参数列表) =&gt; {函数体};foo(实参列表);//用处 例子var arr = [1,2,3,4];//arr.forEach(function(e,index){//    console.log(e);//      console.log(index);//});arr.forEach((e,index) =&gt; {console.log(e);console.log(index)});</code></pre><p>箭头函数的注意事项</p><p>1、箭头函数中this取决于函数的定义，而不是函数的调用</p><pre><code>//不使用箭头函数时 this取决于调用者  此时是windowvar obj = {    name:&quot;张三&quot;,    doSomething: function(){        setTimeout(function(){            console.log(this);        },1000);    }}obj.doSomething();//window//使用箭头函数中的this 取决函数声明的环境 此时是在obj中声明的  则this指向objvar obj = {    name:&quot;张三&quot;,    doSomething: function(){        setTimeout(()=&gt;{            console.log(this);        },1000);    }}obj.doSomething();//obj{name:&quot;张三&quot;}</code></pre><p>2、箭头参数不可以new</p><p>3、箭头函数不可以使用arguments获取参数列表，可以使用rest代替</p><pre><code>let foo = (...param) =&gt; console.log(param);foo(1,2,3,4);</code></pre><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><pre><code>let a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].keys(); //Array.keys()  返回数组的所有下标[0,1,2]console.log(a.next());  //迭代返回当前位置的下标 0console.log(a.next());  //1console.log(a.next());  //2let b = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].values(); //Array.values()  返回数组的所有值console.log(b.next());  //迭代返回当前位置的值  aconsole.log(b.next());  //bconsole.log(b.next());  //c//数组查找{    console.log([1,2,3,4,5,6].find((item)=&gt;{  //find 返回满足条件的第一个元素值        return item&gt;3;    }));    console.log([1,2,3,4,5,6].filter((item)=&gt;{  //filter 返回满足条件的所有元素值        return item&gt;3;    }));    console.log([1,2,3,4,5,6].findIndex((item)=&gt;{ //findIndex 返回满条件的第一个元素下标        return item&gt;3;    }));}//数组包含{    let arr = [123,456,7,8,9,NaN];    console.log(arr.includes(456));//Array.includes(item);在数组中查询有无item元素 返回boolean    //也可以查询有无非数字    console.log([1,2,NaN].includes(1));    console.log([1,2,NaN].includes(NaN));}</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6新增数据类型 属于基本数据类型，Symbol不可以new</p><p>Symbol声明的变量是唯一的，意义在于减少命名冲突；</p><pre><code>{    //Symbol的变量是唯一的，所以a1和a2永远不相等    let a1 = Symbol();    let a2 = Symbol();    console.log(a1 === a2);   //Symbol.for(key)   //在使用Symbol时  会生成一个全局注册表，其中的数据以键值对的形式存在；能根据key来拿到对应的value   //若  a3  a4的key是相同的  那么a3 a4是相同的    let a3 = Symbol.for(&quot;a3&quot;);    let a4 = Symbol.for(&quot;a3&quot;);    console.log(a3 === a4);  //true    //问题  若改变a3的值  a4的值会改变吗？    //是值复制   还是指针}</code></pre><h2 id="ES6中涉及到的数据结构"><a href="#ES6中涉及到的数据结构" class="headerlink" title="ES6中涉及到的数据结构"></a>ES6中涉及到的数据结构</h2><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><p>数组中的元素可以重复，且数组中元素的排列是有序的（因此可以通过下标访问）</p><h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><p>集合的元素是唯一的，不可以重复出现，且集合中的元素是无序的（因此无法通过下标访问集合中的元素）</p><h4 id="Set中的方法"><a href="#Set中的方法" class="headerlink" title="Set中的方法"></a>Set中的方法</h4><table><thead><tr><th align="center"><strong>set.add(ele)</strong></th><th align="center"><strong>向set集合中追加ele元素</strong></th></tr></thead><tbody><tr><td align="center"><strong>set.has(ele)</strong></td><td align="center"><strong>判断set集合中是否存在ele元素</strong></td></tr><tr><td align="center"><strong>set.delete(ele)</strong></td><td align="center"><strong>从集合中删除ele元素</strong></td></tr><tr><td align="center"><strong>set.clear()</strong></td><td align="center"><strong>清空set集合</strong></td></tr><tr><td align="center"><strong>set.forEach( (ele) =&gt;{} )</strong></td><td align="center"><strong>遍历集和</strong></td></tr></tbody></table><p>set对象的创建：</p><pre><code>let set = new set();</code></pre><h3 id="数组与集合的互相转换"><a href="#数组与集合的互相转换" class="headerlink" title="数组与集合的互相转换"></a>数组与集合的互相转换</h3><h4 id="数组-gt-集合"><a href="#数组-gt-集合" class="headerlink" title="数组==&gt;集合"></a>数组==&gt;集合</h4><pre><code>let arr = [1,2,3];let set = new set(arr);</code></pre><h4 id="集合-gt-数组"><a href="#集合-gt-数组" class="headerlink" title="集合==&gt;数组"></a>集合==&gt;数组</h4><pre><code>let set = new set();let arr = [...set];</code></pre><h3 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h3><p><strong>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有下面区别。</strong></p><p> 1.WeakSet 的成员只能是对象，而不能是其他类型的值。</p><p> 2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不 再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p> 3.WeakSet 只有add/delete/clear/has三个方法，不能遍历，没有size属性等</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map也是由键值对构成的，和对象的区别在于Map的key也可以是一个对象，Object只可以是字符串</p><h2 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h2><h3 id="代理Proxy"><a href="#代理Proxy" class="headerlink" title="代理Proxy"></a>代理Proxy</h3><p>代理：通过代理对象访问目标对象</p><p>作用：</p><p> 1、控制目标对象的访问权限</p><p> 2、扩展目标对象方法</p><p>创建目标对象</p><pre><code>let targetObject = {    name:&quot;target&quot;,    type:&quot;object&quot;,    fun:function(){        console.log(&#39;目标对象的fun&#39;);    }}</code></pre><p>创建代理对象</p><pre><code>var p = new Proxy(targetObject,{    //target 就是目标的对象    //key 就是目标对象中的每一个属性和方法    //当代理对象直接获取属性和方法的等信息的时候都会来调用get方法    get(target,key){        if(key === &#39;fun&#39;){            console.log(&quot;代理对象调用目标对象的fun&quot;);        }        return target[key];    },    //当给对象的属性和方法赋值的时候调用set方法    //target 就是目标的对象    //key 就是目标对象中的每一个属性和方法    //value 属性值    set(target,key,value){    //如果key为type的时候就不给目标对象赋值        if(key === &#39;type&#39;){            return target[type];        }        else{            target[key] = value;        }    },    //当通过 xx in obj 的时候调用has方法    has(target,key){        if(key === &#39;type&#39;){            return false;        }        else{            return true;        }    },    //当删除对象的属性时 调用此方法    deleteProperty(target,key){        if(key === &#39;age&#39;){            delete target[key];            return true;        }        else{            return false;        }    }});p.fun(); //代理对象调用目标对象的fun     目标对象的funp.name = &#39;temp&#39;; //修改无效  当使用点的方式来访问属性时 会调用set函数  而set函数中设置了对name的修改权限console.log(p);  //{ name: &#39;target&#39;, type: &#39;object&#39;, fun: [Function: fun] }p.type = &#39;temp&#39;; //修改成功  set中没有对type的权限要求console.log(p); //{ name: &#39;target&#39;, type: &#39;temp&#39;, fun: [Function: fun] }console.log(&#39;type&#39; in p); //true  当使用in判断对象中是否有某属性时 会调用has函数 而我们在has中对type设置了权限 则无法访问console.log(&#39;name&#39; in p); //true  未对name设置  则访问成功delete p.name;  //删除失败   当使用点的方式来删除某属性时会默认调用deleteProperty方法 而我们在deleteProperty中限制了对name的删除权限 则删除失败delete p.type;  //删除成功   console.log(p); //{ name: &#39;target&#39;, fun: [Function: fun] }</code></pre><h3 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h3><p> 反射机制是指程序在运行的时候访问、检测和修改它本身状态或行为的一种能力，例如一个对象能够在运行时知道自己有哪些方法和属性。</p><p> 反射的概念在编译型的编程语言中比较明显，比如java、C#、Object-c等。对于 <code>JavaScript</code>来说，反射就是获取对象的内部结构的信息，所以JS中的反射随处可见，比如for…in方式遍历对象。</p><p> 从ECMAScript6开始，JS引入Reflect这个API专门用于操作反射。</p><p> ES6中的反射，将抛出异常，异常捕获简化为返回一个boolean值来表示其是否正常运行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cookie session</title>
    <link href="/study.github.io/2018/08/20/cookie-session/"/>
    <url>/study.github.io/2018/08/20/cookie-session/</url>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>npm init -y</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install express-cookie --save</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="引入与配置"><a href="#引入与配置" class="headerlink" title="引入与配置"></a>引入与配置</h4><pre><code>const cookieParser = require(&#39;cookie-parser&#39;);//中间件 签名app.use(cookieParser(&#39;howlcn&#39;));</code></pre><h4 id="用cookie储存信息"><a href="#用cookie储存信息" class="headerlink" title="用cookie储存信息"></a>用cookie储存信息</h4><pre><code>res.cookie(&#39;username&#39;,req.body.username,{    maxAge:1000*60, //cookie失效的时长（单位毫秒）    signed:true//开启签名 方式用户篡改cookie});</code></pre><h4 id="清空cookie"><a href="#清空cookie" class="headerlink" title="清空cookie"></a>清空cookie</h4><pre><code>res.cookie();</code></pre><h4 id="获取cookie中的数据"><a href="#获取cookie中的数据" class="headerlink" title="获取cookie中的数据"></a>获取cookie中的数据</h4><pre><code>let username = req.signedCookies.username;//获取cookie中的username</code></pre><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session底层还是调用了cookie</p><p><img src="https://i.loli.net/2019/05/30/5cef97889476388883.png" srcset="/study.github.io/img/loading.gif" alt="session"></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre><code>npm init -y</code></pre><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install express-session --save</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="引入与配置-1"><a href="#引入与配置-1" class="headerlink" title="引入与配置"></a>引入与配置</h4><pre><code>const express = require(&#39;express&#39;);const app = express();const expressSession = require(&#39;express-session&#39;);//配置expressSession中间件app.use(expressSession({    //cookie的名字    name:&#39;howlcn&#39;,    //cookie签名的信息    secret:&#39;howlcn&#39;,    cookie:{        maxAge:100000    },    resave:false,    //saveUninitialized为true时会将没有初始化的session的数据保存到storage中    //一般没有初始化的session是没有数据的  不必保存  则设置为false    saveUninitialized: false,    //为true时，某客户端每一次访问都会重置cookie的重置时间(maxAge)    rolling:true,    //指定session数据存放的地方(数据库),默认保存在服务器内存中（null也是）    store:null}));</code></pre><h4 id="用session存储数据"><a href="#用session存储数据" class="headerlink" title="用session存储数据"></a>用session存储数据</h4><pre><code>req.session.username = username;</code></pre><h4 id="清空session"><a href="#清空session" class="headerlink" title="清空session"></a>清空session</h4><pre><code>req.session.destroy()</code></pre><h4 id="获取session中的信息"><a href="#获取session中的信息" class="headerlink" title="获取session中的信息"></a>获取session中的信息</h4><pre><code>let username = req.session.username;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nuxt基本使用心得</title>
    <link href="/study.github.io/2018/08/19/Nuxt%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/study.github.io/2018/08/19/Nuxt%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p> Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染(SSR)的 Vue 应用提供了极其便利的开发体验。</p><p> Vue.js是开发SPA单页面应用的，传统的SPA应用是将bundle.js从服务端获取，然后在客户端解析并挂载到dom。</p><p> Nuxt这个框架是用Vue开发多页应用，并在服务端渲染。我们可以将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p> Nuxt适合做新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要做到是移动端项目，就没有必要用nuxt这个框架了。</p><p>Nuxt是基于Vue.js的服务端渲染框架，可以很好的解决SPA应用程序的首次加载问题。</p><pre><code>Nuxt.js有如下特点：Vue 2 ： nuxt是基于Vue2开发的Vue Router  ： nuxt整合了路由功能，配置非常简单VueX  ： 支持vuexVue Server Renderer  ： 支持服务端渲染Vue-meta  ： 支持meta标签配置</code></pre><p>Nuxt机制图示</p><p>未使用Nuxt：</p><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/noNuxt.png" srcset="/study.github.io/img/loading.gif" alt="noNuxt"></p><p>使用Nuxt：</p><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/nuxt.png" srcset="/study.github.io/img/loading.gif" alt="nuxt"></p><h2 id="二、创建Nuxt项目"><a href="#二、创建Nuxt项目" class="headerlink" title="二、创建Nuxt项目"></a>二、创建Nuxt项目</h2><p><a href="https://zh.nuxtjs.org/guide/installation/#新手模板" target="_blank" rel="noopener">新手模板</a></p><p>确保安装了npx（npx在NPM版本5.2.0默认安装了）</p><pre><code>$ npx create-nuxt-app &lt;项目名&gt;</code></pre><p>或者使用yarn:</p><pre><code>$ yarn create nuxt-app &lt;项目名&gt;</code></pre><p>配置：</p><p>启动</p><pre><code>npm run dev</code></pre><p>访问</p><pre><code>http://localhost:3000</code></pre><h2 id="三、Nuxt基本使用"><a href="#三、Nuxt基本使用" class="headerlink" title="三、Nuxt基本使用"></a>三、Nuxt基本使用</h2><h3 id="3-1-路由"><a href="#3-1-路由" class="headerlink" title="3.1 路由"></a>3.1 路由</h3><pre><code>//pages文件夹下面，文件名即路由#1.pages下新建search.vue&lt;template&gt;  &lt;div&gt;    这是search页面  &lt;/div&gt;&lt;/template&gt;//2.index.vue使用路由 此处的search就是所创建的search.vue的文件名&lt;nuxt-link to=&quot;/search&quot;&gt;到search页面&lt;/nuxt-link&gt;</code></pre><h3 id="3-2-嵌套子模版"><a href="#3-2-嵌套子模版" class="headerlink" title="3.2 嵌套子模版"></a>3.2 嵌套子模版</h3><pre><code>#index.vue&lt;template&gt;      &lt;section class=&quot;container&quot;&gt;            &lt;div&gt;              &lt;logo/&gt;             &lt;/div&gt;      &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import Logo from &#39;~/components/Logo.vue&#39;export default {  components: {    Logo  }}&lt;/script&gt;</code></pre><h3 id="3-3-layouts布局文件"><a href="#3-3-layouts布局文件" class="headerlink" title="3.3 layouts布局文件"></a>3.3 layouts布局文件</h3><p> 默认情况下所有的页面都会默认使用layouts下面default.vue这个布局文件</p><pre><code>#default.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;头部&lt;/h1&gt;    &lt;!--nuxt就相当于 router-view--&gt;    &lt;nuxt/&gt;                         &lt;h1&gt;尾巴&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>当然也可以创建自定义的布局文件</p><pre><code>//自定义布局文件//1.layouts下新建一个user.vue&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;用户页面头部&lt;/h1&gt;    &lt;nuxt/&gt;    &lt;h1&gt;用户页面底部&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{  }&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt;  h1{    color:green  }&lt;/style&gt;//2.pages下的search.vue指定使用哪个布局文件&lt;script&gt;  export default{    layout:&quot;user&quot;  }&lt;/script&gt;</code></pre><h3 id="3-4-全局CSS文件"><a href="#3-4-全局CSS文件" class="headerlink" title="3.4 全局CSS文件"></a>3.4 全局CSS文件</h3><p> 此css 文件将在所有组件中自动生效</p><pre><code>#1.在assets下新建css/main.css#2.修改nuxt.config.css配置文件后/*** global css*/css: [    &#39;element-ui/lib/theme-chalk/index.css&#39;,    &#39;~assets/css/main.css&#39;],#3.重启服务(配置文件的修改，重启后才能生效)</code></pre><h3 id="3-5-Vuex的使用"><a href="#3-5-Vuex的使用" class="headerlink" title="3.5 Vuex的使用"></a>3.5 Vuex的使用</h3><p> 在nuxt中使用vuex的时候无需new Vue.Store实例，nuxt会帮我们自动创建。默认情况下，会使用index.js这个store。</p><p> 每次修改增加Vuex时要重启服务</p><pre><code>#1.store/index.js//state存放数据export const state = () =&gt; ({  list: [&#39;a&#39;,&#39;b&#39;],  user:{}})//修改stateexport const mutations = {  increment (state,text) {    state.list.push(text);  },}//异步提交mutationsexport const actions = {}#2.store/city.jsexport const state = () =&gt; ({  list: [&#39;c&#39;,&#39;d&#39;]})export const mutations = {  increment (state,text) {    state.list.push(text);  }}</code></pre><p>在vue文件中使用vuex</p><ol><li>使用store/index.js中的state时 <code>$store.state.list</code></li><li>使用store/city.js中的state时 <code>$store.state.city.list</code></li></ol><pre><code>#3.pages/city.vue&lt;template&gt;  &lt;div&gt;    Page is city    &lt;ul&gt;      &lt;li        v-for=&quot;(item,idx) in $store.state.list&quot;        :key=&quot;idx&quot;&gt; {{ item }}        &lt;/li&gt;      &lt;input        type=&quot;button&quot;        value=&quot;增加信息index&quot;        @click=&quot;addIndex&quot;&gt;      &lt;li        v-for=&quot;(item,idx) in $store.state.city.list&quot;        :key=&quot;idx&quot;&gt; {{ item }}       &lt;/li&gt;    &lt;/ul&gt;    &lt;input      type=&quot;button&quot;      value=&quot;增加信息city&quot;      @click=&quot;addCity&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import axios from &quot;axios&quot;  export default{    data(){      return {        list:[]      }    },    methods: {      addIndex(){        this.$store.commit(&#39;increment&#39;, &quot;kk&quot;)      },      addCity(){        this.$store.commit(&#39;city/increment&#39;, &quot;jj&quot;)      }    }  }&lt;/script&gt;</code></pre><h2 id="四、SPA-SEO-SSR"><a href="#四、SPA-SEO-SSR" class="headerlink" title="四、SPA\SEO\SSR"></a>四、SPA\SEO\SSR</h2><h3 id="4-1-SPA-单页面应用"><a href="#4-1-SPA-单页面应用" class="headerlink" title="4.1 SPA:单页面应用"></a>4.1 SPA:单页面应用</h3><blockquote><p>SPA 时代，主要是在客户端端使用了<code>history</code>或<code>hash</code>（主要是为了低版本浏览器的兼容）API，在首次请求经服务端路由输出整个应用程序后，接下来的路由都由前端掌控了，前端通过路由作为中心枢纽控制一系列页面（组件）的渲染(DOM的生成)加载和数据交互。</p></blockquote><p>优点：</p><ol><li>页面之间的切换非常快</li><li>一定程度减少了后端服务器的压力</li><li>实现前后端分离，后端程序只需要提供api，不需要客户端到底是web端还是手机等</li></ol><p>缺点：</p><ol><li>首屏打开速度很慢</li><li>不利于SEO搜索引擎优化</li></ol><h3 id="4-2-SEO-搜索引擎优化"><a href="#4-2-SEO-搜索引擎优化" class="headerlink" title="4.2 SEO:搜索引擎优化"></a>4.2 SEO:搜索引擎优化</h3><blockquote><p>SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</p><p>由于SPA使用Ajax动态获取数据，很难保证搜索引擎的正常爬取，并且有些搜索引擎不支持js和Ajax获取的数据，因此SSR诞生</p></blockquote><h3 id="4-3-SSR-服务器端渲染"><a href="#4-3-SSR-服务器端渲染" class="headerlink" title="4.3 SSR:服务器端渲染"></a>4.3 SSR:服务器端渲染</h3><blockquote><p>为了解决SPA不支持SEO的问题，我们也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，但是这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。</p></blockquote><p>基本流程：当客户端向服务器发送请求后，web服务器根据路由拿到对应数据渲染并输出，且输出部分中包含两部分：</p><ol><li>路由页对应的页面及已渲染好的数据（解决首屏加载）</li><li>完整的SPA程序代码 （本地路由跳转，而不请求服务器）</li></ol><p>优点：</p><ol><li>更好的 SEO（搜索引擎爬虫抓取工具可以直接查看完全渲染的页面）</li><li>更快的内容到达时间 （不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了）</li></ol><p>缺点：</p><ol><li>占用更多的cpu和内存资源</li><li>一些常用的浏览器的api可能无法正常使用 （如：window，document，alert）</li><li>开发调试会有一些麻烦 （因为涉及到了浏览器及服务器，对于SPA的一些组件的声明周期的管理会变得复杂）</li></ol><h3 id="4-4-Nuxt对SSR支持"><a href="#4-4-Nuxt对SSR支持" class="headerlink" title="4.4 Nuxt对SSR支持"></a>4.4 Nuxt对SSR支持</h3><blockquote><p>从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 <a href="https://nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a> 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。</p><p>Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于Vue的SSR框架，预设了利用Vue.js开发<strong>服务端渲染</strong>的应用所需要的各种配置，使用它你可以不需要自己搭建一套 SSR 程序，而是通过其约定好的文件结构和API就可以实现一个首屏渲染的 Web 应用。</p><p>Nuxt.js 主要关注的是应用的 UI渲染。</p></blockquote><p><a href="https://juejin.im/post/58ff960ba22b9d0065b722cd" target="_blank" rel="noopener">实现基于 Nuxt.js 的 SSR 应用</a></p><h2 id="五、数据预取"><a href="#五、数据预取" class="headerlink" title="五、数据预取"></a>五、数据预取</h2><h3 id="5-1-准备服务器接口"><a href="#5-1-准备服务器接口" class="headerlink" title="5.1 准备服务器接口"></a>5.1 准备服务器接口</h3><pre><code>#1.server/interface/city.jsvar express = require(&#39;express&#39;)var router = express.Router()router.get(&#39;/info&#39;, function (req, res) {    return res.status(200).json([&#39;北京&#39;,&#39;天津&#39;])})module.exports = router#2.server/index.jsconst cityInterface = require(&quot;./interface/city&quot;)//在app.use(nuxt.render)上面添加app.use(&quot;/city&quot;,cityInterface)app.use(&quot;/city&quot;,cityInterface);app.use(nuxt.render)#.重启服务localhost:3000/city/info  测试接口</code></pre><h3 id="5-2-不适用数据预取"><a href="#5-2-不适用数据预取" class="headerlink" title="5.2 不适用数据预取"></a>5.2 不适用数据预取</h3><pre><code>#1.客户端pages下新建city.vue&lt;template&gt;  &lt;div&gt;    Page is city    &lt;ul&gt;      &lt;li        v-for=&quot;(item,idx) in list&quot;        :key=&quot;idx&quot;&gt; {{ item }} &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import axios from &quot;axios&quot;  export default{    data(){      return {        list:[]      }    },    //async表示方法返回一个Promise    //await 同步等待    async mounted(){      let {status,data} = await axios.get(&quot;/city/info&quot;);      this.list = data;      console.log(this.list);    }  }&lt;/script&gt;</code></pre><h3 id="5-3-Nuxt-js的工作流"><a href="#5-3-Nuxt-js的工作流" class="headerlink" title="5.3 Nuxt.js的工作流"></a>5.3 Nuxt.js的工作流</h3><p><img src="https://howlcn1997.github.io/2018/06/07/Nuxt/1546049173524.png" srcset="/study.github.io/img/loading.gif" alt="1546049173524"></p><ul><li>nuxtServerInit：如果在状态树(store)中指定了 <code>nuxtServerInit</code> 方法，Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（仅在服务端调用）。当我们想将服务端的一些数据传到客户端时，这个方法是非常好用的</li><li>middleware：中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前，服务端首屏渲染和路由跳转前均执行对应中间件。可以用作页面跳转时验证用户信息操作(登陆拦截)。</li><li>asyncData会在组件加载前（限于页面组件）调用，可以在<strong>服务端首屏渲染或者在路由跳转时执行</strong>，专门用来请求数据，Nuxt.js 会将 <code>asyncData</code> 返回的数据融合组件 <code>data</code> 方法返回的数据一并返回给当前组件。asyncData应该是用于影响SEO的内容，也就是需要让爬虫读取的内容。</li></ul><h3 id="5-4-服务端数据预取"><a href="#5-4-服务端数据预取" class="headerlink" title="5.4 服务端数据预取"></a>5.4 服务端数据预取</h3><h4 id="nuxtServerInit"><a href="#nuxtServerInit" class="headerlink" title="nuxtServerInit"></a>nuxtServerInit</h4><blockquote><p>nuxtServerInit可以将服务端的数据通过vuex同步到客户端，该方法仅会在服务端首屏渲染时执行</p></blockquote><pre><code>#store/index.jsexport const state = () =&gt; ({  list: [],})export const mutations = {  setlist (state,text) {    text.forEach(item=&gt;{      state.list.push(item)    })  },}export const actions = {  //将菜单信息写入到vuex实例中  async nuxtServerInit ({ commit }, { req ,app }) {    {      let {status, data} = await app.$axios.get(&quot;/city/info&quot;);      commit(&#39;setlist&#39;, data)    }  }}#2.pages/city.vue&lt;template&gt;  &lt;div&gt;    Page is city    &lt;ul&gt;      &lt;li        v-for=&quot;(item,idx) in $store.state.list&quot;        :key=&quot;idx&quot;&gt; {{ item }} &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="asyncData和fetch方法"><a href="#asyncData和fetch方法" class="headerlink" title="asyncData和fetch方法"></a>asyncData和fetch方法</h4><pre><code>//使用asyncData进行ssr渲染async asyncData(){    //给data取别名，请求网址写全，因为在刷新浏览器的时候需要全路径请求服务器    let {status,data:list} = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;);    if(status == 200) {        //这边不能使用this.list = list,因为获取不到this        //通过return给页面返回数据        return {            list        }    }}async fetch ({ store, params }){      //当页面加载时触发可以执行请求来触发action来修改state      //不可以return数据给页面      //页面可以从this.$store中获取action修改的state      let {status,data:list} = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;);      store.commit(&#39;setlist&#39;, list)}</code></pre><p>注意点：asyncData 和 fetch都只能够在页面组件中使用，如果想要在页面组件的子组件中使用ssr，可以使用nuxtServerInit<br>#注意点：由于 asyncData方法是在组件初始化前被调用的，所以在方法内是没有办法通过this来引用组件的实例。<br>#注意点：当用户请求页面时候服务端会先使用SSR来生成对应的页面文档结构，而在用户切换路由则是使用了SPA的模式。这意味着如果用户刷新页面，asyncData方法会在服务端执行；如果用户通过nuxt-link路由导航到当前页面，asyncData会在客户端执行</p><h3 id="5-5客户端数据预取"><a href="#5-5客户端数据预取" class="headerlink" title="5.5客户端数据预取"></a>5.5客户端数据预取</h3><blockquote><p>当asyncData方法是由路由跳转触发的时候，则使用客户端数据预取，asyncData方法会在客户端执行。可以通过控制台打印来查看是在浏览器执行还是在node执行就可以验证了。</p></blockquote><pre><code>async asyncData(context){    //给data取别名，请求网址写全    let {status,data:list} = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;);    //如果是客户端执行，则可以使用window对象    //如果是服务端执行，则没有window对象    if(process.client){        console.log(window)    }    if(status == 200) {        //这边不能使用this.list = list,因为获取不到this        //通过return给页面返回数据        return {            list        }    }}</code></pre><h2 id="六、SSR原理"><a href="#六、SSR原理" class="headerlink" title="六、SSR原理"></a>六、SSR原理</h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180524/92672015b4914784ae5a800c4a655e25.jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a></p><p>如上图所示：webpack将 Source 打包出两个bundle文件。</p><ul><li><p>服务端渲染：Server Bundle用于服务端渲染，主要是获取异步数据，同步到组件中，并将组件渲染成HTML返回到前端，但是<strong>vue-ssr不能绑定javascript事件</strong>，也就是说服务器端使用vue-ssr渲染出来的返回到浏览器的也只能是HTML+CSS。</p></li><li><p>客户端渲染：Client Bundle 用于客户端渲染，之前说过服务器不能增加事件，那只能前端增加。所以我们看到SSR渲染的网页源码中有</p><pre><code>window.__NUXT__=...</code></pre><p>代码，这是后端和前端在使用vuex共享数据。后端从vuex里面取到数据之后渲染成真正的HTML和css返回。客户端也是从vuex里面取到数据，客户端的渲染主要做2件事：</p><ul><li>拿到数据，使用 virtual-dom进行预渲染，然后和服务端渲染出来的进行比对，比对两边渲染的内容是不是一致的</li><li>对DOM元素的事件进行绑定，也就是回答的问题，事件在这块进行的处理</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Get与Post的区别及联系</title>
    <link href="/study.github.io/2018/08/12/Get%E4%B8%8EPost%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E8%81%94%E7%B3%BB/"/>
    <url>/study.github.io/2018/08/12/Get%E4%B8%8EPost%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E8%81%94%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="GET与POST的区别与联系"><a href="#GET与POST的区别与联系" class="headerlink" title="GET与POST的区别与联系"></a>GET与POST的区别与联系</h2><p>GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。</p><p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p><p>你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。</p><p>当你在面试中被问到这个问题，你的内心充满了自信和喜悦。</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLcm8TfMjvKvXwbzXTbpUaahYNVFpXh8fIMgqcmbIeEBqFTt7ibiaewMicg/640?wx_fmt=png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>你轻轻松松的给出了一个“标准答案”：</p><ul><li><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p></li><li><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p></li><li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p></li><li><p>GET请求只能进行url编码，而POST支持多种编码方式。</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p></li><li><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p></li><li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p></li><li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p></li><li><p>GET参数通过URL传递，POST放在Request body中。</p></li></ul><p>（本标准答案参考自w3schools）</p><p>“很遗憾，这不是我们要的回答！”</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLkCV5yUI4QFlaibOg9aFp2ZjPlaeAgaibbYyzOYsmcDfPlzFPAdcy21dQ/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>请告诉我真相。。。</p><p>如果我告诉你GET和POST本质上没有区别你信吗？</p><p>让我们扒下GET和POST的外衣，坦诚相见吧！</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLVXZkPZibSibtVZoIkDcBTQJ3mFibpNtqOSNTLDs01s2rmB6PyCoibjczxQ/640?wx_fmt=png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>那么，“标准答案”里的那些区别是怎么回事？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLdhmQxXtz2Kwn3yzT8Jzic1joUsjXxeaU8JwerDiabz9N9sYmBpIgWic2A/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p><p>但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLSDX3EiadGp0gDsHwgvGictCwWSEaAQ4jVib1sLaqnBGpFAUhHhjv8xGKQ/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p><p>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>你以为本文就这么结束了？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLNqLBKzbCAfuLHkM355iaBC9FuOlWrtiaIUmD95T8ReVJ9FInZIZWV0YA/0?" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>我们的大BOSS还等着出场呢。。。</p><p>这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。</p><p>GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><p>\1. GET与POST都有自己的语义，不能随便混用。</p><p>\2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p><p>\3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p><p>现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？</p><p><img src="http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLyfrfWEnMQlicIoNbaQJCicpKjOVQp8tNjU9Zp8Eia40om3vTah9aZEF7w/640?wx_fmt=jpeg" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>转自<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">在途中#</a>文章写的太生动了，忍不住copy一份，哈哈哈…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>云服务器的搭建</title>
    <link href="/study.github.io/2018/07/28/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/07/28/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="云服务器的搭建"><a href="#云服务器的搭建" class="headerlink" title="云服务器的搭建"></a>云服务器的搭建</h1><h2 id="一、搭建Https本地服务器"><a href="#一、搭建Https本地服务器" class="headerlink" title="一、搭建Https本地服务器"></a>一、搭建Https本地服务器</h2><h3 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h3><p>在本地磁盘上新建一个HttpsTest文件夹,用来存放测试文件</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/24.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="2-初始化以及express安装"><a href="#2-初始化以及express安装" class="headerlink" title="2.初始化以及express安装"></a>2.初始化以及express安装</h3><p>接下来用以下命令初始化文件夹以及安装express矿建</p><pre><code>npm init -ynpm install express --save</code></pre><p>之后会生成以下三个文件</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/25.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="3-建立https-js文件"><a href="#3-建立https-js文件" class="headerlink" title="3.建立https.js文件"></a>3.建立https.js文件</h3><p>新建一个https.js文件,该文件后续会写入服务器测试代码</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/26.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="4-安装openssl"><a href="#4-安装openssl" class="headerlink" title="4.安装openssl"></a>4.安装openssl</h3><p>openssl 用于生成自签名证书(免费，本地测试使用)</p><h4 id="4-1安装"><a href="#4-1安装" class="headerlink" title="4.1安装"></a>4.1安装</h4><p>如果电脑中已有git,直接右键<code>git bush here</code>即可,忽略以下安装步骤</p><p>若没有,可以安装openssl安装包,下载地址<a href="http://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener">http://slproweb.com/products/Win32OpenSSL.html</a></p><p>找到对应的exe文件下载安装即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/27.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>安装完成后配置环境变量,把openssl安装路径bin的路径（例如 C:\OpenSSL-Win64\bin）加入到操作系统的系统环境变量Path中</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/28.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><blockquote><p>重启电脑!!!切记,是个好习惯</p></blockquote><h4 id="4-2验证"><a href="#4-2验证" class="headerlink" title="4.2验证"></a>4.2验证</h4><p>验证openssl是否生效,打开cmd,输入<code>openssl</code>若能跳转,则安装完成</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/29.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="5-生成证书"><a href="#5-生成证书" class="headerlink" title="5.生成证书"></a>5.生成证书</h3><p>cmd进入openssl后,输入命令生成Private Key 和 CSR</p><pre><code>req -new -newkey rsa:2048 -nodes -out mydomain.csr -keyout private.key</code></pre><p>ps:若用git则需要加openssl,下同</p><pre><code>openssl req -new -newkey rsa:2048 -nodes -out mydomain.csr -keyout private.key</code></pre><p>生成自签名证书</p><p>使用上一步的private.key和mydomain.csr生成自签名证书,输入以下命令</p><pre><code>x509 -req -days 365 -in mydomain.csr -signkey private.key -out mydomain.crt</code></pre><p>完成后会得到以下几个文件</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/30.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="6-完善https-js以及测试"><a href="#6-完善https-js以及测试" class="headerlink" title="6.完善https.js以及测试"></a>6.完善https.js以及测试</h3><p>在http.js中输入以下代码搭建服务器</p><pre><code>var express = require(&quot;express&quot;);var app = express();var fs = require(&#39;fs&#39;);var key = fs.readFileSync(&#39;./private.key&#39;);var cert = fs.readFileSync(&#39;./mydomain.crt&#39;);var options = {    key: key,    cert: cert};// Run static servervar https = require(&#39;https&#39;);https.createServer(options, app.get(&#39;/&#39;, function (req, reb) {    reb.send(&#39;Success!&#39;)})).listen(3000, function () {    console.log(&#39;Running...&#39;)});</code></pre><p>到此基本处理完成,下面开始测试</p><p>运行https.js</p><p>在浏览器中输入<a href="https://www.javascriptcn.com/go/?target=https%3A%2F%2Flocalhost">https://localhost</a>:3000</p><p>浏览器会显示<code>您的连接是不是私密连接</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/31.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击<code>高级</code>选项,再点击<code>继续前往</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/32.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>当看到页面返回<code>Success!</code>时,即表示https服务搭建成功</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/33.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>可以通过点击网站信息,点击证书查看证书信息</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/34.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/35.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><blockquote><p>由于我们证书是自己创建的，没有经过第三方机构的验证，因此会出现警告的提示。大家可以去有资质的网络运营商，去申请自己的证书。比如：<a href="http://www.godaddy.com/ssl/ssl-certificates.aspx" target="_blank" rel="noopener">godaddy SSL Certificates</a>，优惠码：<strong>WOWfensme</strong></p></blockquote><h2 id="二、搭建腾讯云Https网络服务器"><a href="#二、搭建腾讯云Https网络服务器" class="headerlink" title="二、搭建腾讯云Https网络服务器"></a>二、搭建腾讯云Https网络服务器</h2><h3 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h3><p>进入腾讯云官网,用微信登录账号(若提示是否创建新账号,点击创建新账号)往下翻,找到<code>域名与网站</code>功能菜单,点击</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/1.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击域名注册</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/2.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击<code>域名1元抢</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/3.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>进入页面后<code>.club</code>和<code>.xyz</code>域名都是一年一元,按喜好任选即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/4.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击之后,再输入框中输入自己的想要创建的域名,点击查询,如果不可以购买,说明已被抢注,需要换其他名称</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/5.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>购买完成之后,点击页面右上角控制台,即可进入管理中心,看到自己购买的域名</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/6.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/7.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/8.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>之后,在该页面点击实名认证,域名都要通过实名认证才可以使用,填写相关信息即可</p><h3 id="2-购买服务器"><a href="#2-购买服务器" class="headerlink" title="2.购买服务器"></a>2.购买服务器</h3><p>接下来准备购买服务器,在腾讯云官网有15天免费体验,可以先进行试用</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/9.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>这一部分都可以免费试用,我们主要需要<code>云服务器</code></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/10.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击领取之后会有默认配置可以选择,操作系统的话,如果熟悉Linux可以使用Cent OS,否则选择windows server即可</p><p>接下来免费付款即可</p><p>完成之后,右上角会有消息提示,点击查看消息,即可看到购买的服务器的登录密码和相关信息</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/11.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><h3 id="3-服务器配置"><a href="#3-服务器配置" class="headerlink" title="3.服务器配置"></a>3.服务器配置</h3><p>接下来需要配置服务器</p><p>1.首先登录云服务器控制台</p><p>2.在实例列表中可以看到自己的服务器,点击登录</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/12.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>3.在弹出的【登录Windows实例】窗口中，选择【使用 RDP 文件登录】，单击【下载 RDP 文件】到本地。</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/13.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>4.双击下载到本地的 RDP 文件，远程连接到 Windows 云服务器。</p><p>到此服务器基本设置完成,接下来需要在服务器中安装node,sublime等等(强烈推荐vscode)</p><h3 id="4-域名配置"><a href="#4-域名配置" class="headerlink" title="4.域名配置"></a>4.域名配置</h3><p>在完成实名认证后,点击控制台,进入域名管理,点击解析</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/14.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>点击添加记录,基本格式按以下图片内容写</p><p><strong>注意:其中记录值换成你自己购买的服务器的公网ip</strong></p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/15.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>这样域名已经与服务器进行绑定</p><h3 id="5-https连接测试"><a href="#5-https连接测试" class="headerlink" title="5.https连接测试"></a>5.https连接测试</h3><p>以下都是在云服务器中操作</p><p>1.要搭建https的连接,先要下载ssl证书管理,在腾讯云官网中,点击控制台,云产品,ssl证书</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/16.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>2.点开之后会看到如下</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/17.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>3、点击申请证书，默认选择即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/18.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>4、填写信息完毕后，选择“自动DNS验证”，将自动为域名添加DNS记录，如下图：</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/19.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>5、等候证书通过，通过后点击下载</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/20.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>6、然后把这两个文件放到服务器磁盘中(新建一个usr文件夹,放入其中,记住他的绝对路径)</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/21.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>7.在服务器中安装Nginx,进行反向代理,这是Nginx的官网</p><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p><p>下载解压即可</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/22.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>7、修改Nginx下面的conf文件夹下nginx.conf文件添加如下代码,删去中文</p><pre><code>server {    listen              443 ssl;    server_name         gw2.vsgames.cn;    ssl_certificate     /Users/wucao/Desktop/gw2.vsgames.cn/Nginx/1_gw2.vsgames.cn_bundle.crt;  # 证书文件地址    ssl_certificate_key /Users/wucao/Desktop/gw2.vsgames.cn/Nginx/2_gw2.vsgames.cn.key; # 私钥文件地址    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers         HIGH:!aNULL:!MD5;    location / {        root /usr/share/nginx/html;    }}</code></pre><p>配置好点击nginx.exe重启Nginx</p><p>8.接下来在node中编写代码,将秘钥和证书地址改为自己的</p><pre><code>const https = require(&#39;https&#39;);const fs = require(&#39;fs&#39;);const options = {  key: fs.readFileSync(&#39;/Users/wucao/Desktop/gw2.vsgames.cn/Nginx/2_gw2.vsgames.cn.key&#39;),//秘钥地址  cert: fs.readFileSync(&#39;/Users/wucao/Desktop/gw2.vsgames.cn/Nginx/1_gw2.vsgames.cn_bundle.crt&#39;)//证书地址};https.createServer(options, function(req, res) {  res.statusCode = 200;  res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);  res.end(&#39;Hello World\n&#39;);}).listen(8000);</code></pre><p>开启服务器</p><p>输入你的域名地址加端口号,例如<code>https://howlcn.cn:8000</code></p><p>出现<code>hello world</code>说明搭建成功</p><p><img src="https://howlcn1997.github.io/2018/04/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/23.png" srcset="/study.github.io/img/loading.gif" alt="img"></p><p>若直接域名访问,则将监听端口设为80即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack的基本使用心得</title>
    <link href="/study.github.io/2018/07/20/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/study.github.io/2018/07/20/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack的基本使用"><a href="#webpack的基本使用" class="headerlink" title="webpack的基本使用"></a>webpack的基本使用</h1><p>1、webpack能够处理JS文件之间相互依赖的关系</p><p>2、webpack能够处理JS的兼容性问题，将高级的、浏览器无法识别的语法转为低级的浏览器能识别的语法</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装webpack</p><pre><code>npm install -g webpacknpm install webpack@3.0.0 -g  //安装指定版本</code></pre><p>全局安装脚手架()</p><pre><code>npm i webpack-cli -g</code></pre><h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>这里以隔行换色为例：</p><p>先构建文件目录如下：</p><p><img src="https://howlcn1997.github.io/2018/04/02/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E7%9B%AE%E5%BD%95.png" srcset="/study.github.io/img/loading.gif" alt="目录"></p><p>其中node_modules文件夹是安装其他包自动构建的</p><p>安装我们要用到的包，这里使用了jquery</p><pre><code>npm i jquery</code></pre><p>index.html中写入代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;!-- 不推荐在这里直接引用任何css script --&gt;    &lt;!-- 所有的引用都在main.js中写 --&gt;    &lt;!-- 因为main.js中用了ES6的语法，浏览器不兼容，此时就需要webpack来预处理 --&gt;    &lt;!-- &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;这是第1个li&lt;/li&gt;        &lt;li&gt;这是第2个li&lt;/li&gt;        &lt;li&gt;这是第3个li&lt;/li&gt;        &lt;li&gt;这是第4个li&lt;/li&gt;        &lt;li&gt;这是第5个li&lt;/li&gt;        &lt;li&gt;这是第6个li&lt;/li&gt;        &lt;li&gt;这是第7个li&lt;/li&gt;        &lt;li&gt;这是第8个li&lt;/li&gt;        &lt;li&gt;这是第9个li&lt;/li&gt;        &lt;li&gt;这是第10个li&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在main中写入代码</p><pre><code>//这是入口js文件//导入jqueryimport $ from &#39;jquery&#39;$(function(){    $(&#39;li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;skyblue&#39;);    $(&#39;li:even&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;)})</code></pre><p>用webpack处理mian.js</p><p>命令行中键入</p><pre><code>webpack ./src/main.js ./dist/bundle.js</code></pre><p><code>./src/main.js</code>是要处理的文件路径</p><p><code>./dist/bundle.js</code>是处理之后需要保存到的路径</p><p>此时将<code>main.js</code>处理成<code>bundle.js</code>,此时我们就可以在html页面中直接引入<code>bundle.js</code>了</p><pre><code>&lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt;</code></pre><p>完成效果</p><p><img src="https://howlcn1997.github.io/2018/04/02/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E6%95%88%E6%9E%9C.png" srcset="/study.github.io/img/loading.gif" alt="1561981889615"></p><h2 id="基本配置文件的使用"><a href="#基本配置文件的使用" class="headerlink" title="基本配置文件的使用"></a>基本配置文件的使用</h2><p>每当我们将<code>mian.js</code>中的内容做出变化时，都要手动输入 <code>webpack ./src/main.js ./dist/bundle.js</code>命令来重新生成<code>bundle.js</code>,过于麻烦，这里可以设置配置文件以达到，只需要输入<code>webpack</code>就可以达到重新生成bundle.js的目的</p><p>在项目根目录下创建<code>webpack.config.js</code>文件，进行配置</p><pre><code>const path = require(&#39;path&#39;);//这个配置文件，其实就是一个js文件，通过Node中的模块操作，向外暴露了一个对象module.exports = {    //手动指定入口 和 出口    //入口，表示要使用webpack打包哪个文件    entry: path.join(__dirname,&#39;./src/main.js&#39;),    //输入文件相关属性    output: {        path: path.join(__dirname,&#39;./dist&#39;),//指定打包好的文件，输出到哪个目录中去        filename: &#39;bundle.js&#39; //指定 输出文件名称    }}</code></pre><h2 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server</h2><p>之前代码每做一次改变都要在命令行键入<code>webpack</code>，过于麻烦，为了进一步偷懒，我们可以利用<code>webpack-dev-server</code>工具来实现。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>命令行键入</p><pre><code>npm i webpack-dev-server -D  //将此工具安装到项目的本地开发依赖npm i webpack -D   //项目中安装webpacknpm i webpack-cli -D   //项目中安装webpack-cli</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>webpack-dev-server</code>的使用方式同<code>webpack</code>一样，（这让我想到了<code>node</code> 与 nodemon`的关系）</p><pre><code>webpack-dev-server   //暂不可用</code></pre><p>注意：1、由于我们是在项目本地中安装的，无法在powershell中直接使用，我们可以在package.json中，在scripts中添加<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>，配置如下</p><pre><code>{    &quot;name&quot;: &quot;01-webpack&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;&quot;,    &quot;main&quot;: &quot;index.js&quot;,    &quot;scripts&quot;: {        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,        &quot;dev&quot;: &quot;webpack-dev-server&quot;    },    &quot;keywords&quot;: [],    &quot;author&quot;: &quot;&quot;,    &quot;license&quot;: &quot;ISC&quot;,    &quot;dependencies&quot;: {        &quot;jquery&quot;: &quot;^3.4.1&quot;    },    &quot;devDependencies&quot;: {        &quot;webpack-dev-server&quot;: &quot;^3.7.2&quot;    }}</code></pre><p>2、由于webpack-dev-server是依赖于webpack的，所以我们呢必须要在项目中本地安装webpack和脚手架</p><p>3、由于webpack-dev-server打包的文件并没有存放在磁盘上，而是暂存在内存中，导致我们的改变<code>main.js</code>时没有效果，它相当于在项目根目录生成了一个看不见的文件，</p><p>所以我们在script引入时，应直接应用根目录下</p><pre><code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>npm run dev</code></pre><h2 id="使用html-webpack-plugin"><a href="#使用html-webpack-plugin" class="headerlink" title="使用html-webpack-plugin"></a>使用html-webpack-plugin</h2><p>使得html页面也可以被加载到内存中，提高代码开发效率</p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><pre><code>npm i html-webpack-plugin -D</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>在main.js中引入</p><pre><code>const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);</code></pre><p>在plugins中配置</p><pre><code>plugins: [    //配置插件的节点    new webpack.HashedModuleIdsPlugin(), //new 一个热更新的 模块对象     new htmlWebpackPlugin({  //创建一个 在内存中生成HTML 页面的插件        //指定 模板页面，将来会根据指定的页面的路径，去生成内存中的 页面        template: path.join(__dirname,&#39;./src/index.html&#39;),        // 指定 生成的页面的名称        filename: &#39;index.html&#39;    })]</code></pre><h2 id="webpack-处理第三方不是文件类型的过程"><a href="#webpack-处理第三方不是文件类型的过程" class="headerlink" title="webpack 处理第三方不是文件类型的过程"></a>webpack 处理第三方不是文件类型的过程</h2><ol><li>当发现要处理的文件不是js文件时，回去配置文件中查找有无对应的第三方loader规则；</li><li>如查找到对应规则，会调用对应的一系列loader处理此文件类型；</li><li>调用use中一系列的loader时，会从后向前调用，第一个loader的处理结果会返回给下一个；loader，直到当前loader为最后一个loader；</li><li>当最后一个loader处理完毕时，会将执行结构返回给webpack进行打包合并处理，并输出到bundle.js中去。</li></ol><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><strong>由于webpack默认只能处理js文件，非js文件要使用loader加载器</strong></p><h3 id="loader处理css"><a href="#loader处理css" class="headerlink" title="loader处理css"></a>loader处理css</h3><p>在index.html中不推荐直接引入css，这样可能会导致客户端项服务器发送第二次请求，这里使用第三方loader，利用webpack将css打包到bundle.js中去。</p><p>处理css需要两个loader加载器</p><ul><li>style-loader</li><li>css-loader</li></ul><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install style-loader css-loader -D</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在webpack.config.js中新增一个配置节点module，他是一个对象；在这个module对象上有一个rules属性，这个属性是一个数组，存放了所有第三方的 匹配 和 处理规则。</p><pre><code>module: {    rules: [        {test: /\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;]}    ]}</code></pre><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>在main.js中引入css</p><pre><code>import &#39;./css/index.css&#39;</code></pre><h3 id="loader处理less"><a href="#loader处理less" class="headerlink" title="loader处理less"></a>loader处理less</h3><p>处理less需要三个个loader加载器</p><ul><li>style-loader</li><li>css-loader</li><li>less-loader</li></ul><h4 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install style-loader css-loader less-loader -D</code></pre><p>注意：若之前已经安装了<code>style-loader</code> <code>css-loader</code>，仅需要安装<code>less-loader</code> 即可</p><pre><code>npm install less-loader -D</code></pre><p>若要正常使用less-loader，还需要一个less依赖项，安装less</p><pre><code>npm install less -D</code></pre><p>注意：此处的less是内部依赖于less-loader的，则无需再main.js中引入</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>在module中的rules中添加配置</p><pre><code>{test: /\.less$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]}</code></pre><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><pre><code>main.js`中引入`index.lessimport &#39;./css/index.less&#39;</code></pre><h3 id="loader处理scss"><a href="#loader处理scss" class="headerlink" title="loader处理scss"></a>loader处理scss</h3><p>处理less需要三个个loader加载器</p><ul><li>style-loader</li><li>css-loader</li><li>sass-loader (坑：这里是sass 而文件名是.scss)</li></ul><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install sass-loader -D</code></pre><p>安装内部依赖项</p><pre><code>npm install node-sass -D</code></pre><p>注意此处安装node-sass若失败，请切换cnpm进行安装</p><pre><code>npm install cnpm -gcnpm install node-sass -D</code></pre><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><pre><code>{test: /\.scss$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]}</code></pre><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><pre><code>main.js`中引入`index.scssimport &#39;./css/index.scss&#39;</code></pre><h3 id="loader处理css中的图片"><a href="#loader处理css中的图片" class="headerlink" title="loader处理css中的图片"></a>loader处理css中的图片</h3><p>当css中出现引用图片时，webpack会解码出错，如</p><pre><code>body {    background: url(./images/temp.jpg);}</code></pre><p>之所以出错，是由于对url的解析出错，这里需要用到url-loader；</p><p>处理图片需要两个loader加载器</p><ul><li>url-loader</li><li>file-loader</li></ul><h4 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install url-loader file-loader -D</code></pre><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><pre><code>{test: /\.(png|jpg|gif|bmp|jpeg)$/, use: &#39;url-loader?limit=1024$name=[hash:8]-[name].[ext]&#39;}</code></pre><p>该loader会默认将要加载的图片转码为base64的字符串替换url原本的位置，使其可以直接加载在页面上；</p><p>其中：</p><ul><li>limit 当图片大小超过此属性对应的值时，不将其转码为base64，否则转为base64</li><li>name 设置由url-loader处理之后的文件名<ul><li>[hash: 8] 设置文件名开头为随机的8位哈希值</li><li>[name] 设置文件名结束为文件的原本名字</li><li>[ext] 设置后缀名为文件原本的后缀名</li></ul></li></ul><p>示例：当文件<code>test.png</code>大小大于limit时，文件被处理为<code>3hu4ye89-test.png</code></p><h4 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h4><p>在css中使用</p><pre><code>body {  background: url(../images/test.png);}</code></pre><p>并将此css文件引入main.js中</p><h3 id="loader处理字体图标的问题"><a href="#loader处理字体图标的问题" class="headerlink" title="loader处理字体图标的问题"></a>loader处理字体图标的问题</h3><p>当我们使用第三方字体图标时（如bootstrap.css）时，若文件声明某种字体时而利用url去引用其他文件时，在webpack打包时便会报错。</p><p>处理图片需要一个loader加载器</p><ul><li>url-loader</li></ul><h4 id="安装-7"><a href="#安装-7" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install url-loader -D</code></pre><p>其实上一步已经安装，无需再次安装。</p><h4 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h4><pre><code>{test: /\.(ttf|eot|svg|woff|woff2)$/, use: &#39;url-loader&#39;}</code></pre><h4 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h4><p>这里以<code>bootstrap</code>为例：</p><p>安装<code>bootstrap</code></p><pre><code>npm install bootstrap@3.3.5 --save</code></pre><p><code>index.html</code>中输入</p><pre><code>&lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;</code></pre><p><code>main.js</code>中引入</p><pre><code>import &#39;bootstrap/dist/css/bootstrap.css&#39;</code></pre><p>注意：这里不能直接引入<code>import &#39;bootstrap&#39;</code></p><h2 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h2><p>由于webpack只能处理部分ES6的代码，所以为了更好的兼容ES6我们需要引入babel来达到目的。将ES6以上的语法自动转换成当前浏览器可以识别的ES最高版本的语法。</p><h3 id="安装-8"><a href="#安装-8" class="headerlink" title="安装"></a>安装</h3><h4 id="安装babel的转码工具"><a href="#安装babel的转码工具" class="headerlink" title="安装babel的转码工具"></a>安装babel的转码工具</h4><pre><code>npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev</code></pre><h4 id="安装babel转换的语法"><a href="#安装babel转换的语法" class="headerlink" title="安装babel转换的语法"></a>安装babel转换的语法</h4><pre><code>npm i babel-preset-env babel-preset-stage-0 --save-dev</code></pre><h3 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h3><p> 1、在webpack.config.js中配置</p><pre><code>{test: /\.js$/, use: &#39;babel-loader&#39;, exclude: /node_modules/}</code></pre><p> 2、在项目根目录下新建一个名为 <code>.babelrc</code>的babel配置文件,文件中键入内容</p><pre><code>{    &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;],    &quot;plugins&quot;: [&quot;transform-runtime&quot;]}</code></pre><p>注意：该文件是严格遵从<code>json</code>格式的。</p><p>其中:</p><ul><li>presets 中配置语法插件 (相当于高级语法翻译成低级语法的字典)</li><li>plugins中配置属于babel的插件（相当于翻译器）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Express服务器的搭建</title>
    <link href="/study.github.io/2018/07/14/Express%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/07/14/Express%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>是基于Node.js平台，快速、开放极简的web开发框架</p><p>初始化</p><pre><code>npm init -y  //加-y时 会以默认参数创建package.json文件   若不加 可以自定义package.json参数信息</code></pre><p>安装</p><pre><code>npm install express -save</code></pre><p>自动重启服务器工具</p><pre><code>npm install nodemon  //若要使用该工具  在启动服务器时要使用nodemon命令 如 nodemon ./server.js</code></pre><p>路径的匹配</p><pre><code>//匹配student开头，而且后面跟了学号   http://localhost:8000/student/1234app.get(&quot;/student/:id/:name&quot;,function(req,res){    var id = req.params[&quot;id&quot;];    var name = req.params[&quot;name&quot;];    res.send(id+name);});</code></pre><h2 id="中间件的另一种使用方式"><a href="#中间件的另一种使用方式" class="headerlink" title="中间件的另一种使用方式"></a>中间件的另一种使用方式</h2><pre><code>const express = require(&#39;express&#39;);const app = express();var f1 = (req,res,next)=&gt;{    console.log(1);    next();}var f2 = (req,res,next)=&gt;{    console.log(2);    next();}var f3 = (req,res,next)=&gt;{    console.log(3);    res.send();}app.use(&#39;/user&#39;,[f1,f2,f3]);app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);})</code></pre><h2 id="next注意点"><a href="#next注意点" class="headerlink" title="next注意点"></a>next注意点</h2><p>有如下代码：</p><pre><code>const express = require(&#39;express&#39;);const app = express();//无门槛进入  只要是localhost:3000就会响应app.use((req,res,next)=&gt;{    console.log(&#39;有用户进入...函数一&#39;);    next(); //通关文牒},(req,res,next)=&gt;{         console.log(&#39;有用户进入...函数二&#39;);    next();});app.use(&#39;/user&#39;,(req,res,next)=&gt;{    console.log(&#39;访问结束&#39;);    res.send(&#39;用户页面&#39;+total);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);})</code></pre><p><strong>next() 不加参数时会指向下一个执行函数，即函数一中的next()会指向函数二</strong></p><pre><code>const express = require(&#39;express&#39;);const app = express();//无门槛进入  只要是localhost:3000就会响应app.use((req,res,next)=&gt;{    console.log(&#39;有用户进入...函数一&#39;);    next(&#39;/user&#39;); //通关文牒},(req,res,next)=&gt;{         console.log(&#39;有用户进入...函数二&#39;);    next();});app.use(&#39;/user&#39;,(req,res,next)=&gt;{    console.log(&#39;访问结束&#39;);    res.send(&#39;用户页面&#39;+total);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);})</code></pre><p><strong>next(‘/user’) 加参数时，会跳转至下一个路径为/user的use函数，即跳过函数二直接来到下一个use函数</strong></p><h2 id="body-parser的使用"><a href="#body-parser的使用" class="headerlink" title="body-parser的使用"></a>body-parser的使用</h2><p><strong>作用：可以获取post请求中信息</strong></p><p>安装</p><pre><code>npm install body-parser --save</code></pre><p>使用</p><pre><code>const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);//若要获取post中的参数 则必须以此挂载bodyparser中间件app.use(bodyParser.urlencoded({extended: false}));app.use(express.static(&#39;views&#39;));app.post(&#39;/login&#39;,(req,res)=&gt;{    res.send(&#39;name:&#39;+req.body.username);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h2><pre><code>const express = require(&#39;express&#39;);const app = express();app.get(&#39;/index&#39;,(req,res,next)=&gt;{    try{        let a = null;        console.log(a.toString()); //null不能调用toString()  此处故意制造错误        next();    }catch(e){        next(e); //转至错误处理中间件    }});//错误处理中间件（注意。错误处理中间件 要用use）app.use((err,req,res,next)=&gt;{    // res.send(err); 无法打印    res.send(err.toString());});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="指定静态资源"><a href="#指定静态资源" class="headerlink" title="指定静态资源"></a>指定静态资源</h2><pre><code>const express = require(&#39;express&#39;);const app = express();app.use(express.static(&#39;views&#39;));//指定views文件夹为静态资源文件夹  若该文件夹中存在login.html 则可以通过http:localhost:3000/login.html来直接访问该页面</code></pre><h2 id="Router类的使用"><a href="#Router类的使用" class="headerlink" title="Router类的使用"></a>Router类的使用</h2><p>1、先创建一个需要js文件，每一个js文件就是一个类</p><p>每一个js文件中的写法</p><pre><code>const express = require(&#39;express&#39;);const router = express.Router(); //创建router类router.get(&#39;/c1&#39;,(req,res)=&gt;{  //设置请求响应函数  /c1为访问路径    res.send(&#39;/c1&#39;);});router.post(&#39;/c2&#39;,(req,res)=&gt;{//设置请求响应函数    res.send(&#39;/c2&#39;);});module.exports = router;  //将router暴露出去</code></pre><p>2、当创建若干js文件（类）之后，用一个js文件进行汇总使用，相当于入口文件 此处创建server.js</p><p>写法</p><pre><code>const express = require(&#39;express&#39;);const app = express();const chang = require(&#39;./chang&#39;); //引入自定义的类//...app.use(&#39;/chang&#39;,chang);  //访问方式 localhost:3000/chang/c1     //此处用use指定的/chang只是虚拟路径 并不存在真实的物理路径//app.use(chang);   //访问方式 localhost:3000/c1 //...//app.use(.....)app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><p>这种使用方式相当于自定义了中间件后，再在server中使用。</p><h2 id="art-template的使用"><a href="#art-template的使用" class="headerlink" title="art-template的使用"></a>art-template的使用</h2><h3 id="art-template在前台的使用"><a href="#art-template在前台的使用" class="headerlink" title="art-template在前台的使用"></a>art-template在前台的使用</h3><p><strong>下载</strong><a href="http://aui.github.io/art-template/docs/installation.html" target="_blank" rel="noopener">art-template-web</a></p><p>1、将art-template-web.js引入到页面</p><pre><code>&lt;script src=&quot;./template-web.js&quot;&gt;&lt;/script&gt;</code></pre><p>2、在页面中定义一个模板</p><pre><code>&lt;/body&gt;//此script标签相当于一个容器&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; //注意 此处一定要加上  type=&quot;text/html&quot;    {{each users}}        &lt;h1&gt;{{$value.name}}&lt;/h1&gt;        &lt;li&gt;{{$value.age}}&lt;/li&gt;        &lt;li&gt;{{$value.gender}}&lt;/li&gt;        &lt;li&gt;{{$value.love}}&lt;/li&gt;    {{/each}}&lt;/script&gt;&lt;script&gt;    var data = {        users:[{name: &#39;张三&#39;, age: 12, gender: &#39;女&#39;, love: &#39;唱&#39;},               {name: &#39;李四&#39;, age: 13, gender: &#39;男&#39;, love: &#39;跳&#39;},               {name: &#39;王五&#39;, age: 14, gender: &#39;女&#39;, love: &#39;rap&#39;},               {name: &#39;蔡徐坤&#39;, age: 15, gender: &#39;女&#39;, love: &#39;篮球&#39;}]    }    //如果数组中都是对象，且要访问对象内的值时要使用$value.xxx  value代表当前遍历到的数组元素    var html = template(&#39;test&#39;,data);    var box = document.getElementById(&#39;box&#39;);    box.innerHTML = html;&lt;/script&gt;&lt;/html&gt;</code></pre><p>另一种实现方式</p><pre><code>&lt;script&gt;    //当使用此法时 模板字符串拼接时  每一个标签要单独用 &quot;&quot; 括起来    var artt = &quot;{{each users}}&quot;+        &quot;&lt;h1&gt;{{$value.name}}&lt;/h1&gt;&quot;+        &quot;&lt;li&gt;{{$value.age}}&lt;/li&gt;&quot;+        &quot;&lt;li&gt;{{$value.gender}}&lt;/li&gt;&quot;+        &quot;&lt;li&gt;{{$value.love}}&lt;/li&gt;&quot;+    &quot;{{/each}}&quot;;    var render = template.compile(artt);    var data = {        users:[{name: &#39;张三&#39;, age: 12, gender: &#39;女&#39;, love: &#39;唱&#39;},                {name: &#39;李四&#39;, age: 13, gender: &#39;男&#39;, love: &#39;跳&#39;},                {name: &#39;王五&#39;, age: 14, gender: &#39;女&#39;, love: &#39;rap&#39;},                {name: &#39;蔡徐坤&#39;, age: 15, gender: &#39;女&#39;, love: &#39;篮球&#39;}]    }    //如果数组中都是对象，且要访问对象内的值时要使用$value.xxx  value代表当前遍历到的数组元素    var html = render(data);    var box = document.getElementById(&#39;box&#39;);    box.innerHTML = html;&lt;/script&gt;</code></pre><h3 id="art-template在后台中的使用"><a href="#art-template在后台中的使用" class="headerlink" title="art-template在后台中的使用"></a>art-template在后台中的使用</h3><p>初始化</p><pre><code>npm init -y</code></pre><p>安装</p><pre><code>npm install art-template --savenpm install express-art-template --save</code></pre><p>使用</p><pre><code>const express = require(&#39;express&#39;);const app = express();//指定art-template渲染的文件后缀是htmlapp.engine(&#39;html&#39;,require(&#39;express-art-template&#39;));//指定静态资源目录app.use(express.static(&#39;views&#39;));</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>wamp环境的搭建</title>
    <link href="/study.github.io/2018/07/10/wamp%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/study.github.io/2018/07/10/wamp%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="wamp环境搭建"><a href="#wamp环境搭建" class="headerlink" title="wamp环境搭建"></a>wamp环境搭建</h1><h2 id="一、wamp简介"><a href="#一、wamp简介" class="headerlink" title="一、wamp简介"></a>一、wamp简介</h2><p>wamp是Windows Apache MySQL PHP的简称</p><p>Windows 操作系统</p><p>Apache 提供网页服务(html js css img)</p><p>MySQL 数据库</p><p>PHP 编程语言，可以用来开发动态网站</p><h2 id="二、下载与安装"><a href="#二、下载与安装" class="headerlink" title="二、下载与安装"></a>二、下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>根据电脑系统下载 <a href="https://pan.baidu.com/s/1b_8fp8Qsj9laXzxIeO5XCQ" target="_blank" rel="noopener">wampServer2.4 x86 x64</a> 提取码:i3ti.</p><p>（推荐安装32位）</p><h3 id="安装前须知"><a href="#安装前须知" class="headerlink" title="安装前须知"></a>安装前须知</h3><p>1 确保电脑安装了<a href="https://pan.baidu.com/s/1OfOwL8Qd6MCV8kSppBn6yA" target="_blank" rel="noopener">Microsoft Visual C++ 2012 Redistributable</a>提取码:0u1t;</p><p>2 更新了<a href="https://pan.baidu.com/s/1_COl7-dFJZI-sjH3NzQ5Vg" target="_blank" rel="noopener">KB2999226</a> 提取码:s6w7;</p><p>3 已卸载原有的数据库和Apache.</p><p>安装wamp，傻瓜式安装即可.</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>打开wamp 当任务栏中的W变为绿色，且再浏览器中输入localhost回车后出现wamp界面则本地服务器运行成功</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%AE%89%E8%A3%85%E6%A3%80%E6%B5%8B.png" srcset="/study.github.io/img/loading.gif" alt="安装检测"></p><h2 id="三、配置访问权限"><a href="#三、配置访问权限" class="headerlink" title="三、配置访问权限"></a>三、配置访问权限</h2><h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><p>想要其他设备访问到你的本地服务器需要进行如下操作</p><p>打开 wamp –&gt; bin –&gt; apache –&gt; Apache2.4.4 –&gt; conf –&gt; httpd.conf文件，搜索关键词 Order</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png" srcset="/study.github.io/img/loading.gif" alt="配置访问权限"></p><p>将此行修改为</p><pre><code>Allow from all      //允许所有ip访问</code></pre><p>右击wamp任务栏图片重启服务器（刷新失效时，请重启wamp）</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%87%8D%E5%90%AF%E6%9C%8D%E5%8A%A1%E5%99%A8.png" srcset="/study.github.io/img/loading.gif" alt="重启服务器"></p><p>PS：你当然也可以不将Deny from all 改为Allow from all，你可以在下方指定只有那些ip可以访问，如只允许192.168.32.222访问</p><p>在下方添加</p><pre><code>Allow from 192.168.32.222</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>查询本机ip地址，cmd中键入</p><pre><code>ipconfig</code></pre><p>其中IPV4 后便是本机ip地址，如（192.168.32.2）</p><p>在另一台设备中输入192.168.32.2，回车后访问成功（若显示访问被拒绝请确认配置正确，重启wamp，关闭防火墙后重试）</p><h2 id="四、更改wamp默认服务器根目录"><a href="#四、更改wamp默认服务器根目录" class="headerlink" title="四、更改wamp默认服务器根目录"></a>四、更改wamp默认服务器根目录</h2><p>本地服务器的默认根目录是安装根目录下的www文件夹。</p><p>可在该文件夹中新建一个index.html文件，再在浏览器中输入localhost/index.html访问该页面。</p><p>更改默认目录</p><p>打开 wamp –&gt; bin –&gt; apache –&gt; Apache2.4.4 –&gt; conf –&gt; httpd.conf文件，搜索关键词 DocumentRoot</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B9%E7%9B%AE%E5%BD%95.png" srcset="/study.github.io/img/loading.gif" alt="修改默认根目录"></p><p>将此两行的路径同时修改为你所创建的文件夹所在路径：</p><p>我在桌面的ClassPC文件夹下创建了www文件夹，以此作为根目录，则DocumentRoot改为C:/Users/student/Desktop/ClassPC/www</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B9%E7%9B%AE%E5%BD%952.png" srcset="/study.github.io/img/loading.gif" alt="更改默认根目录2"></p><p>重启wamp</p><h2 id="五、虚拟主机配置"><a href="#五、虚拟主机配置" class="headerlink" title="五、虚拟主机配置"></a>五、虚拟主机配置</h2><p>配置虚拟主机，以支持多站点</p><p>我们先在之前所设置好的服务器根目录(C:/Users/student/Desktop/ClassPC/www)下，新建三个文件夹 server1 server2 server3 (一个文件夹代表一个站点)</p><h3 id="配置httpd-vhosts-conf"><a href="#配置httpd-vhosts-conf" class="headerlink" title="配置httpd-vhosts.conf"></a>配置httpd-vhosts.conf</h3><p>打开 wamp –&gt; bin –&gt; apache –&gt; Apache2.4.4 –&gt; conf –&gt; extra –&gt; httpd-vhosts.conf</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE1.png" srcset="/study.github.io/img/loading.gif" alt="虚拟主机配置1"></p><p>一个表示一个站点</p><p>将已有标签复制三份，并分别设置其DocumentRoot ServerName ServerAlias，如下图所示</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE2.png" srcset="/study.github.io/img/loading.gif" alt="虚拟主机配置2"></p><h3 id="配置计算机映射关系"><a href="#配置计算机映射关系" class="headerlink" title="配置计算机映射关系"></a>配置计算机映射关系</h3><p>打开 计算机 –&gt; C: –&gt;windows –&gt; System32 –&gt; drivers –&gt; etc –&gt; host</p><p>在最下方添加映射关系，如图</p><p><img src="https://howlcn1997.github.io/2018/03/12/wamp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" srcset="/study.github.io/img/loading.gif" alt="配置映射关系"></p><p>重启wamp</p><p>浏览器输入localhost/server1,显示index of/server1,访问成功！</p><p>其他机器浏览器输入192.168.32.2/server1,显示index of/server1,访问成功！</p><hr><p>更新：若有购买腾讯云等云端服务器，在将Wamp部署到服务器时，请手动关闭Wamp自带的MySQL，MySQL的运行出错可能导致Apache的假死现象。</p><p>更新：关于Apache服务器<code>(OS 64)指定的网络名不再可用。 : AH00341: winnt_accept: Asynchronous AcceptEx failed.</code>错误而导致的Apache假死现象的解决：</p><ol><li>apache版本为APAche2.0.49及以上版本，增加<code>Win32DisableAcceptEx</code>配置项</li><li>apache版本为APAche2.4及以上版本，在<code>wamp\bin\apache\Apache2.4.4\conf\httpd.conf</code>增加<code>AcceptFilter http None AcceptFilter https None</code>配置项替代<code>Win32DisableAcceptEx</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Less的使用</title>
    <link href="/study.github.io/2018/07/06/Less%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/07/06/Less%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><p>less是动态的样式表<strong>语言</strong>，通过简明的语法定义，使编写cs’s的工作变得非常简单，本质上，less包含一套自定义的语法以及i一个解析器。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、安装Nodejs环境</p><p>2、cmd中执行</p><pre><code>npm install -g less</code></pre><p>3、验证</p><pre><code>lessc -v    //若正确出现less版本号则安装成功</code></pre><h2 id="使用less编译"><a href="#使用less编译" class="headerlink" title="使用less编译"></a>使用less编译</h2><p> 先创建一个less文件 demo.less</p><pre><code>@color: #ccc;div {    color: @color;}</code></pre><p> 在当前目录下运行cmd，输入</p><pre><code>lessc demo.less demo.css</code></pre><p>运行之后会在当前目录下生成一个demo.css文件，内容为</p><pre><code>div {  color: #ccc;}</code></pre><h2 id="VsCode中使用less"><a href="#VsCode中使用less" class="headerlink" title="VsCode中使用less"></a>VsCode中使用less</h2><p> 1、添加 Easy Less 扩展插件，安装，安装完后最好重启一次VSCode；</p><p> 2、在需要生成css文件的地方，新建一个<code>.less</code>文件；</p><p> 3、保存后，会在同级目录下自动生成一个同名css文件</p><h2 id="less的基本语法"><a href="#less的基本语法" class="headerlink" title="less的基本语法"></a>less的基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>/*注释*/        这种注释方式会也会编译到css中//              这种注释方式在编译时会被去除</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p> @变量名: 值</p><pre><code>@baseColor: #eee;     //申明一个变量并赋值a {    color: @@baseColor;   //使用变量}</code></pre><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><p> 可以将一个定义好的变量引入到另一个样式中 类似于函数的调用</p><pre><code>//先写好一个样式  @r 类似于函数的形参.addRadius(@r:10px){  //也可以设置默认值    border-radius: @r;    -wekit-border-radius: @r;    -moz-border-radius: @r;}//使用样式div {    width: 200px;    height: 200px;    .addRadius(5px);}</code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p> 可以实现选择器的继承，可以减少代码量，同时使代码结构更加清晰</p><pre><code>.jd_hearder {}.jd_hearder &gt; div {}.jd_hearder &gt; div &gt; h3 {}.jd_hearder &gt; div &gt; h3::before {}.jd_hearder    &gt; div &gt; a:hover {}</code></pre><p>上面是我们之前常用的写样式的方式，代码是非常冗余的，并且结构不清晰；</p><p>可以用less来解决这类问题，并且编译后的css文件，与上面的代码的效果是一样的</p><pre><code>.jd_header {    width: 100%；        height: 200px;    .addRadius();    //嵌套一个元素    div {        width: 100%;        h3 {            height: 200px;            ::before    //相当于 h3 ::before            $::before {}//相当于 h3::before     注意区别        }        a {            color: @baseColor;            $:hover {   //相当于 a:hover                text-decoration: none;            }        }    }    }</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于JavaScript中作用域/作用域链和预解析</title>
    <link href="/study.github.io/2018/07/02/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/study.github.io/2018/07/02/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析Javascript中作用域、作用域链和预解析"><a href="#浅析Javascript中作用域、作用域链和预解析" class="headerlink" title="浅析Javascript中作用域、作用域链和预解析"></a>浅析Javascript中作用域、作用域链和预解析</h1><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><pre><code>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</code></pre><p>作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p><h3 id="1-全局作用域（全局变量）"><a href="#1-全局作用域（全局变量）" class="headerlink" title="1.全局作用域（全局变量）"></a>1.全局作用域（全局变量）</h3><p><strong>全局变量，原理就是将变量挂载到window对象中.</strong></p><p><strong>全局变量拥有全局的作用域，可在任意地方被调用</strong></p><p>全局变量有两种声明方式</p><h3 id="（1）函数外部"><a href="#（1）函数外部" class="headerlink" title="（1）函数外部"></a>（1）函数外部</h3><p>(写在函数外面的都是全局变量)</p><pre><code>&lt;script&gt;    var num = 15; //全局变量        function f() {        var num = 10; //不是全局变量            function f2(){               /*----*/             }            f2();        }    f();    console.log(num); //  15&lt;/script&gt;</code></pre><h3 id="（2）函数内部"><a href="#（2）函数内部" class="headerlink" title="（2）函数内部"></a>（2）函数内部</h3><p>(不加var的变量声明，隐式全局变量)</p><pre><code>&lt;script&gt;    function f() {        num = 10; //隐式全局变量    }    f();    console.log(num); // 10&lt;/script&gt;</code></pre><h4 id="全局变量与隐式全局变量的区别"><a href="#全局变量与隐式全局变量的区别" class="headerlink" title="全局变量与隐式全局变量的区别"></a>全局变量与隐式全局变量的区别</h4><pre><code>隐式全局变量可以通过delete关键字来删除，全局变量不可以//全局变量不可被delete&lt;script&gt;    var a = 2; //全局变量    function f(){        //****    }    console.log(a); //  2    delete a;    console.log(a); //  2&lt;/script&gt;//隐式全局变量被delete&lt;script&gt;    function f(){        a = 2; //隐式全局变量    }    console.log(a); //  2    delete a;    console.log(a); //  not defined (已被删除)&lt;/script&gt;</code></pre><h3 id="2-局部作用域-局部变量"><a href="#2-局部作用域-局部变量" class="headerlink" title="2.局部作用域(局部变量)"></a>2.局部作用域(局部变量)</h3><pre><code>局部变量：写在函数体里面的变量局部变量只可以在当前函数内部使用&lt;script&gt;    function f() {        var num = 10; //局部变量        function f2(){            console.log(num); // 10        }        f2();    }    f();    console.log(num); //  not defined&lt;/script&gt;</code></pre><h2 id="二、作用域链"><a href="#二、作用域链" class="headerlink" title="二、作用域链"></a>二、作用域链</h2><p>作用域链简而言之就是，调用变量时，若当前作用域内没有该变量时就向它的上一级作用域去寻找。</p><p>Javascript用的是词法作用域（静态作用域）</p><p>实例：</p><pre><code>&lt;script&gt;    /* 0级作用域 */var a = 1;function aa(){    /* 1级作用域 */    //var a = 2;    function bb(){  /* 2级作用域 */        //var a = 3;        console.log(a);  // 1    }    bb();}aa();&lt;/script&gt;</code></pre><p>作用过程：</p><ol><li>当运行到console.log(a)时，会在当前作用域（2级作用域）内寻找是否有a可用；</li><li>若有直接使用，否则向上一级作用域（1级作用域）去寻找；</li><li>此时来到1级作用域，若此时有a可用则用，否则继续向上一级寻找，直到到达0级作用域；</li><li>此时来到0级作用域，若此时有a可用则用，否则报错；</li></ol><p><img src="https://howlcn1997.github.io/2018/02/26/%E6%B5%85%E6%9E%90Javascript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%A2%84%E8%A7%A3%E6%9E%90/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg" srcset="/study.github.io/img/loading.gif" alt="作用域链"></p><p><strong>值得注意的是：作用域链的始发点与函数的调用位置无关，而与函数的声明位置有关</strong> 例子如下：</p><pre><code>&lt;script&gt;    var value = 1;    function foo() {        console.log(value);    }    function bar() {        var value = 2;        foo();    }    bar();&lt;/script&gt;</code></pre><p>此时的打印结果为1，而不是foo函数调用所在作用域的value = 2；</p><p>这里的1是foo函数声明所在的作用域中的value = 1；</p><p>## 三、预解析</p><p>当浏览器执行Javascript代码时，为了提高执行效率会在代码解释执行前进行预解析处理。</p><p>预解析处理规则：</p><p>\1. 变量提升 仅仅将变量声明提升到当前作用域的最上面，不包括变量的赋值<br>\2. 函数提升 将函数的声明提升到当前作用域的最上面，不包括函数的调用 <strong>函数的声明会提前到变量声明之前</strong></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>实例：</p><pre><code>&lt;script&gt;    console.log(a); //undefined    var a = 10;&lt;/script&gt;</code></pre><p>上述代码结果打印为undefined,而不是10，这是为什么呢？</p><p>我们来看看与解析之后的结果，</p><p>预解析为：</p><pre><code>&lt;script&gt;    var a    console.log(a);    a = 10;&lt;/script&gt;</code></pre><p>由于变量声明被提升到作用域最前端，而赋值没有被提升，导致执行console.log(a);时 a还未被赋值。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>实例：</p><pre><code>&lt;script&gt;    f1();    function f1() {        /*-----*/    }&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function f1() {        /*-----*/    }    f1();&lt;/script&gt;</code></pre><h3 id="函数的声明会提前到变量声明之前"><a href="#函数的声明会提前到变量声明之前" class="headerlink" title="函数的声明会提前到变量声明之前"></a>函数的声明会提前到变量声明之前</h3><pre><code>函数提升和变量提升同时发生时，函数的声明会提前到变量声明之前。&lt;script&gt;    var a = 3;    function a(){        console.log(10);    }       console.log(a);    a();&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function a(){        console.log(10);    }    var a;    a = 3    console.log(a);    a(); //not function  因为此时a为变量而不是函数&lt;/script&gt;</code></pre><p><strong>值得注意的是：</strong></p><p>1.函数是可以被打印的</p><pre><code>&lt;script&gt;    function a(){    /*----*/    }console.log(a); //打印函数a&lt;/script&gt;</code></pre><p>2.变量a的赋值可以被普通类型和函数互相取代</p><pre><code>&lt;script&gt;    var a；    a = function(){        /*----*/        }    console.log(a); //打印函数a    a = 1;    console.log(a); // 1；&lt;/script&gt;</code></pre><h3 id="匿名函数的申明不遵循预解析规则"><a href="#匿名函数的申明不遵循预解析规则" class="headerlink" title="匿名函数的申明不遵循预解析规则"></a>匿名函数的申明不遵循预解析规则</h3><pre><code>&lt;script&gt;    f();  //报错    var f = function(){        /*----*/    }&lt;/script&gt;</code></pre><p>因为解析前后代码相同 执行 <strong>f()</strong> 时，f未被声明为函数类型。</p><h3 id="隐式全局变量的注意点"><a href="#隐式全局变量的注意点" class="headerlink" title="隐式全局变量的注意点"></a>隐式全局变量的注意点</h3><pre><code>&lt;script&gt;    f();    console.log(a);  //undefined    console.log(b);  //9    function f() {      var a = b = c = 9;      console.log(a); //9      console.log(b); //9    }&lt;/script&gt;</code></pre><p>被解析为：</p><pre><code>&lt;script&gt;    function f() {      var a;  //局部变量      a = 9;        b = 9;  //隐式全局变量      console.log(a);  //9      console.log(b);  //9    }    f();    console.log(b);  //9    console.log(a);  //undefined   因为a是局部变量&lt;/script&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于JS函数的重载问题</title>
    <link href="/study.github.io/2018/06/29/JS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2018/06/29/JS%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="关于Javascript的函数重载问题"><a href="#关于Javascript的函数重载问题" class="headerlink" title="关于Javascript的函数重载问题"></a>关于Javascript的函数重载问题</h1><p><strong>在Javascript与Java等语言不同，它自身没有重载的具体方法，但我们可以利用Javascript的特性来完成重载的效果</strong></p><h2 id="1-什么是重载"><a href="#1-什么是重载" class="headerlink" title="1.什么是重载"></a>1.什么是重载</h2><pre><code>重载，简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</code></pre><h2 id="2-Javascript如何实现重载"><a href="#2-Javascript如何实现重载" class="headerlink" title="2.Javascript如何实现重载"></a>2.Javascript如何实现重载</h2><h3 id="方法一：利用函数的arguments来完成函数的重载"><a href="#方法一：利用函数的arguments来完成函数的重载" class="headerlink" title="方法一：利用函数的arguments来完成函数的重载"></a>方法一：利用函数的arguments来完成函数的重载</h3><pre><code>//函数的声明function overLoading() {　　// 根据arguments.length，对不同的值进行不同的操作　　switch(arguments.length) {　　　　case 0: console.log(&#39;无参&#39;);　　　　　    break;　　　　case 1: console.log(&#39;一个参数&#39;);　　　　　    break;　　　　case 2: console.log(&#39;两个参数&#39;);              break;    } }//函数的调用overLoading();  //结果：无参overLoading(1);  //结果：一个参数overLoading(1,2);  //结果：两个参数</code></pre><h3 id="方法二：《Secrets-of-the-JavaScript-Ninja》中的方法"><a href="#方法二：《Secrets-of-the-JavaScript-Ninja》中的方法" class="headerlink" title="方法二：《Secrets of the JavaScript Ninja》中的方法"></a>方法二：《Secrets of the JavaScript Ninja》中的方法</h3><p>重载方法实例：</p><pre><code>function addMethod(object, name, fn) {　　var old = object[name];   //把前一次添加的方法存在一个临时变量old里面　　object[name] = function() {   // 重写了object[name]的方法　　　　// 如果调用object[name]方法时，传入的参数个数跟预期的一致，则直接调用　　　　if(fn.length === arguments.length) {　　　　　　return fn.apply(this, arguments);　　　　// 否则，判断old是否是函数，如果是，就调用old　　　　} else if(typeof old === &quot;function&quot;) {　　　　　　return old.apply(this, arguments);　　　　}　　}}</code></pre><p>所谓<strong>addMethod</strong>函数，简单的理解，就是给某个<strong>object</strong>，添加一个指定<strong>name</strong>的函数<strong>fn</strong>。它利用了<strong>闭包</strong>，可以通过<strong>old</strong>变量将先后绑定的函数链接起来。</p><p>你可以这样使用<strong>addMethod</strong>函数，将<strong>find</strong>函数直接添加到每个对象实例：</p><pre><code>function Users(){  addMethod(this, &quot;find&quot;, function(){      // Find All  });  addMethod(this, &quot;find&quot;, function(name){    // Find a user by name  });  addMethod(this, &quot;find&quot;, function(first, last){    // Find a user by first and last name  });}</code></pre><p>你也可以将<strong>find</strong>函数添加到对象的<strong>prototype</strong>，这样所有对象实例将共享<strong>find</strong>函数:</p><pre><code>function Users(){    addMethod(Users.prototype, &quot;find&quot;, function(){      // Find all users...    });    addMethod(Users.prototype, &quot;find&quot;, function(name){      // Find a user by name    });    addMethod(Users.prototype, &quot;find&quot;, function(first, last){      // Find a user by first and last name    });}</code></pre><p><strong>users</strong>对象的<strong>find</strong>方法成功实现了重载，可以根据不同的输入调用不同的函数：</p><pre><code>var users = new Users();users.find(); // Finds allusers.find(&quot;John&quot;); //  Finds users by nameusers.find(&quot;John&quot;, &quot;Resig&quot;); // Finds users by first and last nameusers.find(&quot;John&quot;, &quot;E&quot;, &quot;Resig&quot;); // Does nothing</code></pre><p>这种方法有一些明显的缺陷:</p><ul><li>重载只能处理输入参数个数不同的情况，它不能区分参数的类型、名称等其他要素。(ECMAScript 4计划支持这一特性，称作Multimethods，然而该版本已被放弃)。</li><li>重载过的函数将会有一些额外的负载，对于性能要求比较高的应用，使用这个方法要慎重考虑。</li></ul><p><strong>addMethod</strong>函数的秘诀之一在于<strong>fn.length</strong>。或许很多人并不清楚，所有函数都有一个<strong>length</strong>属性，它的值等于定义函数时的参数个数。比如，当你定义的函数只有1个参数时，其<strong>length</strong>属性为1：</p><pre><code>(function(foo){}).length == 1</code></pre><p>如果你担心只绑定单个函数时的性能问题，你可以使用如下<strong>addMethod</strong>函数：</p><pre><code>function addMethod(object, name, fn){    var old = object[ name ];    if ( old )        object[ name ] = function(){            if ( fn.length == arguments.length )                return fn.apply( this, arguments );            else if ( typeof old == &#39;function&#39; )                return old.apply( this, arguments );        };    else        object[ name ] = fn;}</code></pre><p>这样绑定第一个函数时，将不会有额外的操作，既简单又快速。当绑定更多函数时，则与原<strong>addMethod</strong>函数一样，会有额外的性能损失。</p><p>这样做还有一个额外的好处：对于那些参数个数不符合要求的函数调用，将统一又第一个绑定的函数处理。这时调用<strong>find</strong>方法的输出如下：</p><pre><code>var users = new Users();users.find(); // Finds allusers.find(&quot;John&quot;); // Finds users by nameusers.find(&quot;John&quot;, &quot;Resig&quot;); // Finds users by first and last nameusers.find(&quot;John&quot;, &quot;E&quot;, &quot;Resig&quot;); // Finds all</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Css3学习</title>
    <link href="/study.github.io/2018/06/26/Css3%E5%AD%A6%E4%B9%A0/"/>
    <url>/study.github.io/2018/06/26/Css3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h2><pre><code>width: 200px;height: 200px;border: 30px solid pink;box-sizing: border-box;border-image: url(./img/border1.png);/* 切割 */border-image-slice: 30 fill;/* 背景图会被拉升 */border-image-repeat: stretch;/* 将内容缩放进行完整的重复平铺 使得能够正好放下若干元素 */border-image-repeat: round;/* 背景会被直接平铺 */border-image-repeat: repeat;/* 设置边框图片的宽度 */border-image-width: 30px;/* 将背景图延伸到盒子外 不会放大 只会延伸 *//*放大中间部分*/border-image-outset: 100px;</code></pre><h2 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h2><h3 id="简单渐变"><a href="#简单渐变" class="headerlink" title="简单渐变"></a>简单渐变</h3><h4 id="简单线性渐变-linear-gradient"><a href="#简单线性渐变-linear-gradient" class="headerlink" title="简单线性渐变 linear-gradient"></a>简单线性渐变 linear-gradient</h4><pre><code>.box1{    width: 400px;    height: 800px;    margin: 10px auto;    /*linear-gradient(方向，开始颜色位置，颜色2位置，颜色3位置...)    1. to left：设置渐变为从右到左。相当于: 270deg;    2. to right：设置渐变从左到右。相当于: 90deg;       3. to top：设置渐变从下到上。相当于: 0deg;    4. to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。也可以直接指定度数，如45deg    */    background: linear-gradient(to right,pink,skyblue,yellowgreen,orange);    background: linear-gradient(20deg,pink,skyblue,yellowgreen,orange);    background: linear-gradient(-20deg,pink,skyblue,yellowgreen,orange);}</code></pre><h4 id="简单径向渐变radial-gradient"><a href="#简单径向渐变radial-gradient" class="headerlink" title="简单径向渐变radial-gradient"></a>简单径向渐变radial-gradient</h4><pre><code>.box2{    width: 400px;    height: 800px;    margin: 10px auto;    /* radial-gradient(·形状 大小 坐标·,颜色1，颜色2...) */    /* 圆形 */    background: radial-gradient(circle at center,pink,skyblue,yellowgreen,orange);    /* background: radial-gradient(circle at 200px 100px,pink,skyblue,yellowgreen,orange); */    /* 0%至10%是red渐变至green  10%至100%是green渐变至yellow */    background: radial-gradient(circle at 100px 100px,red 0%,green 10%,yellow 100%);    /* 椭圆 */    background: radial-gradient(ellipse at center,pink,skyblue,yellowgreen,orange);    /* 0%至20%是pink渐变至skyblue  20%至40%是skyblue渐变至yellowgreen  40%之后是纯yellowgreen */    background: radial-gradient(ellipse at 10px 100px,pink 0%,skyblue 20%,yellowgreen 40%);    /* 参数加入大小 */    /*    closest-side：最近边；      farthest-side：最远边；     closest-corner：最近角；      farthest-corner：最远角。默认是最远的角farthest-corner      */    /* 渐变的范围边缘触及最近的border结束 */    background: radial-gradient(circle closest-side at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最远的border结束 */    background: radial-gradient(circle farthest-side at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最近的角结束 */    background: radial-gradient(circle closest-corner at 100px 100px,pink,skyblue,yellowgreen,orange);    /* 渐变的范围边缘触及最圆的角结束 */    background: radial-gradient(circle farthest-corner at 10px 500px,pink,skyblue,yellowgreen,orange);}</code></pre><h3 id="重复渐变"><a href="#重复渐变" class="headerlink" title="重复渐变"></a>重复渐变</h3><h4 id="重复线性渐变repeating-linear-gradient"><a href="#重复线性渐变repeating-linear-gradient" class="headerlink" title="重复线性渐变repeating-linear-gradient"></a>重复线性渐变repeating-linear-gradient</h4><pre><code>/* 重复渐变 */.box3 {    width: 400px;    height: 800px;    margin: 10px auto;    /*线性重复性渐变    repeating-linear-gradient(角度,颜色1 %0,颜色2 %10)    */    background: repeating-linear-gradient(45deg,red 0%,red 3%,orange 3%,orange 6%,yellow 6%,yellow 9%,green 9%,green 12%,blue 12%,blue 15%,indigo 15%,indigo 18%,purple 18%,purple 21%); */    /* background: repeating-linear-gradient(45deg,#fff 0px,#fff 2px,#000 2px,#000 4px); */}</code></pre><h4 id="重复径向渐变repeating-radial-gradient"><a href="#重复径向渐变repeating-radial-gradient" class="headerlink" title="重复径向渐变repeating-radial-gradient"></a>重复径向渐变repeating-radial-gradient</h4><pre><code>.box4{    width: 400px;    height: 800px;    margin: 10px auto;    /*径向的重复性渐变    repeating-radial-gradient(形状 终点位置 at 起点位置,颜色1 0%,颜色2 5%,颜色3 10%)    */    background: repeating-radial-gradient(circle farthest-corner at 10px 20px,red 0%,red 3%,orange 3%,orange 6%,yellow 6%,yellow 9%,green 9%,green 12%,blue 12%,blue 15%,indigo 15%,indigo 18%,purple 18%,purple 21%);</code></pre><h3 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h3><p>多次使用渐变，利用透明度，达到交叉效果</p><pre><code>background: repeating-linear-gradient(45deg,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%),repeating-linear-gradient(-45deg,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%);    background: repeating-radial-gradient(circle farthest-corner at left top,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%),repeating-radial-gradient(circle farthest-corner at right top,rgba(0,0,0,.5) 0%,rgba(255,255,255,.5) 10%);}</code></pre><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E6%B8%90%E5%8F%98%E8%89%B2.png" srcset="/study.github.io/img/loading.gif" alt="渐变色"></p><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><pre><code>transition: 要过渡的属性  花费时间  运动曲线  何时开始;/*可以一次性设置，也可以分开设置*/    transition-property : 设置哪个属性要进行动画    transition-duration: 设置动画的时间    transition-timing-function : 设置动画运动的曲线(linear  ease  ease-in  ease-out  ease-in-out)    transition-delay : 设置动画延迟的时间</code></pre><h2 id="CSS-2D变形"><a href="#CSS-2D变形" class="headerlink" title="CSS 2D变形"></a>CSS 2D变形</h2><h3 id="translate-x-y"><a href="#translate-x-y" class="headerlink" title="translate(x, y)"></a>translate(x, y)</h3><pre><code>transform: translate(100px,100px);transform: translateX(100px);</code></pre><h3 id="缩放-scale-x-y"><a href="#缩放-scale-x-y" class="headerlink" title="缩放 scale(x, y)"></a>缩放 scale(x, y)</h3><pre><code>transform:scale(0.8,2.0);  //宽  高</code></pre><h3 id="旋转-rotate-deg"><a href="#旋转-rotate-deg" class="headerlink" title="旋转 rotate(deg)"></a>旋转 rotate(deg)</h3><p> 注意设置旋转中心点的时候不要设置在hover上</p><pre><code>transform:rotate(45deg);   //如果是正数，则顺时针，否则为逆时针transform-origin: left top; //默认为centertransform-origin: 10px 100px;</code></pre><h3 id="倾斜-skew-deg-deg"><a href="#倾斜-skew-deg-deg" class="headerlink" title="倾斜 skew(deg, deg)"></a>倾斜 skew(deg, deg)</h3><pre><code>transform:skew(45deg);</code></pre><p> 注意点角度不要是90的奇数整倍数，因为skew时，元素的高度是不发生变化的，当倾斜90度时元素的斜边要水平（上下边要与左右边重合）与高度不为零冲突，元素动画会 <strong>鬼畜</strong></p><p><strong>添加多个变形动画时用空格隔开，如</strong></p><pre><code>transform: rotate(45deg) translateX(100px);</code></pre><h3 id="坐标系问题"><a href="#坐标系问题" class="headerlink" title="坐标系问题"></a>坐标系问题</h3><p>下面两种的效果是不同的</p><pre><code>（1）transform: rotate(45deg) translateX(100px); （2）transform: translateX(100px) rotate(45deg);</code></pre><p>这是因为元素在进行2D变化时是根据坐标轴的，而旋转和缩放会改变坐标轴，发生意想不到的结果。但好好利用可以做出好的动画效果。</p><pre><code>transform: rotate(700deg) translateX(100px); /*达到蜗牛旋转效果*/</code></pre><h2 id="盒子居中的方法"><a href="#盒子居中的方法" class="headerlink" title="盒子居中的方法"></a>盒子居中的方法</h2><h3 id="盒子水平居中的办法"><a href="#盒子水平居中的办法" class="headerlink" title="盒子水平居中的办法"></a>盒子水平居中的办法</h3><p> 1、text-align: center</p><p> 2、margin: auto; 元素需要时block</p><h3 id="盒子垂直居中的办法"><a href="#盒子垂直居中的办法" class="headerlink" title="盒子垂直居中的办法"></a>盒子垂直居中的办法</h3><p> 1、line-height</p><p> 2、padding</p><h3 id="盒子垂直水平居中的方法"><a href="#盒子垂直水平居中的方法" class="headerlink" title="盒子垂直水平居中的方法"></a>盒子垂直水平居中的方法</h3><h4 id="利用transform让盒子垂直水平居中"><a href="#利用transform让盒子垂直水平居中" class="headerlink" title="利用transform让盒子垂直水平居中"></a>利用transform让盒子垂直水平居中</h4><pre><code>width: 200px;height: 200px;background-color: red;position: absolute;/*transform 百分比参照的是元素本身的宽高*/transform: translate(-50%,-50%); /*left和top参照的是父容器宽高的50%*/left: 50%;top:50%;</code></pre><h4 id="利用margin"><a href="#利用margin" class="headerlink" title="利用margin"></a>利用margin</h4><pre><code>position:fixed;width:200px;height:200px;left:50%;top:50%;margin-left:-100px;margin-top:-100px;</code></pre><h4 id="calc和定位的组合使用"><a href="#calc和定位的组合使用" class="headerlink" title="calc和定位的组合使用"></a>calc和定位的组合使用</h4><pre><code>top: calc(50% - 元素高度/2);left: calc(50% - 元素宽度/2);</code></pre><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><pre><code>/*    有：    background-color        背景颜色        background-image        背景图片地址        background-repeat        是否平铺  查手册了解其取值        background-position        背景位置       查手册了解其取值 left right center top bottom  两两搭配                                            使用方位名词时，前后无顺序要求；但是使用数字10px 10px时注意前后顺序        background-attachment    背景固定还是滚动*/div{    width: 400px;    height: 400px;    background-color: skyblue;    background-repeat: no-repeat;/*大小自适应充满*/    background-image: url(../img/girl.jpg);    background-size: 200px;    background-position: center;    /*background-position: 30px 10px;第一个值为X轴 第二个值为Y轴    其中网页顶端为X轴  右为正方向   左边为Y轴  下为正方向*/    /*background-position: 10px center;*/}</code></pre><h2 id="背景缩放"><a href="#背景缩放" class="headerlink" title="背景缩放"></a>背景缩放</h2><pre><code>div{    width: 800px;    height: 500px;    background: #000 url(../img/王者荣耀背景图.jpg) no-repeat top center;    /*background-size: 100px 100px;     设置两个属性值可能导致图片失真扭曲    background-size: 100px;   尽量使用一个属性值 另一个属性值会等比例缩放*/    /*background-size: 50%;     使用一个值 另一个值等比例缩放*/    background-size:cover;     /*会自动  |等比例缩放|  保证图片充满容器 但有可能图片溢出导致部分图片无法显示  【最常用】*/    /*background-size:contain;    等比例缩放，过程中图片的高度或者宽度任意一个属性值满足容器高宽时就停止缩放，保证图片完整性，但可能无法充满容器*/}</code></pre><h2 id="多背景"><a href="#多背景" class="headerlink" title="多背景"></a>多背景</h2><pre><code>/*一个元素可以设置多重背景图像；    每组属性之间使用逗号分隔    如果设置的多重背景图之间存在交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上    为了避免背景色将图像盖住，背景色通常都定义在最后一组上。*/div{    width: 500px;    height: 500px;    /*background: pink url(../img/水浒传.jpg) no-repeat fixed center center;  此处添加fixed后 该图片便以body为容器*/    background: url(../第1阶段HTML/img/水浒传.jpg) no-repeat left top,        url(../第1阶段HTML/img/三国演义.jpg) no-repeat right bottom pink;/*当一个div中需要出现多个背景图片时 中间用逗号隔开。值得注意的是：背景色的设置要放在最后一个设置中，不然会覆盖之前的图片效果*/}</code></pre><h2 id="凹凸文字"><a href="#凹凸文字" class="headerlink" title="凹凸文字"></a>凹凸文字</h2><pre><code>/*凸起*//*text-shadow:水平位置 垂直位置 模糊位置 阴影颜色  右和下为正方向*/text-shadow: 1px 1px 1px #000,-1px -1px 1px #fff;/*凹下*//*text-shadow:水平位置 垂直位置 模糊位置 阴影颜色  右和下为正方向*/text-shadow: 1px 1px 1px #fff,-1px -1px 1px #000;</code></pre><h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2><h3 id="观察距离"><a href="#观察距离" class="headerlink" title="观察距离"></a>观察距离</h3><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E6%99%AF%E6%B7%B1.png" srcset="/study.github.io/img/loading.gif" alt="景深"></p><pre><code>perspective:1000px; /*设置视角与投射面的距离*/</code></pre><p>注意的是：若要给某元素设置景深效果，那么perspective要设置在他的父元素上</p><p>分别设置 transform: translateZ()后的效果</p><pre><code>transform: translateZ(0px);transform: translateZ(500px);transform: translateZ(999px);transform: translateZ(1001px);</code></pre><h3 id="视角观察点"><a href="#视角观察点" class="headerlink" title="视角观察点"></a>视角观察点</h3><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/%E8%A7%82%E5%AF%9F%E7%82%B9.png" srcset="/study.github.io/img/loading.gif" alt="观察点"></p><p>默认为中心（center center）</p><pre><code>perspective-origin: left top;/*是body的左上角*/perspective-origin: 0px 0px; /*也可以精确化垂点*/</code></pre><h3 id="利用景深达到伪3d效果"><a href="#利用景深达到伪3d效果" class="headerlink" title="利用景深达到伪3d效果"></a>利用景深达到伪3d效果</h3><pre><code>body {    perspective: 1000px;    /*设置视角观察方向 且是相对于body的，且视角是一直垂直与body的*/    perspective-origin: left top;/*是body的左上角*/}.box {    width: 200px;    height: 200px;    border: 2px solid black;    /*transition 设置过渡动画*/    transition: all  1s;}.box1:hover {    transform: translateZ(500px);}&lt;div class=&quot;box box1&quot;&gt;&lt;/div&gt;</code></pre><p>当鼠标移动到box上时触发 transform: translateZ(500px); 致使box在他的Z轴上正方向移动500px;而他的父元素body设置了观察点为body的左上角，则box的移动轨迹是向右下角的。</p><h2 id="3d变形"><a href="#3d变形" class="headerlink" title="3d变形"></a>3d变形</h2><p>(注：3d变形结合景深后可以呈现空间立体效果。)</p><p>每个元素都有自己的坐标系</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/3d%E5%9D%90%E6%A0%87%E7%B3%BB.png" srcset="/study.github.io/img/loading.gif" alt="3d坐标系"></p><h3 id="translate3d-x-y-z"><a href="#translate3d-x-y-z" class="headerlink" title="translate3d(x,y,z)"></a>translate3d(x,y,z)</h3><p>例：</p><pre><code>.box1 {    transform: translate3d(100px,-50px,500px);}/*向x轴正方向移动100px 向y轴负方向移动50px  向z轴正方向移动500px*/</code></pre><h3 id="rotate3d-x-y-z-angle"><a href="#rotate3d-x-y-z-angle" class="headerlink" title="rotate3d(x,y,z,angle)"></a>rotate3d(x,y,z,angle)</h3><p>[x,y,z]向量，定义旋转轴；</p><p>angle定义旋转角度，正值为顺时针，负值为逆时针；</p><p> <strong>关于向量的运作原理</strong></p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F1.png" srcset="/study.github.io/img/loading.gif" alt="1560564644997"></p><p>[x,y,z]向量为[0,0,1]时代表z轴，旋转绕z轴旋转</p><p>[x,y,z]向量为[0,1,0]时代表y轴，旋转绕y轴旋转</p><p>[x,y,z]向量为[1,0,0]时代表x轴，旋转绕x轴旋转</p><p>[x,y,z]向量为[1,1,1]时，旋转轴如图绿色线所示</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F2.png" srcset="/study.github.io/img/loading.gif" alt="1560564933962"></p><p>再加上旋转角度后：</p><pre><code>.box2 {    transform: rotate3d(1,1,1,45deg);}</code></pre><p>效果</p><p><img src="https://howlcn1997.github.io/2018/02/15/CSS3/rotate%E5%90%91%E9%87%8F3.png" srcset="/study.github.io/img/loading.gif" alt="1560565807459"></p><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p> transform-origin: x-axis y-axis z-axis;</p><h3 id="scale3d-x-y-z"><a href="#scale3d-x-y-z" class="headerlink" title="scale3d(x,y,z)"></a>scale3d(x,y,z)</h3><pre><code>/* transform: scaleX(0.5); *//* transform: scaleY(0.5); *//*元素没有厚度 Z轴上的缩放暂时是没有意义的*/scale3d(2,2,0.5);</code></pre><h3 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h3><pre><code>/*当图片不是正面对象用户的时候就隐藏*/backface-visibility: hidden;</code></pre><h3 id="preserve-3d"><a href="#preserve-3d" class="headerlink" title="preserve-3d"></a>preserve-3d</h3><p> 让元素以3d效果去呈现 他是添加在父元素上的一个属性</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p> 关键帧动画(animation)：允许我们在多个状态之间进行动画</p><p> 过渡动画(transition )：允许我们在两个状态之间进行动画</p><p>1、先申明动画函数</p><pre><code>@keyframes Animate{    0%{        /* 可以同时对多个属性添加动画效果 */        transform: scale3d(1,1,1);    }    50%{        transform: scale3d(2,2,2);    }    100%{        transform: scale3d(1,1,1);    }}</code></pre><p>2、使用 并配置</p><pre><code>.box:hover{    /*动画的名字 调用动画函数*/    animation-name: Animate;    /*动画持续的时间*/    animation-duration: 2s;    /*动画延迟多长时间执行*/    animation-delay: 1s;    /*动画运动的曲线  linear匀速动画*/    animation-timing-function: linear;    /*指定动画执行的次数*/    animation-iteration-count: infinite;    /*让动画结束之后保留在动画结束的状态*/    animation-fill-mode: forwards;     /*让动画结束之后保留在动画初始的状态*/    /* animation-fill-mode: backwards;  */}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Photoshop的简单使用</title>
    <link href="/study.github.io/2018/06/24/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/06/24/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Photoshop图像处理专家"><a href="#Photoshop图像处理专家" class="headerlink" title="Photoshop图像处理专家"></a>Photoshop图像处理专家</h1><h2 id="1-学习Ps的目的"><a href="#1-学习Ps的目的" class="headerlink" title="1. 学习Ps的目的"></a>1. 学习Ps的目的</h2><p>虽然ps应该是UI的拿手好戏，但作为前端开发人员，在日常写程序的过程中不免会有用到Ps的时候，会使用Ps可以使得与前端的交接工作变得顺利。</p><p>前端人员的Ps学习目的：</p><p><strong>1) 会简单的抠图</strong></p><p><strong>2) 会简单的修改PSD效果图</strong></p><p><strong>3) 熟练的切图</strong></p><h2 id="2-Photoshop的安装"><a href="#2-Photoshop的安装" class="headerlink" title="2.Photoshop的安装"></a>2.Photoshop的安装</h2><p>现阶段我门使用的是Photoshop-CC（阉割版）</p><p>(64bit) <a href="https://pan.baidu.com/s/1W9b0F-CdHrzIirJpd50Ang" target="_blank" rel="noopener">百度云下载地址</a> 提取码：2rhu</p><p>(32bit) <a href="https://pan.baidu.com/s/1MU-KOriQ8fenWZgxJAX-Vw" target="_blank" rel="noopener">百度云下载地址</a> 提取码： vjmr</p><h2 id="3-Photoshop的界面认识"><a href="#3-Photoshop的界面认识" class="headerlink" title="3.Photoshop的界面认识"></a>3.Photoshop的界面认识</h2><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img1.png" srcset="/study.github.io/img/loading.gif" alt="img1"></p><h2 id="4-Photoshop的基本操作"><a href="#4-Photoshop的基本操作" class="headerlink" title="4.Photoshop的基本操作"></a>4.Photoshop的基本操作</h2><p>基本设置</p><p><strong>视图 –&gt; 标尺</strong></p><p><strong>窗口 –&gt; 信息</strong></p><p><strong>右击标尺可选择标尺单位</strong></p><h3 id="1-新建文件"><a href="#1-新建文件" class="headerlink" title="1) 新建文件"></a>1) 新建文件</h3><pre><code>文件 --&gt; 新建         //Ctrl+n</code></pre><ol><li>在新建对话框中如果宽度和高度的单位不是像素，要改成以像素为单位。平日的开发都是以像素为单位的。</li><li>分辨率固定72，为了避免出现预期之外错误，此值固定不变。</li></ol><h3 id="2-关闭文件"><a href="#2-关闭文件" class="headerlink" title="2) 关闭文件"></a>2) 关闭文件</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img2.png" srcset="/study.github.io/img/loading.gif" alt="img2"></p><p>或者</p><pre><code>Ctrl+W</code></pre><h3 id="3-保存文件"><a href="#3-保存文件" class="headerlink" title="3) 保存文件"></a>3) 保存文件</h3><pre><code>文件 --&gt; 保存        //Ctrl+s</code></pre><h3 id="4-移动工具与缩放变形"><a href="#4-移动工具与缩放变形" class="headerlink" title="4) 移动工具与缩放变形"></a>4) 移动工具与缩放变形</h3><h4 id="移动工具"><a href="#移动工具" class="headerlink" title="移动工具"></a>移动工具</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img3.png" srcset="/study.github.io/img/loading.gif" alt="img3"></p><p>使用案例：将一张图添加到另一张图中。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img4.png" srcset="/study.github.io/img/loading.gif" alt="img4"></p><p>打开一文件后，鼠标左击图片标题不动，向下拖拽成</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img5.png" srcset="/study.github.io/img/loading.gif" alt="img5"></p><p>这时再利用移动工具，将图片移动到目标图片上</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img6.png" srcset="/study.github.io/img/loading.gif" alt="img6"></p><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><pre><code>按住ctrl，鼠标即可对当前图层拖拽，要移动哪个图形，就在在图层面板中选中该图形所在的图层。按方向键可以微调。</code></pre><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><pre><code>Ctrl+t   //当前图层显示变换控件，也可以直接点击工具属性栏中的按钮按住shift可以等比例缩放</code></pre><p>操作完成后，ENTER回车，确认操作。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img7.png" srcset="/study.github.io/img/loading.gif" alt="img7"></p><h3 id="5-图层操作"><a href="#5-图层操作" class="headerlink" title="5) 图层操作"></a>5) 图层操作</h3><pre><code>F7   //图层面板显示/消失按钮</code></pre><h4 id="新建图层与删除"><a href="#新建图层与删除" class="headerlink" title="新建图层与删除"></a>新建图层与删除</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img8.png" srcset="/study.github.io/img/loading.gif" alt="img8"></p><h4 id="图层层叠"><a href="#图层层叠" class="headerlink" title="图层层叠"></a>图层层叠</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img9.png" srcset="/study.github.io/img/loading.gif" alt="img9"></p><p>此时鸣人是压着佐助的，这时因为佐助所在的图层在鸣人所在图层的下面。</p><p>我们将图层2 拖住至图层1上方，此时佐助就跑到鸣人上面了。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img10.png" srcset="/study.github.io/img/loading.gif" alt="img10"></p><h4 id="图层复制"><a href="#图层复制" class="headerlink" title="图层复制"></a>图层复制</h4><p>选择移动工具后</p><pre><code>1.按住Alt 拖拽图像2.Ctrl+j (重合复制)</code></pre><h4 id="图层编组"><a href="#图层编组" class="headerlink" title="图层编组"></a>图层编组</h4><p>选定所有待分组图层后</p><pre><code>ctrl+g  //创建分组ctrl+shift+g //取消分组</code></pre><p>图层或编组重命名</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img11.png" srcset="/study.github.io/img/loading.gif" alt="img11"></p><p>组操作或图层操作切换</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img12.png" srcset="/study.github.io/img/loading.gif" alt="img12"></p><h4 id="图层合并"><a href="#图层合并" class="headerlink" title="图层合并"></a>图层合并</h4><p>选中待合并图层后</p><pre><code>ctrl+e</code></pre><h4 id="图层的不透明度"><a href="#图层的不透明度" class="headerlink" title="图层的不透明度"></a>图层的不透明度</h4><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img13.png" srcset="/study.github.io/img/loading.gif" alt="img13"></p><h3 id="6-选区工具"><a href="#6-选区工具" class="headerlink" title="6) 选区工具"></a>6) 选区工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img14.png" srcset="/study.github.io/img/loading.gif" alt="img14"></p><pre><code>Ctrl+D  //取消分区</code></pre><h3 id="7-磁性套索工具"><a href="#7-磁性套索工具" class="headerlink" title="7) 磁性套索工具"></a>7) 磁性套索工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img15.png" srcset="/study.github.io/img/loading.gif" alt="磁性套索工具"></p><h3 id="8-魔棒工具"><a href="#8-魔棒工具" class="headerlink" title="8) 魔棒工具"></a>8) 魔棒工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img16.png" srcset="/study.github.io/img/loading.gif" alt="魔棒工具"></p><p><strong>容差的概念：简单来说，容差越大选区范围越广，容差越小选区范围越宅</strong></p><h3 id="9-选区的布尔运算"><a href="#9-选区的布尔运算" class="headerlink" title="9) 选区的布尔运算"></a>9) 选区的布尔运算</h3><p>就是在原有选区的基础上，加上新的选区或减去分区。</p><pre><code>按住shift 再继续选区   //加选区按住Alt  再选区    //减选区Ctrl+shift+i   //反选</code></pre><h3 id="10-钢笔工具"><a href="#10-钢笔工具" class="headerlink" title="10) 钢笔工具"></a>10) 钢笔工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img17.png" srcset="/study.github.io/img/loading.gif" alt="钢笔工具"></p><ol><li>点击第一个点</li><li>再点击第二点时按住鼠标不动进行拖拽，会形成一个可控的弧线</li><li>上一条线为弧线后，与下一个点之间会默认为弧（取消办法：按住Alt，点击上一个点，即可取消）</li><li>完成一个闭合曲线</li><li>Ctrl+ENTER 形成选区</li></ol><h3 id="11-文字工具"><a href="#11-文字工具" class="headerlink" title="11) 文字工具"></a>11) 文字工具</h3><p>略</p><h3 id="12-吸管工具"><a href="#12-吸管工具" class="headerlink" title="12) 吸管工具"></a>12) 吸管工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img18.png" srcset="/study.github.io/img/loading.gif" alt="吸管工具1"></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img19.png" srcset="/study.github.io/img/loading.gif" alt="吸管工具2"></p><h3 id="13）切片工具"><a href="#13）切片工具" class="headerlink" title="13）切片工具"></a>13）切片工具</h3><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img20.png" srcset="/study.github.io/img/loading.gif" alt="切片工具"></p><h4 id="手动切片"><a href="#手动切片" class="headerlink" title="手动切片"></a>手动切片</h4><p>1.用切片工具选取目标区域</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img21.png" srcset="/study.github.io/img/loading.gif" alt="切片选区"></p><p>2.<strong>文件 –&gt;储存为web所用格式</strong></p><pre><code>Alt+Ctrl+shift+S  //存储为web所用格式快捷键</code></pre><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img22.png" srcset="/study.github.io/img/loading.gif" alt="选定格式"></p><p><strong>存储时，要记得选中“选中的切片”</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img23.png" srcset="/study.github.io/img/loading.gif" alt="储存"></p><h4 id="图层切片"><a href="#图层切片" class="headerlink" title="图层切片"></a>图层切片</h4><p>1.选中目标图层</p><p>2.<strong>图层 –&gt; 新建基于图层的切片</strong></p><p>3.存储</p><h3 id="辅助线切图"><a href="#辅助线切图" class="headerlink" title="辅助线切图"></a>辅助线切图</h3><p>1.标尺部分拖拽出辅助线，将图片进行分割。</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img25.png" srcset="/study.github.io/img/loading.gif" alt="辅助线切图"></p><p>2.点击属性栏中的基于参考线的切片</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img26.png" srcset="/study.github.io/img/loading.gif" alt="基于参考线的切片"></p><p>3.存储</p><h3 id="等份数切片"><a href="#等份数切片" class="headerlink" title="等份数切片"></a>等份数切片</h3><p>1.<strong>切片选择工具 –&gt;划分</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img27.png" srcset="/study.github.io/img/loading.gif" alt="等分数切片"></p><p>2.选择等份切片方式</p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img28.png" srcset="/study.github.io/img/loading.gif" alt="划分"></p><p>3.存储</p><h4 id="清除全部切片和辅助线"><a href="#清除全部切片和辅助线" class="headerlink" title="清除全部切片和辅助线"></a>清除全部切片和辅助线</h4><p>1.视图 –&gt; 清除切片</p><p>2.视图 –&gt; 清除参考线</p><h4 id="切片注意"><a href="#切片注意" class="headerlink" title="切片注意"></a>切片注意</h4><p><strong>1.当切片时发现有其他图层盖住了目标图层，用利用“小眼睛”将其他图层隐藏</strong></p><p><img src="https://howlcn1997.github.io/2018/02/10/Photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/img24.png" srcset="/study.github.io/img/loading.gif" alt="切片注意"></p><p><strong>2.切片存储时，若要一次存储多个切片，可按住shift再点击目标切片</strong></p><h2 id="5-Photoshop的快捷键"><a href="#5-Photoshop的快捷键" class="headerlink" title="5.Photoshop的快捷键"></a>5.Photoshop的快捷键</h2><ol><li>Ctrl+Z //撤销上一步</li><li>Alt+Ctrl+Z //撤销多步</li><li>Alt+滚轮 //放大、缩小</li><li>Ctrl+滚轮 //左右移动</li><li>Ctrl+D //取消选择</li><li>Ctrl+shift+D //重新选择</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Npm与Yarn的使用</title>
    <link href="/study.github.io/2018/06/21/Npm%E4%B8%8EYarn%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/study.github.io/2018/06/21/Npm%E4%B8%8EYarn%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-amp-YARN"><a href="#NPM-amp-YARN" class="headerlink" title="NPM&amp;YARN"></a>NPM&amp;YARN</h1><h2 id="npm常用的命令"><a href="#npm常用的命令" class="headerlink" title="npm常用的命令"></a>npm常用的命令</h2><p>全局安装：默认安装在Node.js环境的node_modules目录下，全局安装的包一般用于命令行工具</p><p>本地安装：一般用于开发某种具体的功能</p><p> 1、安装包（若不指定版本号 默认安装最新版本）</p><pre><code>npm install -g 安装包名称     （全局安装）npm install 安装包名称      （本地安装）</code></pre><pre><code>例： npm install es-checker     //安装es6例： npm install</code></pre><p>2、卸载包</p><pre><code>npm uninstall -g 安装包名称     （全局卸载）npm uninstall 安装包名称      （本地卸载）例： npm uninstall es-checker     //卸载es6</code></pre><p>3、更新包 （更新到最新版本号）</p><pre><code>npm updata -g 安装包名称</code></pre><p>4、添加依赖</p><pre><code>--save   （向生产环境添加依赖） 生产环境是项目部署上线之后的服务器环境--save-dev   （向开发环境添加依赖） 开发环境是平时开发使用的环境//例子：npm install es-checker --save//例子：npm install es-checker --save-dev</code></pre><p>安装服务器自动重启</p><pre><code>npm install -g nodemon</code></pre><h2 id="npm安装包的步骤"><a href="#npm安装包的步骤" class="headerlink" title="npm安装包的步骤"></a>npm安装包的步骤</h2><p>1、初始化</p><pre><code>npm init //初始化 生成package.json文件</code></pre><p>2、安装包</p><pre><code>npm install 安装包名称      （本地安装）</code></pre><p>3、若存在package.json文件 和 package-lock.json文件，恢复安装</p><pre><code>npm install</code></pre><h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p>安装yarn工具</p><pre><code>npm install -g yarn</code></pre><h2 id="yarn中的命令"><a href="#yarn中的命令" class="headerlink" title="yarn中的命令"></a>yarn中的命令</h2><p>1、初始化包</p><pre><code>npm init  //npm中的初始化方式yarn init  //yarn中初始化方式</code></pre><p>2、安装包</p><pre><code>npm install xxx --save //npm中的安装方式yarn add xxx  //yarn中的安装方式</code></pre><p>3、移除包</p><pre><code>npm uninstall xxx  //npm中的移除方式yarn remove xxx  //yarn中的移除方式</code></pre><p>4、更新包</p><pre><code>npm update xxxyarn upgrade xxx</code></pre><p>5、安装开发依赖的包</p><pre><code>npm install xxx --save-devyarn  add xxx --dev</code></pre><p>6、全局安装</p><pre><code>npm install -g xxxyarn globar add xxx</code></pre><p>7、设置下载镜像的地址</p><pre><code>npm config set registry urlyarn config set registry url</code></pre><p>8、安装所有依赖</p><pre><code>npm installyarn install</code></pre><p>9、执行包</p><pre><code>npm runyarn run</code></pre><h1 id="切换源"><a href="#切换源" class="headerlink" title="切换源"></a>切换源</h1><p>安装nrm</p><pre><code>npm install nrm</code></pre><p>查看源</p><pre><code>nrm ls</code></pre><p>切换</p><pre><code>nrm xxx</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于浮动的若干问题</title>
    <link href="/study.github.io/2018/06/20/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <url>/study.github.io/2018/06/20/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标准文档流"><a href="#1-标准文档流" class="headerlink" title="1.标准文档流"></a>1.标准文档流</h1><p>标准流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做标准流布局。</p><h1 id="2-浮动"><a href="#2-浮动" class="headerlink" title="2.浮动"></a>2.浮动</h1><h2 id="2-1-浮动的机制"><a href="#2-1-浮动的机制" class="headerlink" title="2.1 浮动的机制"></a>2.1 浮动的机制</h2><p>当有两个div同时在标准刘文档中的时候，两个div会隔行显示：</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img1.png" srcset="/study.github.io/img/loading.gif" alt="img1"></p><pre><code>(2D图)</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img4.png" srcset="/study.github.io/img/loading.gif" alt="img4"></p><pre><code>**（3D图）**</code></pre><p>当将蓝色div对应的CSS添加浮动属性后，蓝色div会脱离标准流，而浮在标准流之上</p><pre><code>float: left;</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img2.png" srcset="/study.github.io/img/loading.gif" alt="img2"></p><pre><code>**（2D图）**</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img5.png" srcset="/study.github.io/img/loading.gif" alt="img5"></p><pre><code>**（3D图）**</code></pre><p>将蓝色div和红色div同时设置浮动属性后，两者都处于浮动的层次，显示方式默认为贴边水平并排显示</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img3.png" srcset="/study.github.io/img/loading.gif" alt="img3"></p><pre><code>**（2D图）**</code></pre><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img6.png" srcset="/study.github.io/img/loading.gif" alt="img6"></p><pre><code>**（3D图）**</code></pre><h2 id="2-2-浮动的使用"><a href="#2-2-浮动的使用" class="headerlink" title="2.2 浮动的使用"></a>2.2 浮动的使用</h2><pre><code>选择器{float:属性值;}</code></pre><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">元素向左浮动</td></tr><tr><td align="center">right</td><td align="center">元素向右浮动</td></tr><tr><td align="center">none</td><td align="center">元素不浮动（默认值）</td></tr></tbody></table><h2 id="2-3-清除浮动"><a href="#2-3-清除浮动" class="headerlink" title="2.3 清除浮动"></a>2.3 清除浮动</h2><h3 id="2-3-1-为什么要清除浮动"><a href="#2-3-1-为什么要清除浮动" class="headerlink" title="2.3.1 为什么要清除浮动"></a>2.3.1 为什么要清除浮动</h3><p>浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现。</p><p>由于<strong>浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</strong>，为了解决这些问题，此时就需要在该元素中清除浮动。</p><p>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p><h3 id="2-3-2-清除浮动的本质"><a href="#2-3-2-清除浮动的本质" class="headerlink" title="2.3.2 清除浮动的本质"></a>2.3.2 清除浮动的本质</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。</p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img7.jpg" srcset="/study.github.io/img/loading.gif" alt="img7"></p><p><img src="https://howlcn1997.github.io/2018/01/25/%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/img8.jpg" srcset="/study.github.io/img/loading.gif" alt="img8"></p><h3 id="2-3-3-清除浮动的方法"><a href="#2-3-3-清除浮动的方法" class="headerlink" title="2.3.3 清除浮动的方法"></a>2.3.3 清除浮动的方法</h3><h4 id="1-用clear属性清除浮动"><a href="#1-用clear属性清除浮动" class="headerlink" title="1)用clear属性清除浮动"></a>1)用clear属性清除浮动</h4><pre><code>选择器{clear:属性值;}</code></pre><table><thead><tr><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td align="center">right</td><td align="center">不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td align="center">both</td><td align="center">同时清除左右两侧浮动的影响</td></tr></tbody></table><h4 id="2-额外标签法"><a href="#2-额外标签法" class="headerlink" title="2)额外标签法"></a>2)额外标签法</h4><p>在浮动元素末尾添加一个大小为0，内容为空的标签，如：</p><pre><code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></pre><p><strong>（不推荐）</strong></p><h4 id="3-父级添加overflow属性方法"><a href="#3-父级添加overflow属性方法" class="headerlink" title="3)父级添加overflow属性方法"></a>3)父级添加overflow属性方法</h4><p>给父级元素添加</p><pre><code>overflow： hidden；  /*auto、scroll都可以*/</code></pre><h4 id="4-使用after伪元素清除浮动"><a href="#4-使用after伪元素清除浮动" class="headerlink" title="4) 使用after伪元素清除浮动"></a>4) 使用after伪元素清除浮动</h4><p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong> 。</p><pre><code>.clearfix::after {  content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden;  }   .clearfix {*zoom: 1;}   /*IE6、7 专有 ，星号表示IE7之下浏览器识别，其他浏览器不识别*/                                    /*然后给父元素加上clearfix类就可以了*/</code></pre><h4 id="5-使用before和after双伪元素清除浮动"><a href="#5-使用before和after双伪元素清除浮动" class="headerlink" title="5)使用before和after双伪元素清除浮动"></a>5)使用before和after双伪元素清除浮动</h4><pre><code>.clearfix::before,.clearfix::after {   content:&quot;&quot;;  display:table;  }.clearfix:after {  clear:both;}.clearfix {  *zoom:1;} /*然后给父元素加上clearfix类就可以了*/</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/study.github.io/2018/06/19/Ajax/"/>
    <url>/study.github.io/2018/06/19/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="什么是AJAX？"><a href="#什么是AJAX？" class="headerlink" title="什么是AJAX？"></a>什么是AJAX？</h2><p> Ajax（Asynchronous JavaScript and XML的缩写）是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。</p><p><strong>AJAX的好处</strong>：可以通过<code>js</code>代码发送get或者post的请求去从后台获取到相应数据，并只对页面中的部分标签进行刷新渲染，而不需要刷新整个页面，节约了带宽，优化了性能</p><h2 id="创建AJAX对象"><a href="#创建AJAX对象" class="headerlink" title="创建AJAX对象"></a>创建AJAX对象</h2><pre><code>//兼容性写法  ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);是为了兼容IE5 IE6var ajax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);</code></pre><h2 id="AJAX的方法"><a href="#AJAX的方法" class="headerlink" title="AJAX的方法"></a>AJAX的方法</h2><pre><code>//设置请求方式ajax.open(&quot;post&quot;,&quot;url&quot;,true);  //第三个参数如果为true，则是异步，反之同步//设置请求头格式（post请求时一定要加请求头，这是因为在传输过程中会出现转码的情况，可能导致乱码的情况）xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);//发送请求:get请求参数放在url后面，post请求参数send()方法里面ajax.send(&quot;数据&quot;); //监听ajax状态，当ajax的状态发生改变的时候执行ajax.onreadystatechange = function(){    //响应完成，浏览器已经可以获取到服务器响应结果了    if(this.readyState == 4){  //这是AJAX的状态码 区别与http的状态码 状态码还有 1 2 3 其中3是数据正在传输时的状态，他不保证数据的完整性        //http响应的状态码        if(this.state == 200){  //还有302  301  404...            //获取响应内容            console.log(this.responseText); //用ajax.responseText获取服务器返回的数据                //responseText 获得字符串形式的响应数据。               //responseXML 获得XML 形式的响应数据        }    }}</code></pre><h2 id="数据渲染的两种方式"><a href="#数据渲染的两种方式" class="headerlink" title="数据渲染的两种方式"></a>数据渲染的两种方式</h2><h3 id="数据在服务器中渲染完毕，返回给客户端一个完整页面"><a href="#数据在服务器中渲染完毕，返回给客户端一个完整页面" class="headerlink" title="数据在服务器中渲染完毕，返回给客户端一个完整页面"></a>数据在服务器中渲染完毕，返回给客户端一个完整页面</h3><ol><li>浏览器发送请求至服务器</li><li>服务器接收到请求的信息，根据请求找到相应的信息（如JSON数据），在读取相应的页面文件，并渲染成一个完整的页面，将这个页面返回给客户端</li><li>客户端接收到此页面，并显示 (此方式要在服务器端安装art-template express-art-template等第三方模板）</li></ol><h3 id="服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"><a href="#服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示" class="headerlink" title="服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示"></a>服务器只返回相应的数据，客户端接收到数据后，在客户端进行渲染，并显示</h3><ol><li>客户端发送数据请求给服务器</li><li>服务器拿到请求，找到相应的数据（如JSON），直接将此数据返回给客户端</li><li>客户端拿到数据后，在客户端进行渲染，并显示。（此方式要用到前端渲染插件template-web.js）</li></ol><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML extensible Markup Language 扩展的标记语言，XML的标签可以自定义<br>HTML Hyper Text Markup Lanaguage HTML的标签是由W3C规范的，大概一共200多个</p><p><strong>XML用途：</strong><br>1、 定义数据结构<br>2、 作为配置文件出现</p><p><strong>XML组成：</strong><br>1、 XML文档声明<br>2、 XML标签<br>3、 XML属性<br>4、 XML注释</p><p><strong>XML文档注意点：</strong><br>1）xml的标签必须成对出现如，为成对出现时的标签也必须要是自关闭标签 如<br>2）xml标签名称区分大小写。<br>3）xml标签一定要正确配对。<br>4）xml标签名中间不能使用空格<br>5）xml标签名不能以数字开头<br>6）注意： 在一个xml文档中，有且仅有一个根标签</p><pre><code>//使用xml设计一个通讯录&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;contact&gt;    &lt;person id=&quot;100&quot;&gt;         &lt;name&gt;张三&lt;/name&gt;         &lt;age&gt;18&lt;/age&gt;         &lt;phone&gt;12345678&lt;/phone&gt;         &lt;email&gt;12453@qq.com&lt;/email&gt;    &lt;/person&gt;    &lt;person id=&quot;101&quot;&gt;         &lt;name&gt;李四&lt;/name&gt;         &lt;age&gt;20&lt;/age&gt;         &lt;phone&gt;22345678&lt;/phone&gt;         &lt;email&gt;34453@qq.com&lt;/email&gt;    &lt;/person&gt;&lt;/contact&gt;</code></pre><p><strong>xml的使用</strong></p><pre><code>//服务器代码//返回XML格式的数据app.get(&quot;/getXML&quot;,(req,res)=&gt;{    //设置响应头，指定返回的数据是XML    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);    var xml =  &#39;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&#39;;//XML文档声明    xml += &#39;&lt;person&gt;&#39;;    xml += &#39;&lt;name&gt;羊杨&lt;/name&gt;&#39;;    xml += &#39;&lt;age&gt;16&lt;/age&gt;&#39;;    xml += &#39;&lt;gender&gt;男&lt;/gender&gt;&#39;;    xml += &#39;&lt;/person&gt;&#39;;    res.send(xml);})//客户端代码ajax.onreadystatechange = function(){    if(this.readyState == 4){        //获取响应的XML数据        var xml = this.responseXML.documentElement;//ajax.responseXML.documentElement拿到文档数据        var age = xml.querySelector(&quot;age&quot;);//用标签选择器获取到age数据  但此时age是&lt;age&gt;16&lt;/age&gt;        console.log(age.innerHTML);//此处用innerText拿不到数据        console.log(xml.children);//xml的语法几乎与html语法类似    }}</code></pre><p>JSON</p><p>json数据的使用</p><pre><code>//服务器代码//返回JSON格式的数据app.get(&quot;/getJSON&quot;,(req,res)=&gt;{    //数组    let arr = [        {            name:&quot;zhangsan&quot;,            age:&quot;18&quot;,            gender:&quot;男&quot;,            id:001        },        {            name:&quot;lisi&quot;,            age:&quot;28&quot;,            gender:&quot;男&quot;,            id:002        }    ]    //将数组转换为JSON数据    res.status(200).send(JSON.stringify(arr));})//客户端代码ajax.onreadystatechange = function(){    if(this.readyState == 4){        console.log(this.responseText); //这是JSON字符串，在使用的时候往往需要转换为对象        var students = JSON.parse(this.responseText);        var html = template(&quot;generatorTable&quot;,{students:students});        container.innerHTML = html;    }}</code></pre><h2 id="jQuery中的AJAX"><a href="#jQuery中的AJAX" class="headerlink" title="jQuery中的AJAX"></a>jQuery中的AJAX</h2><p>推荐使用 方便的一批</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>客户端代码</p><pre><code>$.ajax({    //请求方式    type:&quot;get&quot;, //post    //请求路径    url:&quot;&quot;, //如http://localhost:3000/index    //请求参数，无论是get还是post请求，请求参数都可以写在这里    //注意：请求为get时  在服务器得到请求参数时 仍然使用res.query    //这里的data数据必须为字符串 若要传入json数据 需要将json数据转换为字符串如 JSON.stringify({[{},{}]})    data:{name:&quot;zhangsan&quot;},    //规定所要请求的数据的类型    dataType: &#39;&#39;,    //在jQuery中如果请求已经是post，默认的contentType就是application/x-www-form-urlencoded,不需要单独再去写    //contentType: &quot;application/x-www-form-urlencoded&quot;,    //请求成功的回调    success:function(res){        console.log(res);//res是请求的到的数据    }    //请求出错的回调 推荐写    error:function(err){        console.log(err);    }    //无论请求的成功与否，只要请求结束都会执行此函数    complete:function(xhr){    }})</code></pre><p>服务器代码</p><pre><code>let express = require(&quot;express&quot;);let app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));//注意 当客户端中的data:JSON.stringify([{name:&#39;zhangsan&#39;},{name:&#39;lisi&#39;}])时，服务器需要此配置//以解析body中的json数据app.use(bodyParser.json({extended:false}));app.use(express.static(&quot;./views&quot;));//当ajax的url为&#39;/getJSON&#39;时 此接口响应 返回JSON格式的数据//此时ajax的dataType要设置为&#39;json&#39;app.get(&quot;/getJSON&quot;,(req,res)=&gt;{    //数组    let arr = [        {            name:&quot;zhangsan&quot;,            age:&quot;18&quot;,            gender:&quot;男&quot;,            id:001        },        {            name:&quot;lisi&quot;,            age:&quot;28&quot;,            gender:&quot;男&quot;,            id:002        }    ]    arr.forEach((user,idx)={        if(user.name == req.body.name){            res.status(200).send(JSON.stringify(user));        }    })})//当ajax的url为&#39;/getXML&#39;时 此接口响应 返回XML格式的数据//此时ajax的dataType要设置为&#39;xml&#39;app.get(&quot;/getXML&quot;,(req,res)=&gt;{    //设置响应头，指定返回的数据是XML    res.header(&quot;content-type&quot;,&quot;application/xml&quot;);    var xml =  &#39;&lt;?xml version=&quot;1.1&quot; encoding=&quot;utf-8&quot;?&gt;&#39;;    xml += &#39;&lt;person&gt;&#39;;    xml += &#39;&lt;name&gt;zhangsan&lt;/name&gt;&#39;;    xml += &#39;&lt;age&gt;16&lt;/age&gt;&#39;;    xml += &#39;&lt;gender&gt;男&lt;/gender&gt;&#39;;    xml += &#39;&lt;/person&gt;&#39;;    res.send(xml);})</code></pre><p>发送也接受html或script数据</p><p>服务器代码</p><pre><code>const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.use(express.static(&#39;views&#39;));app.get(&#39;/getScript&#39;,(req,res)=&gt;{    res.header(&#39;content-type&#39;,&#39;application/javascript;charset=utf-8&#39;);    res.send(&#39;alert(123);&#39;);});app.get(&#39;/getHtml&#39;,(req,res)=&gt;{    res.header(&#39;content-type&#39;,&#39;text/html;charset=utf-8&#39;)    res.send(&#39;&lt;h1&gt;HTML&lt;/h1&gt;&#39;);});app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><p>客户端代码</p><pre><code>$(&#39;#btn1&#39;).click(function(){    $.ajax({        type: &#39;get&#39;,        url: &#39;/getHtml&#39;,        data: &#39;&#39;,        dataType: &#39;html&#39;,        success:function(res){            //因为dataType为html  jQuery。AJAX会自动设置响应头为text/html  则 可以直接追加res到页面中            $(&#39;#info&#39;).append(res);        },        error:function(err){            console.log(err);        }    });});$(&#39;#btn2&#39;).click(function(){    $.ajax({        type: &#39;get&#39;,        url: &#39;/getScript&#39;,        data: &#39;&#39;,        dataType: &#39;script&#39;,        success:function(res){            //之所以alert()能执行  是因为将script代码打印到控制台  控制台会执行script代码            //也可以用script标签的对res进行封装 追加到页面中 也可以执行            console.log(res);        },        error:function(err){            console.log(err);        }    });});</code></pre><h3 id="dataType"><a href="#dataType" class="headerlink" title="dataType"></a>dataType</h3><p><strong>dataType取值有xml、html、json、jsonp、script或者text</strong></p><p>当dataType取值为<strong>json</strong>，会自动将服务器返回的文本数据通过JSON.parse()转换成对象。<br>服务器应该设置这个响应头：<strong>res.header(“content-type”, “application/json;charset=utf-8”);</strong></p><p>当dataType为<strong>xml或者text</strong>的时候，返回的数据不会另做处理<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/xml”);</strong><br><strong>res.header(“content-type”,”text/plain;charset=utf-8”);</strong></p><p>当dataType为<strong>html</strong>的时候，返回的内容中的script标签会在网页内容被拼接到页面的时候执行<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”text/html;charset=utf-8”);</strong></p><p>当dataType为<strong>script</strong>的时候，会将服务器返回的结果当成js代码执行并且将js代码的文本内容返回给客户端<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><p>当dataType为<strong>jsonp</strong>的时候，会向服务器发送一个jsonp请求<br>服务器应该设置这个响应头：<strong>res.header(“content-type”,”application/javascript”);</strong></p><h2 id="nprogress的使用（全局事件处理）"><a href="#nprogress的使用（全局事件处理）" class="headerlink" title="nprogress的使用（全局事件处理）"></a>nprogress的使用（全局事件处理）</h2><p>1、在html文件中引入nprogress.js 和 nprogress.css</p><p>2</p><pre><code>$(document).ajaxStart(function(){//请求数据开始    NProgress.start();//数据加载动画}).ajaxStop(function(){//请求数据结束    NProgress.done();//数据加载完毕动画});</code></pre><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p><strong>同源策略</strong>是浏览器的一种安全策略，所谓同源是指 <strong>域名，协议，端口完全相同</strong> ，只有同源的地址才可以相互通过AJAX的方式请求。</p><p>同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为<strong>跨域请求</strong></p><p>例如</p><pre><code>http://localhost:8000  是不可以通过ajax访问  http://locally.uieee.com/categories的因为两者不满足同源的条件</code></pre><h3 id="如何进行跨域请求"><a href="#如何进行跨域请求" class="headerlink" title="如何进行跨域请求"></a>如何进行跨域请求</h3><ol><li>CORS</li><li>JSONP</li><li>代理服务器</li><li>修改document.domain</li><li>Iframe</li><li>Location.hash</li><li>Window.postMessage()</li><li>Websocket</li></ol><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>只需要改动服务器，不用改动客户端代码，客户端可以直接使用$.ajax()</p><p>Cross Origin Resource Share，跨域资源共享。这种方案无需客户端作出任何变化（客户端不用改代码），只是在被请求的服务端响应的时候添加一个Access- Control-Allow-Origin 的响应头，表示这个资源是否允许指定域请求。</p><pre><code>//直接在服务器配置如下,客户端代码和以前一样写app.all(&#39;*&#39;, function(req, res, next) {    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-type&#39;);    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS,PATCH&quot;);    res.header(&#39;Access-Control-Max-Age&#39;,6000);//预请求缓存10分钟    next();  });</code></pre><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON with Padding 实质上是通过script的src属性进行数据请求。本质上不是AJAX请求</p><p>需要服务器和客户端配合</p><pre><code>//此时客户端的地址为http://localhost:3000实现要点//客户端代码var script = document.createElement(&#39;script&#39;);script.src = &#39;http://localhost:9999/testJSONP&#39;;//向http://localhost:9999发送跨域请求document.body.appendChild(script)//服务器代码app.get(&quot;/testJSONP&quot;,(req,res)=&gt;{    //设置响应头 服务器给客户端发送了一个js代码块    res.header(&quot;content-type&quot;,&quot;application/javascript&quot;);    let data = JSON.stringify({&quot;name&quot;:&quot;zhangsan&quot;}) ;    //服务器发送 `foo(&#39;{&quot;name&quot;:&quot;zhangsan&quot;}&#39;)` 这个字符串给客户端    res.send(`foo(${data})`);})//如果服务器给客户端返回的js代码块中有函数调用，必须提前在客户端中声明要调用的那个函数function foo(data){    console.log(data);}</code></pre><p><strong>jQuery代码</strong></p><pre><code>//客户端代码$.ajax({    type:&quot;get&quot;,    url:&quot;http://localhost:9999/testJSONP&quot;,    data:&#39;&#39;,    dataType: &#39;jsonp&#39;,    success:function(res){        $(&#39;body&#39;).append(res);    }    error:function(err){        console.log(err);    }    complete:function(xhr){    }});function foo(data){    console.log(data);}//服务器http://localhost:3000代码const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.use(express.static(&#39;views&#39;));app.listen(3000,()=&gt;{    console.log(&#39;running...&#39;);});//服务器http://localhost:8888代码const express = require(&#39;express&#39;);const app = express();const bodyParser = require(&#39;body-parser&#39;);app.use(bodyParser.urlencoded({extended:false}));app.get(&#39;/getJsonp&#39;,(req,res)=&gt;{    res.send(&#39;foo(&quot;你拿到了http://localhost:8888的jsonp&quot;);&#39;);});app.listen(8888,()=&gt;{    console.log(&#39;running...&#39;);});</code></pre><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>AJAX是通过<code>XMLHttpRequest</code>或者封装后的框架进行网络请求，由于这种方式的配置和调用方式非常混乱，已被Fetch取代</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
