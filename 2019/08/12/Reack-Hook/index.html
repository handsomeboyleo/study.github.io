<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/study.github.io/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/study.github.io/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Reack Hook ~ Hexo</title>

  <link rel="stylesheet" href="/study.github.io/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/study.github.io/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/study.github.io/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/study.github.io/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/study.github.io/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/study.github.io/css/main.css"  >


  <link rel="stylesheet" href="/study.github.io/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/study.github.io/">&nbsp;<strong>Handsomeboyleo</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/study.github.io/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/study.github.io/archives/">归档</a>
          </li>
        
          
          
          
          
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/study.github.io/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/study.github.io/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 八月 12日 2019, 12:21 凌晨
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    5.1k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      已阅读 23 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="Reack-Hook"><a href="#Reack-Hook" class="headerlink" title="Reack Hook"></a>Reack Hook</h1><h2 id="Hook简介"><a href="#Hook简介" class="headerlink" title="Hook简介"></a>Hook简介</h2><blockquote>
<p>React 16.7.0开始推行Hook，到 React 16.8.0 Hook 稳定，Hooks开始被推广使用，它解决了传统使用生命周期而导致的相关代码逻辑分离、不相关代码逻辑混合在一个生命周期中、class中复杂的this指向、class不能被很好的压缩、class可能导致热重载不稳定</p>
</blockquote>
<blockquote>
<p>Hook为开发者提供了可以使用function创建微state，且一个state由一个对应的函数管理，还提供了专门处理副作用、实现redux、性能优化等功能，并且100%向后兼容，个人认为Hook是react未来发展的趋势，但并不意味着摒弃class。</p>
</blockquote>
<h2 id="Hook-API"><a href="#Hook-API" class="headerlink" title="Hook API"></a>Hook API</h2><h3 id="1、useState"><a href="#1、useState" class="headerlink" title="1、useState"></a>1、useState</h3><blockquote>
<p>useState返回一个数组，第一个值为state，第二个值为状态管理函数</p>
<p>值得注意的是：为了使得状态的操作函数 与其他函数区别开且和其对应的状态联系起来，在命名上有如下约定规则： set + 状态名</p>
<p>如有状态count，则对应状态管理函数命名为 setCount</p>
</blockquote>
<p>函数签名</p>
<pre><code>const [状态名, 状态管理函数] = useState(状态初始值);</code></pre><p>使用实例</p>
<pre><code>import React, { useState } from &#39;react&#39;;

function Example() {
  // 解构赋值获取useState返回的值，并给他们取名为count和setCount
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre><p>状态管理函的实参必须有返回值，且此返回值会赋值给对应状态。</p>
<p>除上述使用形式外，还可以如下使用</p>
<pre><code>setCount(()=&gt;{
    return count+1;
})</code></pre><p>对应使用场景</p>
<pre><code>// 在原有state的基础上改变数据
const [person,setPerson] = useState({
    name: &#39;王老板&#39;,
    age: 18
})

setState( state =&gt; ({
    ...person,
    age: ++state.age
}) )</code></pre><p><strong>踩坑记录</strong></p>
<ul>
<li><code>useState</code>中的数据务必是<code>immutable</code>数据，若两次传入同一对象则不会触发组件更新，如：</li>
</ul>
<pre><code>import React, { useState } from &#39;react&#39;
export default props =&gt; {
    const [list, setList] = useState([1, 5, 3, 9])
    return &lt;&gt;
        &lt;ul&gt;
            {list.map((item, idx) =&gt; &lt;li key={String(idx)}&gt;{item}&lt;/li&gt;)}
        &lt;/ul&gt;
        {/* sort 不生成副本，直接返回原数组 */}
        &lt;button onClick={()=&gt; {setList(list.sort((a, b) =&gt; a - b))}}&gt;sort&lt;/button&gt;
        {/* slice 返回一个新的副本数组 */}
        &lt;button onClick={()=&gt; {setList(list.slice().sort((a, b) =&gt; a - b))}}&gt;slice&lt;/button&gt;
    &lt;/&gt;
}</code></pre><p>点击sort按钮后并不会出发更新！</p>
<ul>
<li><p><code>useState</code>对应的state只要发生改变，无论组件是否使用了<code>state</code>，该组件都会发生更新；</p>
<p><code>useRef</code>所保存的值，只有在组件中被使用且发生改变时，组件才会更新；</p>
<p>可以参照两者的区别，根据不同场景来判断使用哪种方式保存数据。</p>
</li>
<li><p>useState 是将新值直接覆盖掉旧值，而不是合并</p>
<pre><code>const [temp,setTemp] = useState({a: 1, b: 2});
setTemp({a: 2}); // temp = {a: 2}</code></pre></li>
</ul>
<h3 id="2、useEffect"><a href="#2、useEffect" class="headerlink" title="2、useEffect"></a>2、useEffect</h3><blockquote>
<p>使用<code>useEffect</code>来处理副作用</p>
</blockquote>
<p>函数签名</p>
<pre><code>//1  组件初次渲染后执行一次，依赖项每次改变时执行一次
useEffect(()=&gt;{
    //副作用动作
},[依赖项])

//2  组件初次渲染后执行一次
useEffect(()=&gt;{
    //副作用动作
},[])

//3  组件初次渲染后执行一次，组件每次更新后执行一次
useEffect(()=&gt;{
    //副作用动作
})</code></pre><p>例子：</p>
<pre><code>import React, { useState, useEffect, useRef } from &#39;react&#39;

export default function Example() {
    const [count, setCount] = useState(0);
    const [val, setVal] = useState(0);
    const num = useRef(0);
    useEffect(()=&gt;{
        console.log(&#39;1&#39;)
    },[count]);

    useEffect(()=&gt;{
        console.log(&#39;2&#39;)
    },[]);

    useEffect(()=&gt;{
        console.log(&#39;3&#39;)
    });

    return &lt;div&gt;
        &lt;button onClick={()=&gt;{setCount(count + 1)}}&gt;COUNT&lt;/button&gt;
        &lt;button onClick={()=&gt;{setVal(val + 1)}}&gt;VAL&lt;/button&gt;
        &lt;button onClick={()=&gt;{num.current += 1}}&gt;NUM&lt;/button&gt;
    &lt;/div&gt;
}
//该组件初次渲染后的执行结果
1
2
3

//点击一次 COUNT按钮 后的执行结果
1
3

//点击一次 VAL按钮 后的执行结果
3

//点击一次 NUM按钮 后的执行结果</code></pre><h4 id="（1）处理无需清除的effect"><a href="#（1）处理无需清除的effect" class="headerlink" title="（1）处理无需清除的effect"></a>（1）处理无需清除的effect</h4><blockquote>
<p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p>
</blockquote>
<p>使用实例</p>
<p> 需求：监听url的变化来发送网络请求，保存返回结果</p>
<pre><code>import React, { useState, useEffect } from &#39;react&#39;
import ajax from &#39;@utils/ajax&#39;
export default function Example({ location }) {

    const [data, setData] = useState({});

    useEffect(()=&gt;{
        getData();
    },[location]);

    const getData = () =&gt; {
        ajax.post().then(res =&gt; {
            setData(res);
        })
    }
    return &lt;div&gt;{data}&lt;/div&gt;
}</code></pre><p>当location发生变化时，useEffect中函数就会自动执行</p>
<h4 id="（2）处理需要清除的effect"><a href="#（2）处理需要清除的effect" class="headerlink" title="（2）处理需要清除的effect"></a>（2）处理需要清除的effect</h4><blockquote>
<p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如<strong>订阅外部数据源</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p>
</blockquote>
<p>在useEffect中可选的返回一个清除函数，该清除函数会在组件卸载时自动执行，以达到清除effect的目的</p>
<p>函数签名</p>
<pre><code>//useEffect的第二个参数不影响 ‘清除effect’ 动作
useEffect(()=&gt;{
    //副作用动作
    return () =&gt; {
        //清除effect
    }
})</code></pre><p>使用示例</p>
<pre><code>useEffect(() =&gt; {
    function handleStatusChange(status) {
        setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
});</code></pre><p><strong>踩坑记录</strong></p>
<ul>
<li>在<code>useEffect</code>和<code>useLayoutEffect</code>中使用<code>async</code>和<code>await</code>语法时，要注意分离<code>async</code>默认返回的<code>promise</code>与<code>useEffect</code>和<code>useLayoutEffect</code>的<code>cleanup</code>函数，不要将<code>async</code>的返回函数返给<code>useEffect</code>。使用<code>IIFE</code>解决</li>
</ul>
<pre><code>useEffect(() =&gt; {
    (async () =&gt; {
        await fetchSomething();
    })();
}, []);</code></pre><h3 id="3、useMemo与useCallback"><a href="#3、useMemo与useCallback" class="headerlink" title="3、useMemo与useCallback"></a>3、useMemo与useCallback</h3><blockquote>
<ol>
<li>当组件state被修改时就会触发组件的重新渲染，无论前后state是否一致</li>
<li>父组件更新，子组件会自动更新</li>
<li>组件更新时，会卸载所有function，并重新创建function</li>
</ol>
</blockquote>
<p>这就出现了性能问题，当更新前后状态一致时，是无需更新的。</p>
<p>在之前使用生命周期时，我们通常的解决方案是调用生命周期钩子函数<code>shouldComponentUpdate</code>来判断新老props、states是否发生变化来决定当前组件是否需要更新（原理可参见 React 的 Diff）</p>
<p>Hooks出现后，我们可以直接使用function的形式来创建组件状态，但function自身并没有<code>shouldComponentUpdate</code>判断前后状态的能力。并且，每当函数组件被调用都会执行内部的所有的逻辑，其性能损耗显而易见。</p>
<p><strong>useMemo 与 useCallback 的区别与联系</strong></p>
<p>实际上<code>useCallback</code>是基于<code>useMemo</code>实现的</p>
<pre><code>function useCallback(callback, args) {
    return useMemo(() =&gt; callback, args);
}</code></pre><ol>
<li><code>useMemo</code>是返回<code>callback</code>执行后的结果</li>
<li><code>useCallback</code> 是直接返回被<code>useMemo</code>修饰的<code>callback</code>函数</li>
</ol>
<h4 id="（1）useMemo"><a href="#（1）useMemo" class="headerlink" title="（1）useMemo"></a>（1）useMemo</h4><pre><code>import React from &#39;react&#39;;
export default function WithoutMemo() {
    const [count, setCount] = useState(1);
    const [val, setValue] = useState(&#39;&#39;);

    function expensive() {
        console.log(&#39;compute&#39;);
        let sum = 0;
        for (let i = 0; i &lt; count * 100; i++) {
            sum += i;
        }
        return sum;
    }
    return &lt;div&gt;
        &lt;h4&gt;{count}-{val}-{expensive()}&lt;/h4&gt;
        &lt;div&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+c1&lt;/button&gt;
            &lt;input value={val} onChange={event =&gt; setValue(event.target.value)}/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;
}</code></pre><p>在这个组件中含有一个计算量很大的函数<code>expensive</code>，当我们修改 <code>conut</code> <code>val</code>任意一个状态时，<code>expensive</code>都会被触发，尽管<code>val</code>与<code>expensive</code>的计算毫无关系。</p>
<p>使用<code>useMemo</code>来解决该问题</p>
<pre><code>import React from &#39;react&#39;;
export default function WithoutMemo() {
    const [count, setCount] = useState(1);
    const [val, setValue] = useState(&#39;&#39;);

    //使用useMemo
    const expensive = useMemo(() {
        console.log(&#39;compute&#39;);
        let sum = 0;
        for (let i = 0; i &lt; count * 100; i++) {
            sum += i;
        }
        return sum;
    },[count])

    return &lt;div&gt;
        &lt;h4&gt;{count}-{val}-{expensive}&lt;/h4&gt;
        &lt;div&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+c1&lt;/button&gt;
            &lt;input value={val} onChange={event =&gt; setValue(event.target.value)}/&gt;
        &lt;/div&gt;
    &lt;/div&gt;;
}</code></pre><p>我们可知，<code>expensive</code>的计算只与count相关，则可使用<code>useMome</code>添加依赖值<code>count</code></p>
<p>当且仅当count发生有效改变时才会执行相应函数，并返回缓存值给<code>expensive</code></p>
<h4 id="（2）useCallback"><a href="#（2）useCallback" class="headerlink" title="（2）useCallback"></a>（2）useCallback</h4><p><code>useCallback</code>的特点、作用和用法与<code>useMemo</code>类似，但是他返回一个缓存的函数。</p>
<p>除了利用<code>useMemo</code>和<code>useCallback</code>的缓存特性以达到 ”减少某函数不必要的计算“ 外，还可以利用这特性实现 “避免子组件不必要的更新”，这里以<code>useCallback</code>为例</p>
<pre><code>import React, { useState, useCallback, useEffect } from &#39;react&#39;;
function Parent() {
    const [count, setCount] = useState(1);
    const [val, setVal] = useState(&#39;&#39;);

    const callback = useCallback(() =&gt; {
        return count;
    }, [count]);
    return &lt;div&gt;
        &lt;h4&gt;{count}- {val}&lt;/h4&gt;
        &lt;Child callback={callback}/&gt;
    &lt;/div&gt;;
}

function Child({ callback }) {
    const [count, setCount] = useState(() =&gt; callback());
    useEffect(() =&gt; {
        setCount(callback());
    }, [callback]);
    return &lt;div&gt;
        {count}
    &lt;/div&gt;
}</code></pre><p>例子中的Child组件中 是依赖于父组件传递来的callback来创建的函数，一旦父组件中的callback发生改变则Child组件就会发生更新，若父组件中的callback不使用useCallback来封装，则父组件中的任意变量发生改变都会导致callback的变化进而导致子组件不必要的更新。</p>
<p>此外，所有依赖state或props来创建的函数，需要用到缓存函数的地方都是useCallback的使用场景。</p>
<p><strong>踩坑记录</strong></p>
<p>使用<code>lodash</code>中的<code>debounced</code></p>
<pre><code>import React, { useState } from &#39;react&#39;
import { debounce } from &#39;lodash&#39;

const Example = () =&gt; {
    const [value, setValue] = useState(&#39;&#39;);

    const _debounce = debounce((value)=&gt;{
        console.log(value)
    },3000);

    const _onChange = (e) =&gt; {
        let value = e.target.value;
        setValue(value)
        _debounce(value);
    }
    return &lt;div&gt;
        &lt;input type=&quot;text&quot; onChange={_onChange} value={value} /&gt;
    &lt;/div&gt;
}

export default Example</code></pre><p>每当<code>onChange</code>被触发一次，都会执行<code>setValue</code>，进而导致刷新组件，使得每次都生成新的<code>debounce</code>，这就失去了函数防抖的效果。而此处的矛盾点就是“函数刷新导致生成了新的<code>debounce</code>”，这里就可以使用<code>useCallback</code>来解决。</p>
<pre><code>import React, { useState, useCallback } from &#39;react&#39;
import { debounce } from &#39;lodash&#39;

const Example = () =&gt; {
    const [value, setValue] = useState(&#39;&#39;);

    const _debounce = useCallback(debounce((value)=&gt;{
        console.log(value);
    },3000),[]);

    const _onChange = (e) =&gt; {
        let value = e.target.value;
        setValue(value);
        _debounce(value);
    }
    return &lt;div&gt;
        &lt;input type=&quot;text&quot; onChange={_onChange} value={value} /&gt;
    &lt;/div&gt;
}

export default Example</code></pre><p>这样每次组件刷新后执行的debounce都是同一个函数，进而使得debounce的防抖效果生效。</p>
<h3 id="4、useContext与useReducer"><a href="#4、useContext与useReducer" class="headerlink" title="4、useContext与useReducer"></a>4、useContext与useReducer</h3><h4 id="（1）useContext"><a href="#（1）useContext" class="headerlink" title="（1）useContext"></a>（1）useContext</h4><blockquote>
<p>实现同一子树下所有节点可统一共享子树根节点的数据</p>
</blockquote>
<p>函数签名</p>
<pre><code>const value = useContext(MyContext);</code></pre><blockquote>
<p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 `` 的 <code>value</code> prop 决定。</p>
<p>当组件上层最近的 `` 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。</p>
<p>别忘记 <code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p>
<ul>
<li><strong>正确：</strong> <code>useContext(MyContext)</code></li>
<li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li>
<li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li>
</ul>
<p>调用了 <code>useContext</code> 的组件总会在 context 值变化时重新渲染。</p>
</blockquote>
<p>使用实例：</p>
<pre><code>import React, { useContext } from &#39;react&#39;
//创建Context对象，并附默认值 {count: 1}
const MyContext = React.createContext({ count: 1 })
const [count, setState] = useState(1)

export default function Example() {

    const Son = () =&gt; {
        return &lt;div&gt;
            &lt;Grandson&gt;&lt;/Grandson&gt;
        &lt;/div&gt;
    }

    const Grandson = () =&gt; {
        //使用useContext获取Context对象
        const obj = useContext(MyContext);
        return &lt;div&gt;
            Grandson---{obj.count}
        &lt;/div&gt;
    }
    return &lt;MyContext.Provider value={{ count: count }}&gt;
        &lt;button onClick={() =&gt; { setState(count + 1) }}&gt;ADD&lt;/button&gt;
        &lt;Son&gt;&lt;/Son&gt;
    &lt;/MyContext.Provider&gt;
}</code></pre><p>当点击按钮改变count时，所有消费者组件都会随之发生更新，这也就达到了跨层级组件直接共享数据的目的。</p>
<h4 id="（2）useReducer"><a href="#（2）useReducer" class="headerlink" title="（2）useReducer"></a>（2）useReducer</h4><p>函数签名</p>
<pre><code>// reducer就是平时redux那种reducer函数
// initialState 初始化的state状态
// init 一个函数用于惰性计算state初始值
const [state, dispatch] = useReducer(reducer, initialArg, init);</code></pre><blockquote>
<p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。（统一管理数据，并对<code>action</code>加以限制）</p>
<p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数 。</p>
</blockquote>
<p><code>initialArg</code>作为<code>state</code>的初始值，若存在<code>init</code>,则<code>init</code>会将<code>initalArg</code>处理后的值作为<code>state</code>的初始值</p>
<pre><code>reducer`对应于`dispatch`,使用dispatch所传入的实参对应于`reducer`的`action</code></pre><p>使用实例</p>
<pre><code>import React, { useReducer } from &#39;react&#39;


const initialState = 0;

const init = (initialCount) =&gt; {
    return { count: initialCount }
}
function reducer(state, action) {
    switch (action.type) {
        case &#39;increment&#39;:
            return { count: state.count + 1 };
        case &#39;decrement&#39;:
            return { count: state.count - 1 };
        case &#39;RESET&#39;:
            return init(action.payload)
        default:
            throw new Error();
    }
}

export default props =&gt; {
    const [state, dispatch] = useReducer(reducer, initialState, init);
    return &lt;div&gt;
        Count: {state.count}
        &lt;br /&gt;
        &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;SUB&lt;/button&gt;
        &lt;br /&gt;
        &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;ADD&lt;/button&gt;
        &lt;br /&gt;
        &lt;button onClick={() =&gt; dispatch({ type: &#39;RESET&#39;, payload: initialState })}&gt;RESET&lt;/button&gt;
    &lt;/div&gt;
}</code></pre><h4 id="（3）useContext与useReducer结合使用"><a href="#（3）useContext与useReducer结合使用" class="headerlink" title="（3）useContext与useReducer结合使用"></a>（3）useContext与useReducer结合使用</h4><blockquote>
<p>结合使用useContext和useReducer以实现共享数据的统一管理和共享数据安全性保证</p>
</blockquote>
<p>使用实例</p>
<pre><code>import React, { useContext, useReducer } from &#39;react&#39;

export default props =&gt; {
    const MyContext = React.createContext({ count: 1 });

    const init = (initalCount) =&gt; {
        return { count: initalCount }
    }
    function reducer(state, action) {
        switch (action.type) {
            case &#39;increment&#39;:
                return { count: state.count + 1 };
            case &#39;decrement&#39;:
                return { count: state.count - 1 };
            case &#39;RESET&#39;:
                return init(action.payload)
            default:
                throw new Error();
        }
    }

    const initialCount = 0;
    const [state, dispatch] = useReducer(reducer, initialCount, init);

    const Son1 = () =&gt; {
        return &lt;Grandson1&gt;&lt;/Grandson1&gt;
    }

    const Son2 = () =&gt; {
        const obj = useContext(MyContext);
        return &lt;div&gt;
            Son2---{obj.count}
        &lt;/div&gt;
    }

    const Grandson1 = () =&gt; {
        const obj = useContext(MyContext);
        return &lt;div&gt;
            Grandson1---{obj.count}
        &lt;/div&gt;
    }
    return &lt;MyContext.Provider value={{ count: state.count }}&gt;
        &lt;button onClick={() =&gt; dispatch({ type: &#39;decrement&#39; })}&gt;SUB&lt;/button&gt;
        &lt;br /&gt;
        &lt;button onClick={() =&gt; dispatch({ type: &#39;increment&#39; })}&gt;ADD&lt;/button&gt;
        &lt;br /&gt;
        &lt;button onClick={() =&gt; dispatch({ type: &#39;RESET&#39;, payload: initialCount })}&gt;RESET&lt;/button&gt;
        &lt;Son1&gt;&lt;/Son1&gt;
        &lt;Son2&gt;&lt;/Son2&gt;
    &lt;/MyContext.Provider&gt;
}</code></pre><p>我们现在已经完成了useContext与useReducer的配合使用，我们现在将代码抽离出来，使其可以在任何组件中都可以快速调用</p>
<p>目录结构</p>
<pre><code>-example
    -components
        -Son
            -index.js
        -Grandson
            -index.js
    -store
        -index.js
        -reducer.js
    -index.js</code></pre><p>使用实例</p>
<pre><code>// example\store\index.js
import React, { useReducer, useContext } from &#39;react&#39;
import { defaultState, reducer, init } from &#39;./reducer&#39;

const MyContext = React.createContext();

const Context = props =&gt; {

    //将useReducer的返回值 [state,dispatch] 作为参数
    const contextValue = useReducer(reducer, defaultState, init);

    return &lt;MyContext.Provider value={contextValue}&gt;
        {props.children}
    &lt;/MyContext.Provider&gt;
}

const useMyContext = () =&gt; {
    return useContext(MyContext)
}

export {
    Context,
    useMyContext
}
// example\store\reducer.js
export const defaultState = {
    count: 0
}

export const init = (initalState) =&gt; {
    return { 
        ...initalState,
        count: initalState.count 
    }
}

export const reducer = (state, action) =&gt; {
    switch (action.type) {
        case &#39;increment&#39;:
            return {
                ...state,
                count: state.count + 1
            };
        case &#39;decrement&#39;:
            return {
                ...state,
                count: state.count - 1
            };
        case &#39;RESET&#39;:
            return init(defaultState)
        default:
            throw new Error();
    }
}
// example\components\Grandson\index.js
import React from &#39;react&#39;
import { useMyContext } from &#39;../../store&#39;
export default props =&gt; {
    const [state, dispatch] = useMyContext();
    return &lt;div&gt;
        Grandson --- {state.count}
        &lt;button onClick={() =&gt; { dispatch({ type: &#39;increment&#39; }) }}&gt;Grandson ADD&lt;/button&gt;
        &lt;button onClick={() =&gt; { dispatch({ type: &#39;decrement&#39; }) }}&gt;Grandson SUB&lt;/button&gt;
        &lt;button onClick={() =&gt; { dispatch({ type: &#39;RESET&#39; }) }}&gt;Grandson RESET&lt;/button&gt;
    &lt;/div&gt;
}
// example\components\Son\index.js
import React from &#39;react&#39;
import Grandson from &#39;../Grandson&#39;

export default props =&gt; {
    return &lt;Grandson&gt;&lt;/Grandson&gt;
}
//example\index.js
import React from &#39;react&#39;
import Son from &#39;./components/Son&#39;
import { Context } from &#39;./store&#39;
export default props =&gt; {
    return &lt;Context&gt;
        &lt;Son&gt;&lt;/Son&gt;
    &lt;/Context&gt;
}</code></pre><h3 id="5、useRef"><a href="#5、useRef" class="headerlink" title="5、useRef"></a>5、useRef</h3><p>函数签名</p>
<pre><code>const refContainer = useRef(initialValue);</code></pre><blockquote>
<p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p>
</blockquote>
<p>使用实例</p>
<pre><code>import React from &#39;react&#39;

export default props =&gt; {
    const refContainer = useRef(null);
    return &lt;div ref={refContainer}&gt;&lt;/div&gt;
}</code></pre><p>除此之外，我们可以使子组件接受父组件的ref，让父组件有控制组件的能力，这里要借助<code>forwardRef</code></p>
<p>使用实例</p>
<pre><code>// father
import React, { useRef } from &#39;react&#39;
import Son from &#39;./components/Son&#39;
export default props =&gt; {
    const refContainer = useRef(null);
    const changeInput = () =&gt; {
        refContainer.current.value = &#39;啊，我被改了！&#39;
    }

    return &lt;div &gt;
        &lt;button onClick={changeInput}&gt;changeInput&lt;/button&gt;
        &lt;Son ref={refContainer}&gt;&lt;/Son&gt;
    &lt;/div&gt;
}
// Son
import React, { forwardRef } from &#39;react&#39;
const Son = (props,ref) =&gt; {
    return &lt;div &gt;
        &lt;input ref={ref}&gt;&lt;/input&gt;
    &lt;/div&gt;
}
export default forwardRef(Son)</code></pre><p><strong>useRef 声明常量以保存可变值</strong></p>
<blockquote>
<p>除了使用useRef绑定DOM，它另一个重要作用就是声明一个常量保存可变值，绕开React的Capture Value特性</p>
<p>保存常量这一功能实际上是基于useMemo实现的</p>
<pre><code>&gt; function useRef (initialValue) {
&gt;    return useMemo (() =&gt; ({ current : initialValue }), []);
&gt; }
&gt;</code></pre></blockquote>
<blockquote>
<p>可见 就是初始化的时候创建一个<code>{current:initialValue}</code>，不依赖任何数据，需要手动赋值修改</p>
</blockquote>
<p>使用实例</p>
<pre><code>import React, { useRef } from &#39;react&#39;
export default props =&gt; {
    const count = useRef(0);
    const add = () =&gt; {
        count.current += 1;
    }

    return &lt;div &gt;
        &lt;h1&gt;{count.current}&lt;/h1&gt;
        &lt;button onClick={add}&gt;ADD&lt;/button&gt;
    &lt;/div&gt;
}</code></pre><p><strong>踩坑记录</strong></p>
<ul>
<li>注意与useState的区别与联系</li>
</ul>
<h3 id="6、useImperativeHandle"><a href="#6、useImperativeHandle" class="headerlink" title="6、useImperativeHandle"></a>6、useImperativeHandle</h3><blockquote>
<p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <code>forwardRef</code> 一起使用</p>
</blockquote>
<p>使用实例</p>
<pre><code>//father
import React, { useRef } from &#39;react&#39;
import Son from &#39;./components/Son&#39;
export default props =&gt; {
    const refContainer = useRef(null);
    const changeInput = () =&gt; {
        refContainer.current.focus()
        // console.log(refContainer)
    }

    return &lt;div &gt;
        &lt;button onClick={changeInput}&gt;changeInput&lt;/button&gt;
        &lt;Son ref={refContainer}&gt;&lt;/Son&gt;
    &lt;/div&gt;
}
// Son
import React, { useRef, forwardRef, useImperativeHandle } from &#39;react&#39;

function Son(props, ref) {
    //新建一个ref  将此ref绑定在本组建内的input上
    const inputRef = useRef();
    //将 使得本组件input获取焦点的方法赋给父组件传递来的ref上 
    useImperativeHandle(ref, () =&gt; ({
        focus: () =&gt; {
            inputRef.current.focus();
        }
    }));
    return &lt;input ref={inputRef} /&gt;;
}

export default forwardRef(Son);</code></pre><h3 id="7、useLayoutEffect"><a href="#7、useLayoutEffect" class="headerlink" title="7、useLayoutEffect"></a>7、useLayoutEffect</h3><pre><code>useLayoutEffect( () =&gt; { }, [ 依赖项 ] );</code></pre><blockquote>
<p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p>
<p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p>
</blockquote>
<h3 id="8、useDebugValue"><a href="#8、useDebugValue" class="headerlink" title="8、useDebugValue"></a>8、useDebugValue</h3><pre><code>useDebugValue(value)</code></pre><blockquote>
<p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>
<pre><code>&gt; function useFriendStatus(friendID) {
&gt;   const [isOnline, setIsOnline] = useState(null);
&gt; 
&gt;   // ...
&gt; 
&gt;   // 在开发者工具中的这个 Hook 旁边显示标签
&gt;   // e.g. &quot;FriendStatus: Online&quot;
&gt;   useDebugValue(isOnline ? &#39;Online&#39; : &#39;Offline&#39;);
&gt; 
&gt;   return isOnline;
&gt; }
&gt;</code></pre></blockquote>
<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><blockquote>
<p>在自定义函数中封装原有的Hook</p>
<p>约定该函数的名称为 <code>use</code>开头</p>
</blockquote>
<p>官网案例</p>
<p>由于<code>isOnline</code>的值是监听网络的结果决定的，则只需要暴露<code>state</code>即可</p>
<pre><code>import React, { useState, useEffect } from &#39;react&#39;;

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}</code></pre><p>我的案例</p>
<p>当自定义一个Hook，和普通Hook一样使用时，也可以将state对应的操作函数暴露出来</p>
<pre><code>import React, { useState } from &#39;react&#39;
//自定义Hook
export default function useFriendStatus(value) {
    const [isOnline, setIsOnline] = useState(value || false);

    return [isOnline, setIsOnline];
}</code></pre><p>使用</p>
<pre><code>import React from &#39;react&#39;
import { useFriendStatus } from &#39;./hooks&#39;;
export default props =&gt; {
    const [online, setOnline] = useFriendStatus(false);

    return &lt;div&gt;
        {online ? &#39;true&#39; : &#39;false&#39;}
        &lt;button onClick={() =&gt; { setOnline(!online) }}&gt;SWITCH&lt;/button&gt;
    &lt;/div&gt;
}</code></pre><h2 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h2><h3 id="1、只在组件顶层中使用Hook"><a href="#1、只在组件顶层中使用Hook" class="headerlink" title="1、只在组件顶层中使用Hook"></a>1、只在组件顶层中使用Hook</h3><blockquote>
<p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong> 确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p>
</blockquote>
<pre><code>import React, { useState } from &#39;react&#39;

function Example(props) {
    const [count, setCount] = useState(0); //Yes

    if(props.id){
        // const [count, setCount] = useState(0); //No
    }

       const fn = () =&gt; {
        // const [count, setCount] = useState(0); //No
    }

    return &lt;div&gt;&lt;/div&gt;
}</code></pre><h3 id="2、只在React-函数中调用Hook"><a href="#2、只在React-函数中调用Hook" class="headerlink" title="2、只在React 函数中调用Hook"></a>2、只在React 函数中调用Hook</h3><blockquote>
<p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong>你可以：</p>
<ul>
<li>在 React 的函数组件中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook</li>
</ul>
<p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p>
</blockquote>
<h3 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h3><ol>
<li>Hook在函数组件中使用（这里不称为 无状态组件），在class组件中是不起作用的</li>
<li>所有的Hook都是在DOM更新之后执行的</li>
</ol>
<h2 id="经验笔记"><a href="#经验笔记" class="headerlink" title="经验笔记"></a>经验笔记</h2><ol>
<li><p><strong>useState</strong>将函数入参给useState时，该函数是在DOM渲染前执行的</p>
<pre><code>const [value,setValue] = useState(()=&gt;{
    console.log(&#39;笨鸟先飞&#39;);
    return 0
})</code></pre></li>
<li><p><strong>useEffect</strong>是在DOM渲染结束后执行的</p>
</li>
<li><p><strong>useLayoutEffect</strong>与DOM渲染同步进行，在此函数中获取DOM，会导致偶发性报错</p>
</li>
<li><p>组件不要声明在另一个组件内</p>
<pre><code>// 错误
const FatherComponent = (props) =&gt; {
    const SonComponent = () =&gt; { return &lt;div&gt;&lt;/div&gt;}
    return &lt;div&gt;
        &lt;SonComponent&gt;&lt;/SonComponent&gt;
    &lt;/div&gt;
}

// 正确
const SonComponent = () =&gt; { return &lt;div&gt;&lt;/div&gt;}

const FatherComponent = (props) =&gt; {
    return &lt;div&gt;
        &lt;SonComponent&gt;&lt;/SonComponent&gt;
    &lt;/div&gt;
}</code></pre></li>
</ol>
<h2 id="参照文章："><a href="#参照文章：" class="headerlink" title="参照文章："></a>参照文章：</h2><ol>
<li><a href="https://react-1251415695.cos-website.ap-chengdu.myqcloud.com/docs/getting-started.html" target="_blank" rel="noopener">React官方文档</a></li>
<li><a href="https://blog.csdn.net/sinat_17775997/article/details/94453167" target="_blank" rel="noopener">useMemo与useCallback使用指南</a></li>
<li><a href="https://blog.csdn.net/gtLBTNq9mr3/article/details/93984397" target="_blank" rel="noopener">useReducerde使用和原理</a></li>
</ol>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      

    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/study.github.io/lib/jquery/jquery.min.js" ></script>
<script src="/study.github.io/lib/popper/popper.min.js" ></script>
<script src="/study.github.io/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/study.github.io/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/study.github.io/js/main.js" ></script>


  <script src="/study.github.io/js/lazyload.js" ></script>



  <script src="/study.github.io/js/post.js" ></script>
  
    <script src="/study.github.io/lib/tocbot/tocbot.min.js" ></script>
    <script>
      $(document).ready(function () {
        tocbot.init({
          tocSelector: '#tocbot',
          contentSelector: '.post-content',
          headingSelector: 'h1,h2,h3,h4,h5,h6',
          linkClass: 'tocbot-link',
          activeLinkClass: 'tocbot-active-link',
          listClass: 'tocbot-list',
          isCollapsedClass: 'tocbot-is-collapsed',
          collapsibleClass: 'tocbot-is-collapsible',
          scrollSmooth: true,
        });
      });
    </script>
  



  <script src="/study.github.io/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->



  <script src="/study.github.io/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/study.github.io/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Reack Hook&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/study.github.io/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/study.github.io/js/local-search.js" ></script>
  <script>
    var path = "/study.github.io/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/study.github.io/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
